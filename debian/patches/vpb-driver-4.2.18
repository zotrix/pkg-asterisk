Update chan_vpb so that it can work with newer vpb-driver source like the one
present in Debian

 -- Ron <ron@debian.org>

--- a/channels/chan_vpb.cc
+++ b/channels/chan_vpb.cc
@@ -33,6 +33,8 @@
 	<depend>vpbapi</depend>
  ***/
 
+#include <vpbapi.h>
+
 extern "C" {
 
 #include "asterisk.h"
@@ -66,7 +68,6 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include <sys/ioctl.h>
 #include <ctype.h>
 
-#include <vpbapi.h>
 #include <assert.h>
 
 #ifdef pthread_create
@@ -182,7 +183,7 @@ static int use_ast_dtmf=0;
 static int break_for_dtmf=1;
 
 /* Set EC suppression threshold */
-static int ec_supp_threshold=-1;
+static short ec_supp_threshold=-1;
 
 /* Inter Digit Delay for collecting DTMF's */
 static int dtmf_idd = 3000;
@@ -192,26 +193,26 @@ static int dtmf_idd = 3000;
 #define TIMER_PERIOD_RING 4000
 static int timer_period_ring = TIMER_PERIOD_RING;
 	  
-#define VPB_EVENTS_ALL (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP|VPB_MPLAY_UNDERFLOW \
-			|VPB_MRECORD_OVERFLOW|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
+#define VPB_EVENTS_ALL (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP \
+			|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
 			|VPB_MRING_OFF|VPB_MDROP|VPB_MSTATION_FLASH)
-#define VPB_EVENTS_NODROP (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP|VPB_MPLAY_UNDERFLOW \
-			|VPB_MRECORD_OVERFLOW|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
+#define VPB_EVENTS_NODROP (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP \
+			|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
 			|VPB_MRING_OFF|VPB_MSTATION_FLASH)
-#define VPB_EVENTS_NODTMF (VPB_MRING|VPB_MDIGIT|VPB_MTONEDETECT|VPB_MTIMEREXP|VPB_MPLAY_UNDERFLOW \
-			|VPB_MRECORD_OVERFLOW|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
+#define VPB_EVENTS_NODTMF (VPB_MRING|VPB_MDIGIT|VPB_MTONEDETECT|VPB_MTIMEREXP \
+			|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
 			|VPB_MRING_OFF|VPB_MDROP|VPB_MSTATION_FLASH)
-#define VPB_EVENTS_STAT (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP|VPB_MPLAY_UNDERFLOW \
-			|VPB_MRECORD_OVERFLOW|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
+#define VPB_EVENTS_STAT (VPB_MRING|VPB_MDIGIT|VPB_MDTMF|VPB_MTONEDETECT|VPB_MTIMEREXP \
+			|VPB_MSTATION_OFFHOOK|VPB_MSTATION_ONHOOK \
 			|VPB_MRING_OFF|VPB_MSTATION_FLASH)
 
 
 /* Dialing parameters for Australia */
 /* #define DIAL_WITH_CALL_PROGRESS */
-VPB_TONE_MAP DialToneMap[] = { 	{ VPB_BUSY_AUST, VPB_CALL_DISCONNECT, 0 },
+VPB_TONE_MAP DialToneMap[] = { 	{ VPB_BUSY, VPB_CALL_DISCONNECT, 0 },
   				{ VPB_DIAL, VPB_CALL_DIALTONE, 0 },
-				{ VPB_RINGBACK_308, VPB_CALL_RINGBACK, 0 },
-				{ VPB_BUSY_AUST, VPB_CALL_BUSY, 0 },
+				{ VPB_RINGBACK, VPB_CALL_RINGBACK, 0 },
+				{ VPB_BUSY, VPB_CALL_BUSY, 0 },
 				{ VPB_GRUNT, VPB_CALL_GRUNT, 0 },
 				{ 0, 0, 1 } };
 #define VPB_DIALTONE_WAIT 2000 /* Wait up to 2s for a dialtone */
@@ -339,7 +340,7 @@ static struct vpb_pvt {
 
 } *iflist = NULL;
 
-static struct ast_channel *vpb_new(struct vpb_pvt *i, enum ast_channel_state state, char *context);
+static struct ast_channel *vpb_new(struct vpb_pvt *i, enum ast_channel_state state, const char *context);
 static void *do_chanreads(void *pvt);
 static struct ast_channel *vpb_request(const char *type, int format, void *data, int *cause);
 static int vpb_digit_begin(struct ast_channel *ast, char digit);
@@ -378,7 +379,9 @@ static struct ast_channel_tech vpb_tech 
 	queryoption: NULL,
 	transfer: NULL,
 	write_video: NULL,
-	bridged_channel: NULL
+	bridged_channel: NULL,
+	func_channel_read: NULL,
+	func_channel_write: NULL
 };
 
 static struct ast_channel_tech vpb_tech_indicate = {
@@ -406,7 +409,9 @@ static struct ast_channel_tech vpb_tech_
 	queryoption: NULL,
 	transfer: NULL,
 	write_video: NULL,
-	bridged_channel: NULL
+	bridged_channel: NULL,
+	func_channel_read: NULL,
+	func_channel_write: NULL
 };
 
 /* Can't get ast_vpb_bridge() working on v4pci without either a horrible 
@@ -528,7 +533,7 @@ static enum ast_bridge_result ast_vpb_br
 
 	#else
 
-	res = vpb_bridge(p0->handle, p1->handle, VPB_BRIDGE_ON, i+1 /* resource 1 & 2 only for V4PCI*/ );
+	res = vpb_bridge(p0->handle, p1->handle, VPB_BRIDGE_ON);
 	if (res == VPB_OK) {
 		/* pthread_cond_wait(&bridges[i].cond, &bridges[i].lock);*/ /* Wait for condition signal. */
 		while( !bridges[i].endbridge ) {
@@ -592,7 +597,7 @@ static enum ast_bridge_result ast_vpb_br
 			cs[0] = cs[1];
 			cs[1] = cs[2];
 		};
-		vpb_bridge(p0->handle, p1->handle, VPB_BRIDGE_OFF, i+1 /* resource 1 & 2 only for V4PCI*/ ); 
+		vpb_bridge(p0->handle, p1->handle, VPB_BRIDGE_OFF); 
 	}
 
 	#endif
@@ -710,7 +715,7 @@ static void get_callerid(struct vpb_pvt 
 			}
 
 		} else {
-			ast_log(LOG_ERROR, "CID record - Failed to decode caller id on %s - %s\n", p->dev, vpb_strerror(rc) );
+			ast_log(LOG_ERROR, "CID record - Failed to decode caller id on %s - %d\n", p->dev, rc );
 			strncpy(p->callerid,"unknown", sizeof(p->callerid) - 1);
 		}
 		delete cli_struct;
@@ -1011,7 +1016,7 @@ static inline int monitor_handle_owned(s
 			}
 			break;
 
-		case VPB_PLAY_UNDERFLOW:
+/*		case VPB_PLAY_UNDERFLOW:
 			f.frametype = AST_FRAME_NULL;
 			vpb_reset_play_fifo_alarm(p->handle);
 			break;
@@ -1020,7 +1025,7 @@ static inline int monitor_handle_owned(s
 			f.frametype = AST_FRAME_NULL;
 			vpb_reset_record_fifo_alarm(p->handle);
 			break;
-
+*/
 		default:
 			f.frametype = AST_FRAME_NULL;
 			break;
@@ -1298,7 +1303,7 @@ static inline int monitor_handle_notowne
 				}
 			} else if (!ast_canmatch_extension(NULL, p->context, p->ext, 1, p->callerid)){
 				if (ast_exists_extension(NULL, "default", p->ext, 1, p->callerid)) {
-					vpb_new(p,AST_STATE_UP, "default");	      
+					vpb_new(p,AST_STATE_UP, "default");
 				} else if (!ast_canmatch_extension(NULL, "default", p->ext, 1, p->callerid)) {
 					if (option_verbose > 3) {
 						ast_verbose(VERBOSE_PREFIX_4 "%s: handle_notowned: can't match anything in %s or default\n", p->dev, p->context);
@@ -1360,8 +1365,8 @@ static void *do_monitor(void *unused)
 		}
 
 		if (res != VPB_OK) {
-			ast_log(LOG_ERROR,"Monitor get event error %s\n", vpb_strerror(res) );
-			ast_verbose("Monitor get event error %s\n", vpb_strerror(res) );
+			ast_log(LOG_ERROR,"Monitor get event error %d\n", res );
+			ast_verbose("Monitor get event error %d\n", res );
 			continue;
 		}
 
@@ -1469,7 +1474,7 @@ static int restart_monitor(void)
 				/* Why do other drivers kill the thread? No need says I, simply awake thread with event. */
 				VPB_EVENT e;
 				e.handle = 0;
-				e.type = VPB_NULL_EVENT;
+				e.type = VPB_EVT_NONE;
 				e.data = 0;
 
 				if (option_verbose > 3)
@@ -1526,11 +1531,7 @@ static void mkbrd(vpb_model_t model, int
 			vpb_echo_canc_enable();
 			ast_log(LOG_NOTICE, "Voicetronix echo cancellation ON\n");
 			if (ec_supp_threshold > -1){
-				#ifdef VPB_PRI
-				vpb_echo_canc_set_sup_thresh(0,(short *)&ec_supp_threshold);
-				#else
-				vpb_echo_canc_set_sup_thresh((short *)&ec_supp_threshold);
-				#endif
+				vpb_echo_canc_set_sup_thresh(0, &ec_supp_threshold);
 				ast_log(LOG_NOTICE, "Voicetronix EC Sup Thres set\n");
 			}
 		}
@@ -1646,7 +1647,7 @@ static struct vpb_pvt *mkif(int board, i
 	}
 
 	tmp->vpb_model = vpb_model_unknown;
-	if( vpb_get_model(buf) == VPB_OK ) {
+	if( vpb_get_model(tmp->handle, buf) == VPB_OK ) {
 		if(strcmp(buf,"V12PCI")==0) 
 			tmp->vpb_model = vpb_model_v12pci;
 		else if(strcmp(buf,"VPB4")==0) 
@@ -1874,7 +1875,7 @@ static int vpb_digit_end(struct ast_chan
 static int vpb_call(struct ast_channel *ast, char *dest, int timeout)
 {
 	struct vpb_pvt *p = (struct vpb_pvt *)ast->tech_pvt;
-	int res = 0,i;
+	int res = 0, i;
 	char *s = strrchr(dest, '/');
 	char dialstring[254] = "";
 	int tmp = 0;
@@ -1897,7 +1898,7 @@ static int vpb_call(struct ast_channel *
 			dialstring[i] = ',';
 		else if ((dialstring[i] == 'f') || (dialstring[i] == 'F'))
 			dialstring[i] = '&';
-	}	
+	}
 
 	if (ast->_state != AST_STATE_DOWN && ast->_state != AST_STATE_RESERVED) {
 		ast_log(LOG_WARNING, "vpb_call on %s neither down nor reserved!\n", ast->name);
@@ -1908,7 +1909,7 @@ static int vpb_call(struct ast_channel *
 		return -1;
 	}
 	if (p->mode != MODE_FXO)  /* Station port, ring it. */
-		res = vpb_ring_station_async(p->handle, VPB_RING_STATION_ON,0);       
+		vpb_ring_station_async(p->handle, 2);
 	else {
 		VPB_CALL call;
 
@@ -1961,17 +1962,17 @@ static int vpb_call(struct ast_channel *
 		#endif
 
 		if (res != VPB_OK) {
-			ast_log(LOG_DEBUG, "Call on %s to %s failed: %s\n", ast->name, s, vpb_strerror(res));	      
+			ast_log(LOG_DEBUG, "Call on %s to %s failed: %d\n", ast->name, s, res);
 			res = -1;
-		} else 
+		} else
 			res = 0;
 	}
 
 	if (option_verbose > 2)
-		ast_verbose(VERBOSE_PREFIX_3 "%s: VPB Calling %s [t=%d] on %s returned %d\n",p->dev , s, timeout, ast->name, res); 
+		ast_verbose(VERBOSE_PREFIX_3 "%s: VPB Calling %s [t=%d] on %s returned %d\n",p->dev , s, timeout, ast->name, res);
 	if (res == 0) {
 		ast_setstate(ast, AST_STATE_RINGING);
-		ast_queue_control(ast,AST_CONTROL_RINGING);		
+		ast_queue_control(ast,AST_CONTROL_RINGING);
 	}
 
 	if (!p->readthread){
@@ -2049,7 +2050,7 @@ static int vpb_hangup(struct ast_channel
 
 	if (p->mode != MODE_FXO) {
 		/* station port. */
-		vpb_ring_station_async(p->handle, VPB_RING_STATION_OFF,0);	
+		vpb_ring_station_async(p->handle, 0);
 		if(p->state!=VPB_STATE_ONHOOK){
 			/* This is causing a "dial end" "play tone" loop
 			playtone(p->handle, &Busytone); 
@@ -2201,7 +2202,7 @@ static struct ast_frame  *vpb_read(struc
 	return &f;
 }
 
-static inline int ast2vpbformat(int ast_format)
+static inline AudioCompress ast2vpbformat(int ast_format)
 {
 	switch(ast_format) {
 		case AST_FORMAT_ALAW:
@@ -2213,11 +2214,11 @@ static inline int ast2vpbformat(int ast_
 		case AST_FORMAT_ADPCM:
 			return VPB_OKIADPCM;
 		default:
-			return -1;
+			return VPB_RAW;
 	}
 }
 
-static inline char * ast2vpbformatname(int ast_format)
+static inline const char * ast2vpbformatname(int ast_format)
 {
 	switch(ast_format) {
 		case AST_FORMAT_ALAW:
@@ -2245,7 +2246,7 @@ static inline int astformatbits(int ast_
 			return 4;
 		default:
 			return 8;
-	}   
+	}
 }
 
 int a_gain_vector(float g, short *v, int n) 
@@ -2267,7 +2268,8 @@ int a_gain_vector(float g, short *v, int
 static int vpb_write(struct ast_channel *ast, struct ast_frame *frame)
 {
 	struct vpb_pvt *p = (struct vpb_pvt *)ast->tech_pvt; 
-	int res = 0, fmt = 0;
+	int res = 0;
+	AudioCompress fmt = VPB_RAW;
 	struct timeval play_buf_time_start;
 	int tdiff;
 
@@ -2371,7 +2373,8 @@ static void *do_chanreads(void *pvt)
 	struct ast_frame *fr = &p->fr;
 	char *readbuf = ((char *)p->buf) + AST_FRIENDLY_OFFSET;
 	int bridgerec = 0;
-	int afmt, readlen, res, fmt, trycnt=0;
+	int afmt, readlen, res,trycnt=0;
+	AudioCompress fmt;
 	int ignore_dtmf;
 	const char * getdtmf_var = NULL;
 
@@ -2497,7 +2500,7 @@ static void *do_chanreads(void *pvt)
 
 		if (p->lastinput == -1) {
 			vpb_record_buf_start(p->handle, fmt);
-			vpb_reset_record_fifo_alarm(p->handle);
+/*			vpb_reset_record_fifo_alarm(p->handle); */
 			p->lastinput = fmt;
 			if(option_verbose>1) 
 				ast_verbose( VERBOSE_PREFIX_2 "%s: Starting record mode (codec=%d)[%s]\n",p->dev,fmt,ast2vpbformatname(afmt));
@@ -2621,7 +2624,7 @@ static void *do_chanreads(void *pvt)
 	return NULL;
 }
 
-static struct ast_channel *vpb_new(struct vpb_pvt *me, enum ast_channel_state state, char *context)
+static struct ast_channel *vpb_new(struct vpb_pvt *me, enum ast_channel_state state, const char *context)
 {
 	struct ast_channel *tmp; 
 	char cid_num[256];
@@ -2663,11 +2666,11 @@ static struct ast_channel *vpb_new(struc
 		tmp->tech_pvt = me;
 		
 		strncpy(tmp->context, context, sizeof(tmp->context)-1);
-		if (strlen(me->ext))
-			strncpy(tmp->exten, me->ext, sizeof(tmp->exten)-1);
+		if (!ast_strlen_zero(me->ext))
+			ast_copy_string(tmp->exten, me->ext, sizeof(tmp->exten));
 		else
-			strncpy(tmp->exten, "s",  sizeof(tmp->exten) - 1);
-		if (strlen(me->language))
+			strcpy(tmp->exten, "s");
+		if (!ast_strlen_zero(me->language))
 			ast_string_field_set(tmp, language, me->language);
 
 		me->owner = tmp;
@@ -2707,7 +2710,7 @@ static struct ast_channel *vpb_request(c
 	int oldformat;
 	struct vpb_pvt *p;
 	struct ast_channel *tmp = NULL;
-	char *name = strdup(data ? (char *)data : "");
+	char emptystring[] = "";
 	char *s, *sepstr;
 	int group=-1;
 
@@ -2718,13 +2721,15 @@ static struct ast_channel *vpb_request(c
 		return NULL;
 	}
 
+	char *name = strdup(data ? (char *)data : emptystring);
+
 	sepstr = name;
 	s = strsep(&sepstr, "/"); /* Handle / issues */
-	if (!s) 
-		s = "";
+	if (!s)
+		s = emptystring;
 	/* Check if we are looking for a group */
 	if (toupper(name[0]) == 'G' || toupper(name[0])=='R') {
-		group=atoi(name+1);	
+		group=atoi(name+1);
 	}
 	/* Search for an unowned channel */
 	ast_mutex_lock(&iflock); {
@@ -2779,7 +2784,7 @@ static float parse_gain_value(char *gain
 }
 
 
-int unload_module()
+static int unload_module(void)
 {
 	struct vpb_pvt *p;
 	/* First, take us out of the channel loop */
@@ -2831,20 +2836,22 @@ int unload_module()
 		iflist = NULL;
 	} ast_mutex_unlock(&iflock);
 
-	ast_mutex_lock(&bridge_lock); {
-		memset(bridges, 0, sizeof bridges);	     
-	} ast_mutex_unlock(&bridge_lock);
-	ast_mutex_destroy(&bridge_lock);
-	for(int i = 0; i < max_bridges; i++ ) {
-		ast_mutex_destroy(&bridges[i].lock);
-		ast_cond_destroy(&bridges[i].cond);
+	if (bridges) {
+		ast_mutex_lock(&bridge_lock); {
+			memset(bridges, 0, sizeof bridges);	     
+		} ast_mutex_unlock(&bridge_lock);
+		ast_mutex_destroy(&bridge_lock);
+		for(int i = 0; i < max_bridges; i++ ) {
+			ast_mutex_destroy(&bridges[i].lock);
+			ast_cond_destroy(&bridges[i].cond);
+		}
+		free(bridges);
 	}
-	free(bridges);
 
 	return 0;
 }
 
-int load_module()
+static enum ast_module_load_result load_module(void)
 {
 	struct ast_config *cfg;
 	struct ast_variable *v;
@@ -2858,7 +2865,7 @@ int load_module()
 	int got_gain=0;
 	int first_channel = 1;
 	int echo_cancel = DEFAULT_ECHO_CANCEL;
-	int error = 0; /* Error flag */
+	enum ast_module_load_result error = AST_MODULE_LOAD_SUCCESS; /* Error flag */
 	int bal1 = -1; /* Special value - means do not set */
 	int bal2 = -1; 
 	int bal3 = -1;
@@ -2872,8 +2879,6 @@ int load_module()
 		return AST_MODULE_LOAD_DECLINE;
 	}  
 
-	vpb_seterrormode(VPB_ERROR_CODE);
-
 	ast_mutex_lock(&iflock); {
 		v = ast_variable_browse(cfg, "general");
 		while (v){
@@ -2909,7 +2914,7 @@ int load_module()
 				timer_period_ring = atoi(v->value);
 			}
 			else if (strcasecmp(v->name, "ecsuppthres") ==0) {
-				ec_supp_threshold = atoi(v->value);
+				ec_supp_threshold = (short)atoi(v->value);
 			}
 			else if (strcasecmp(v->name, "dtmfidd") ==0) {
 				dtmf_idd = atoi(v->value);
@@ -2947,7 +2952,7 @@ int load_module()
 					iflist = tmp;
 				} else {
 					ast_log(LOG_ERROR, "Unable to register channel '%s'\n", v->value);
-					error = -1;
+					error = AST_MODULE_LOAD_FAILURE;
 					goto done;
 				}
 			} else if (strcasecmp(v->name, "language") == 0) {
@@ -3013,18 +3018,18 @@ int load_module()
 	ast_config_destroy(cfg);
 
 	if (use_ast_ind == 1){
-		if (!error && ast_channel_register(&vpb_tech_indicate) != 0) {
+		if (error == AST_MODULE_LOAD_SUCCESS && ast_channel_register(&vpb_tech_indicate) != 0) {
 			ast_log(LOG_ERROR, "Unable to register channel class 'vpb'\n");
-			error = -1;
+			error = AST_MODULE_LOAD_FAILURE;
 		}
 		else {
 			ast_log(LOG_NOTICE,"VPB driver Registered (w/AstIndication)\n");
 		}
 	}
 	else {
-		if (!error && ast_channel_register(&vpb_tech) != 0) {
+		if (error == AST_MODULE_LOAD_SUCCESS && ast_channel_register(&vpb_tech) != 0) {
 			ast_log(LOG_ERROR, "Unable to register channel class 'vpb'\n");
-			error = -1;
+			error = AST_MODULE_LOAD_FAILURE;
 		}
 		else {
 			ast_log(LOG_NOTICE,"VPB driver Registered )\n");
@@ -3032,7 +3037,7 @@ int load_module()
 	}
 
 
-	if (error)
+	if (error != AST_MODULE_LOAD_SUCCESS)
 		unload_module();
 	else 
 		restart_monitor(); /* And start the monitor for the first time */
@@ -3040,10 +3045,12 @@ int load_module()
 	return error;
 }
 
+/*
 int usecount()
 {
 	return usecnt;
 }
+*/
 
 const char *description()
 {
@@ -3055,10 +3062,21 @@ const char *key()
 	return ASTERISK_GPL_KEY;
 }
 
+static int reload_module(void)
+{
+
+	return 0;
+
+}
+
+AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_DEFAULT, "Voicetronix VPB Card Driver",
+		load_module,
+		unload_module,
+		reload_module
+);
+
 /**/
 #if defined(__cplusplus) || defined(c_plusplus)
  }
 #endif
 /**/
-
-
--- a/configs/vpb.conf.sample
+++ b/configs/vpb.conf.sample
@@ -1,108 +1,248 @@
 ;
-; V6PCI/V12PCI config file for VoiceTronix Hardware
+; Voicetronix Voice Processing Board (VPB) telephony interface
 ;
-; Options for [general] section
+; Configuration file
 ;
-; type = v12pci|v6pci|v4pci
-; cards = number of cards
-;    To use Asterisk indication tones
-; indication = 1
-;    none,-24db,-18db only for use with OpenLine4
-; ecsuppthres = 0|2048|4096
-;    Inter Digit Delay timeout for when collecting DTMF tones for dialling
-;    from a Station port, in ms
-; dtmfidd = 3000
-;    To use Asterisk DTMF detection
-; ast-dtmf-det=1
-;    Used with ast-dtmf-det
-; relaxdtmf=1
-;    When a native bridge occurs between 2 vpb channels, it will only break
-;    the connection for '#' and '*'
-; break-for-dtmf=no
-;    Set the maximum period between received rings, default 4000ms
-; timer_period_ring=4000
-;
-; Options for [interface] section
-; board = board_number (1, 2, 3, ...)
-; channel = channel_number (1,2,3...)
-; mode = fxo|immediate|dialtone -- for type of line and line handling
-; context = starting context
-; echocancel = on|off (on by default of v4pci, off by default for others)
-; callerid = on|off|v23|bell (on => to collect caller ID if available between 1st/2nd rings using vpb functions)
-;                            (v23|bell => collect caller ID using asterisk functions)
-;            Or for use with FXS channels a '"name" <location>' format can be used to set the channels CID
-;
-; UseLoopDrop = 0|1 (enables the use of Loop Drop detection, on by default in
-;                    some cases spurious loop-drops can cause unexpected 
-;                    hangup detection)
-; 
-; Gain settings
-; txgain  => Transmit Software Gain (-12 => 12)
-; rxgain  => Receive Software Gain (-12 => 12)
-; txhwgain => Transmit hardware gain (-12 => 12)
-; rxhwgain => Receive Hardware gain (-12 => 12)
-;
-; These are advanced settings and only mentioned for completeness.
-; bal1  => Hybrid balance codec register 1
-; bal2  => Hybrid balance codec register 2
-; bal3  => Hybrid balance codec register 3
-;
-; Dial translations - if you want a pause or hook-flash in your dial string
-; you can use "w" for pause (wait) or "f" for "hook-flash", eg:
-; exten => _9XXX,1,Dial(vpb/g1/ww${EXTEN:${TRUNKMSD}})
+
+[general]
 ;
+; Total number of Voicetronix cards in this machine
 ;
+cards=1
+
+;
+; Which indication functions to use
+;    1 = use Asterisk functions
+;    0 = use VPB functions
+;
+indication=1
+
+;
+; Echo Canceller suppression threshold
+;    0    = no suppression threshold
+;    2048 = -18dB
+;    4096 = -24dB
+;
+;ecsuppthres=0
+
+;
+; Inter-digit delay timeout, used when collecting DTMF tones for dialling
+; from a station port.  Measured in milliseconds.
+;
+dtmfidd=3000
+
+;
+; How to play DTMF tones
+;    any value     = use Asterisk functions
+;    commented out = use VPB functions
+;
+;ast-dtmf=1
+
+;
+; How to detect DTMF tones
+;    any value     = use Asterisk functions
+;    commented out = use VPB functions
+;
+; NOTE: this setting is currently broken, and uncommenting it will
+; stop dialling from working.  Any volunteers to fix it?
+;ast-dtmf-det=1
+
+;
+; Use relaxed DTMF detection (ignored unless ast-dtmf-det is set)
+;
+relaxdtmf=1
+
+;
+; When we do a native bridge between two VPB channels:
+;    yes = only break the connection for '#' and '*'
+;    no  = break the connection for any DTMF
+;
+; NOTE: this is currently broken, and setting to no will segfault
+; Asterisk while dialling.  Any volunteers to fix it?
+;
+break-for-dtmf=yes
+
+;
+; The maximum period between received rings.  Measures in milliseconds.
+;
+timer_period_ring=4000
 
-[general]
-type = v12pci
-;type = v6pci
-;type = v4pci
-cards = 1
 
 [interfaces]
+;
+; Default language
+;
+language=en
+
+;
+; Default context
+;
+context=default
+
+;
+; Echo cancellation
+;     off  = no not use echo cancellation
+;     on   = use echo cancellation
+;
+echocancel=off
+
+;
+; Caller ID routines/signalling
+;   For FXO ports, select one of:
+;     on   = collect caller ID between 1st/2nd rings using VPB routines
+;     off  = do not use caller ID
+;     bell = bell202 as used in US, using Asterisk's caller ID routines
+;     v23  = v23 as used in the UK, using Asterisk's caller ID routines
+;   For FXS ports, set the channel's CID in '"name" <number>' format
+;
+; NOTE that other caller ID standards are supported in Asterisk, but are
+; not yet active in chan_vpb.  It should be reasonably trivial to add
+; support for the other standards (see the default zapata.conf for a list
+; of them) that Asterisk already handles.
+;
+callerid=bell
 
-board = 0
-echocancel = on
+;
+; Use a polarity reversal as the trigger for the start of caller ID,
+; rather than triggering after the first ring.
+;
+usepolaritycid=0
+
+;
+; Use loop drop to detect the end of a call.  On by default, but if you
+; experience unexpected hangups, try turning it off.
+;
+useloopdrop=1
+
+;
+; Use in-kernel bridging.  This will generally give lower delay audio if
+; bridging between two VPB channels.  It will not affect bridging
+; between VPB channels and other technologies.
+;
+usenativebridge=1
+
+;
+; Software transmit and receive gain.  Adjusting these will change the
+; volume of audio files that are played (tx) and recorded (rx).  It will
+; _not_ affect audio between channels in a native bridge.  It will,
+; however, affect the volume of audio between VPB channels and channels
+; using other technologies (such as VoIP channels).  Usually it's best to
+; leave these as they are.  If you're looking to get rid of echo, the
+; first thing to do is match your line impedance with the bal1/bal2/bal3
+; settings.
+;
+;txgain=0.0
+;rxgain=0.0
+
+;
+; Hardware transmit and receive gain.  Adjusting these will change the
+; volume of all audio on a channel.  The allowed range of settings is
+; -12.0 to 12.0 (measured in dB).
+;
+;txhwgain=0.0
+;rxhwgain=0.0
+
+;
+; Balance register settings, for matching the impedance of the card to
+; that of the connected equipment.  Only relevant for OpenLine and
+; OpenSwitch series cards.  Values should be in the range 0 - 255.
+;
+; We (Voicetronix) have determined the best codec balance values for
+; standard interfaces based on their US, Australian and European
+; specifications, shown below.
+;
+; US (600 ohm)
+;bal1=0xf8
+;bal2=0x1a
+;bal3=0x0c
+;
+; Australia (complex impedance)
+;bal1=0xf0
+;bal2=0x5d
+;bal3=0x79
+;
+; Europe (CTR-21)
+;bal1=0xf0
+;bal2=0x6e
+;bal3=0x75
 
+;
+; Logical groups can be assigned to allow outgoing rollover.  Groups range
+; from 0 to 63, and multiple groups can be specified.
+;
+group=1
+
+;
+; Ring groups (a.k.a. call groups) and pickup groups.  If a phone is
+; ringing and it is a member of a group which is one of your pickup
+; groups, then you can answer it by picking up and dialling *8#.  For
+; simple offices, just make these both the same.  Groups range from 0 to
+; 63.
+;
+callgroup=1
+pickupgroup=1
+
+;
+; If we haven't had a "grunt" (voice activity detection) for this many
+; seconds, then we hang up the line due to inactivity.  Default is one
+; hour.
+;
+grunttimeout=3600
+
+;
+; Type of line and line handling.  This setting will usually be overridden
+; on a per channel basis.  Valid settings are:
+;     fxo       = this is an FXO port
+;     immediate = this is an FXS port, with no dialtone or dialling
+;                   required (ie it is a "hotline")
+;     dialtone  = this is an FXS port, providing dialtone and dialling
+;
+mode=immediate
 
-; For OpenLine4 cards
-;context = demo
-;mode = fxo
-;channel = 0
-;channel = 1
-;channel = 2
-;channel = 3
-
-; For OpenSwith12 with jumpers at factory default
-context = demo
-mode = fxo
-channel = 8
-channel = 9
-channel = 10
-channel = 11
-
-context = local
-mode = dialtone
-channel = 0
-channel = 1
-channel = 2
-channel = 3
-channel = 4
-channel = 5
-channel = 6
-channel = 7
-;
-; For OpenSwitch6
-; Note that V6PCI channel numbers start at 7!
-;context = demo
-;mode = fxo
-;channel = 6
-;channel = 7
-
-;mode = dialtone
-;channel = 8
-;channel = 9
-;channel = 10
-;channel = 11
+;-------------------------------------------------------------------------
+; Channel definitions
+;
+; Each channel inherits the settings specified above, unless the are
+; overridden.  As a minimum, the board number and channel number must be
+; set, starting from 0 for the first board, and for the channels on each
+; board.  For example, board 0, channels 0 to 11, then board 1, channels
+; 0 to 11 for two OpenSwitch12 cards.
+;
 
+;
+; First board is an OpenSwitch12 card (jumpers at factory defaults)
+;
+;board=0
+;
+;mode=dialtone
+;context=from-handset
+;group=1
+;channel=0
+;channel=1
+;channel=2
+;channel=3
+;channel=4
+;channel=5
+;channel=6
+;channel=7
+;
+;mode=fxo
+;context=from-pstn
+;group=2
+;channel=8
+;channel=9
+;channel=10
+;channel=11
 
+;
+; Second board is an OpenLine4
+;
+;board=1
+;
+;mode=fxo
+;group=2
+;context=from-pstn
+;channel=0
+;channel=1
+;channel=2
+;channel=3
--- a/channels/Makefile
+++ b/channels/Makefile
@@ -123,5 +123,3 @@ misdn_config.o: ASTCFLAGS+=-Imisdn
 misdn/isdn_lib.o: ASTCFLAGS+=-Wno-strict-aliasing
 
 $(if $(filter chan_misdn,$(EMBEDDED_MODS)),modules.link,chan_misdn.so): chan_misdn.o misdn_config.o misdn/isdn_lib.o misdn/isdn_msg_parser.o
-
-chan_vpb.oo: ASTCFLAGS:=$(filter-out -Wdeclaration-after-statement,$(ASTCFLAGS))
