From: Russell Bryant <russell@digium.com>
Date: Tue, 3 May 2011 19:55:49 +0000
Subject: Fix a bunch of compiler warnings generated by gcc 4.6.0.

Most of these are -Wunused-but-set-variable, but there were a few others
mixed in here, as well.

Including the fixe from upstream commit r319083.

This is a patch from upstream and will be included in 1.8.5 or 1.8.6.

Origin: http://svnview.digium.com/svn/asterisk?view=rev&rev=316265
---
 apps/app_amd.c                 |    3 ---
 apps/app_festival.c            |    8 --------
 apps/app_followme.c            |    2 --
 apps/app_ices.c                |    3 ---
 apps/app_minivm.c              |   24 ++++++++++++++----------
 apps/app_originate.c           |    5 ++---
 apps/app_queue.c               |    5 ++---
 apps/app_voicemail.c           |    2 --
 channels/chan_agent.c          |    8 +-------
 channels/chan_phone.c          |   10 ++++------
 channels/chan_skinny.c         |   23 +++--------------------
 channels/chan_unistim.c        |    4 +---
 codecs/lpc10/dyptrk.c          |    3 +--
 formats/format_wav.c           |    3 +--
 funcs/func_enum.c              |    6 ++----
 include/asterisk/linkedlists.h |    3 ++-
 main/asterisk.c                |    9 ++++-----
 main/audiohook.c               |   18 ++++++------------
 main/cdr.c                     |   11 -----------
 main/channel.c                 |    3 +--
 main/config.c                  |    3 +--
 main/dsp.c                     |    2 --
 main/features.c                |   11 ++---------
 main/fskmodem_float.c          |    5 +----
 main/manager.c                 |    2 +-
 main/pbx.c                     |    7 +++----
 main/plc.c                     |    2 --
 main/rtp_engine.c              |   18 ++++++------------
 main/udptl.c                   |    2 --
 pbx/pbx_config.c               |    7 +------
 res/res_agi.c                  |   11 +++++------
 res/res_calendar.c             |    7 +++----
 res/res_fax.c                  |   12 +++---------
 res/res_musiconhold.c          |    4 ----
 34 files changed, 70 insertions(+), 176 deletions(-)

diff --git a/apps/app_amd.c b/apps/app_amd.c
index c978ce0..8e2d644 100644
--- a/apps/app_amd.c
+++ b/apps/app_amd.c
@@ -156,7 +156,6 @@ static void isAnsweringMachine(struct ast_channel *chan, const char *data)
 	int iTotalTime = 0;
 	int iWordsCount = 0;
 	int currentState = STATE_IN_WORD;
-	int previousState = STATE_IN_SILENCE;
 	int consecutiveVoiceDuration = 0;
 	char amdCause[256] = "", amdStatus[256] = "";
 	char *parse = ast_strdupa(data);
@@ -301,7 +300,6 @@ static void isAnsweringMachine(struct ast_channel *chan, const char *data)
 				
 				if (silenceDuration >= betweenWordsSilence) {
 					if (currentState != STATE_IN_SILENCE ) {
-						previousState = currentState;
 						ast_verb(3, "AMD: Channel [%s]. Changed state to STATE_IN_SILENCE\n", chan->name);
 					}
 					/* Find words less than word duration */
@@ -341,7 +339,6 @@ static void isAnsweringMachine(struct ast_channel *chan, const char *data)
 				if (consecutiveVoiceDuration >= minimumWordLength && currentState == STATE_IN_SILENCE) {
 					iWordsCount++;
 					ast_verb(3, "AMD: Channel [%s]. Word detected. iWordsCount:%d\n", chan->name, iWordsCount);
-					previousState = currentState;
 					currentState = STATE_IN_WORD;
 				}
 				if (consecutiveVoiceDuration >= maximumWordLength){
diff --git a/apps/app_festival.c b/apps/app_festival.c
index ef8827a..2ab5616 100644
--- a/apps/app_festival.c
+++ b/apps/app_festival.c
@@ -163,7 +163,6 @@ static int send_waveform_to_channel(struct ast_channel *chan, char *waveform, in
 {
 	int res = 0;
 	int fds[2];
-	int pid = -1;
 	int needed = 0;
 	int owriteformat;
 	struct ast_frame *f;
@@ -195,7 +194,6 @@ static int send_waveform_to_channel(struct ast_channel *chan, char *waveform, in
 	
 	res = send_waveform_to_fd(waveform, length, fds[1]);
 	if (res >= 0) {
-		pid = res;
 		/* Order is important -- there's almost always going to be mp3...  we want to prioritize the
 		   user */
 		for (;;) {
@@ -257,10 +255,6 @@ static int send_waveform_to_channel(struct ast_channel *chan, char *waveform, in
 	close(fds[0]);
 	close(fds[1]);
 
-#if 0
-	if (pid > -1)
-		kill(pid, SIGKILL);
-#endif
 	if (!res && owriteformat)
 		ast_set_write_format(chan, owriteformat);
 	return res;
@@ -284,7 +278,6 @@ static int festival_exec(struct ast_channel *chan, const char *vdata)
 	char ack[4];
 	char *waveform;
 	int filesize;
-	int wave;
 	char bigstring[MAXFESTLEN];
 	int i;
 	struct MD5Context md5ctx;
@@ -493,7 +486,6 @@ static int festival_exec(struct ast_channel *chan, const char *vdata)
 
 	/* Read back info from server */
 	/* This assumes only one waveform will come back, also LP is unlikely */
-	wave = 0;
 	do {
 		int read_data;
 		for (n = 0; n < 3; ) {
diff --git a/apps/app_followme.c b/apps/app_followme.c
index a71a683..941da52 100644
--- a/apps/app_followme.c
+++ b/apps/app_followme.c
@@ -790,7 +790,6 @@ static void findmeexec(struct fm_args *tpargs)
 	char *rest, *number;
 	struct findme_user *tmpuser;
 	struct findme_user *fmuser;
-	struct findme_user *headuser;
 	struct findme_user_listptr *findme_user_list;
 	int status;
 
@@ -901,7 +900,6 @@ static void findmeexec(struct fm_args *tpargs)
 
 		fmuser = NULL;
 		tmpuser = NULL;
-		headuser = NULL;
 		if (winner)
 			break;
 
diff --git a/apps/app_ices.c b/apps/app_ices.c
index f2b9498..cfe4296 100644
--- a/apps/app_ices.c
+++ b/apps/app_ices.c
@@ -112,7 +112,6 @@ static int ices_exec(struct ast_channel *chan, const char *data)
 	int pid = -1;
 	int flags;
 	int oreadformat;
-	struct timeval last;
 	struct ast_frame *f;
 	char filename[256]="";
 	char *c;
@@ -122,8 +121,6 @@ static int ices_exec(struct ast_channel *chan, const char *data)
 		return -1;
 	}
 	
-	last = ast_tv(0, 0);
-	
 	if (pipe(fds)) {
 		ast_log(LOG_WARNING, "Unable to create pipe\n");
 		return -1;
diff --git a/apps/app_minivm.c b/apps/app_minivm.c
index 5537369..196f8fc 100644
--- a/apps/app_minivm.c
+++ b/apps/app_minivm.c
@@ -1266,13 +1266,22 @@ static int sendmail(struct minivm_template *template, struct minivm_account *vmu
 		char tmpcmd[PATH_MAX];
 		int tmpfd;
 
+		/**
+		 * XXX
+		 * /bug tmpfd is a leaked fd.  The file is also never unlinked.
+		 *      See app_voicemail.c for how the code works there that
+		 *      doesn't have this bug.
+		 */
+
 		ast_copy_string(newtmp, "/tmp/XXXXXX", sizeof(newtmp));
 		ast_debug(3, "newtmp: %s\n", newtmp);
 		tmpfd = mkstemp(newtmp);
-		snprintf(tmpcmd, sizeof(tmpcmd), "sox -v %.4f %s.%s %s.%s", vmu->volgain, filename, format, newtmp, format);
-		ast_safe_system(tmpcmd);
-		finalfilename = newtmp;
-		ast_debug(3, "VOLGAIN: Stored at: %s.%s - Level: %.4f - Mailbox: %s\n", filename, format, vmu->volgain, vmu->username);
+		if (tmpfd > -1) {
+			snprintf(tmpcmd, sizeof(tmpcmd), "sox -v %.4f %s.%s %s.%s", vmu->volgain, filename, format, newtmp, format);
+			ast_safe_system(tmpcmd);
+			finalfilename = newtmp;
+			ast_debug(3, "VOLGAIN: Stored at: %s.%s - Level: %.4f - Mailbox: %s\n", filename, format, vmu->volgain, vmu->username);
+		}
 	} else {
 		finalfilename = ast_strdupa(filename);
 	}
@@ -1828,7 +1837,6 @@ static int leave_voicemail(struct ast_channel *chan, char *username, struct leav
 	char callerid[256];
 	FILE *txt;
 	int res = 0, txtdes;
-	int msgnum;
 	int duration = 0;
 	char date[256];
 	char tmpdir[PATH_MAX];
@@ -1871,7 +1879,6 @@ static int leave_voicemail(struct ast_channel *chan, char *username, struct leav
 		pbx_builtin_setvar_helper(chan, "MVM_RECORD_STATUS", "FAILED");
 		return res;
 	}
-	msgnum = 0;
 
 	userdir = check_dirpath(tmpdir, sizeof(tmpdir), vmu->domain, username, "tmp");
 
@@ -2452,7 +2459,6 @@ static int minivm_accmess_exec(struct ast_channel *chan, const char *data)
 	char *message = NULL;
 	char *prompt = NULL;
 	int duration;
-	int cmd;
 
 	if (ast_strlen_zero(data))  {
 		ast_log(LOG_ERROR, "MinivmAccmess needs at least two arguments: account and option\n");
@@ -2526,7 +2532,7 @@ static int minivm_accmess_exec(struct ast_channel *chan, const char *data)
 	}
 	snprintf(filename,sizeof(filename), "%s%s/%s/%s", MVM_SPOOL_DIR, vmu->domain, vmu->username, message);
 	/* Maybe we should check the result of play_record_review ? */
-	cmd = play_record_review(chan, prompt, filename, global_maxgreet, default_vmformat, 0, vmu, &duration, NULL, FALSE);
+	play_record_review(chan, prompt, filename, global_maxgreet, default_vmformat, 0, vmu, &duration, NULL, FALSE);
 
 	ast_debug(1, "Recorded new %s message in %s (duration %d)\n", message, filename, duration);
 
@@ -3238,12 +3244,10 @@ static int minivm_account_func_read(struct ast_channel *chan, const char *cmd, c
 		check_dirpath(buf, len, vmu->domain, vmu->username, NULL);
 	} else {	/* Look in channel variables */
 		struct ast_variable *var;
-		int found = 0;
 
 		for (var = vmu->chanvars ; var ; var = var->next)
 			if (!strcmp(var->name, colname)) {
 				ast_copy_string(buf, var->value, len);
-				found = 1;
 				break;
 			}
 	}
diff --git a/apps/app_originate.c b/apps/app_originate.c
index 659ea29..3d2594d 100644
--- a/apps/app_originate.c
+++ b/apps/app_originate.c
@@ -101,7 +101,6 @@ static int originate_exec(struct ast_channel *chan, const char *data)
 	char *parse;
 	char *chantech, *chandata;
 	int res = -1;
-	int outgoing_res = 0;
 	int outgoing_status = 0;
 	static const unsigned int timeout = 30;
 	static const char default_exten[] = "s";
@@ -148,14 +147,14 @@ static int originate_exec(struct ast_channel *chan, const char *data)
 		ast_debug(1, "Originating call to '%s/%s' and connecting them to extension %s,%s,%d\n",
 				chantech, chandata, args.arg1, exten, priority);
 
-		outgoing_res = ast_pbx_outgoing_exten(chantech, AST_FORMAT_SLINEAR, chandata,
+		ast_pbx_outgoing_exten(chantech, AST_FORMAT_SLINEAR, chandata,
 				timeout * 1000, args.arg1, exten, priority, &outgoing_status, 0, NULL,
 				NULL, NULL, NULL, NULL);
 	} else if (!strcasecmp(args.type, "app")) {
 		ast_debug(1, "Originating call to '%s/%s' and connecting them to %s(%s)\n",
 				chantech, chandata, args.arg1, S_OR(args.arg2, ""));
 
-		outgoing_res = ast_pbx_outgoing_app(chantech, AST_FORMAT_SLINEAR, chandata,
+		ast_pbx_outgoing_app(chantech, AST_FORMAT_SLINEAR, chandata,
 				timeout * 1000, args.arg1, args.arg2, &outgoing_status, 0, NULL,
 				NULL, NULL, NULL, NULL);
 	} else {
diff --git a/apps/app_queue.c b/apps/app_queue.c
index 465356e..48e30b0 100644
--- a/apps/app_queue.c
+++ b/apps/app_queue.c
@@ -4323,7 +4323,6 @@ static int try_calling(struct queue_ent *qe, const char *options, char *announce
 	char *agiexec = NULL;
 	char *macroexec = NULL;
 	char *gosubexec = NULL;
-	int ret = 0;
 	const char *monitorfilename;
 	const char *monitor_exec;
 	const char *monitor_options;
@@ -4838,7 +4837,7 @@ static int try_calling(struct queue_ent *qe, const char *options, char *announce
 					/* We purposely lock the CDR so that pbx_exec does not update the application data */
 					if (qe->chan->cdr)
 						ast_set_flag(qe->chan->cdr, AST_CDR_FLAG_LOCKED);
-					ret = pbx_exec(qe->chan, mixmonapp, mixmonargs);
+					pbx_exec(qe->chan, mixmonapp, mixmonargs);
 					if (qe->chan->cdr)
 						ast_clear_flag(qe->chan->cdr, AST_CDR_FLAG_LOCKED);
 
@@ -4970,7 +4969,7 @@ static int try_calling(struct queue_ent *qe, const char *options, char *announce
 			application = pbx_findapp("agi");
 			if (application) {
 				agiexec = ast_strdupa(agi);
-				ret = pbx_exec(qe->chan, application, agiexec);
+				pbx_exec(qe->chan, application, agiexec);
 			} else
 				ast_log(LOG_WARNING, "Asked to execute an AGI on this channel, but could not find application (agi)!\n");
 		}
diff --git a/apps/app_voicemail.c b/apps/app_voicemail.c
index fcbba79..051b409 100644
--- a/apps/app_voicemail.c
+++ b/apps/app_voicemail.c
@@ -7071,7 +7071,6 @@ static int forward_message(struct ast_channel *chan, char *context, struct vm_st
 	char *dir;
 	int curmsg;
 	char urgent_str[7] = "";
-	char tmptxtfile[PATH_MAX];
 	int prompt_played = 0;
 #ifndef IMAP_STORAGE
 	char msgfile[PATH_MAX], textfile[PATH_MAX], backup[PATH_MAX], backup_textfile[PATH_MAX];
@@ -7084,7 +7083,6 @@ static int forward_message(struct ast_channel *chan, char *context, struct vm_st
 	dir = vms->curdir;
 	curmsg = vms->curmsg;
 
-	tmptxtfile[0] = '\0';
 	while (!res && !valid_extensions) {
 		int use_directory = 0;
 		if (ast_test_flag((&globalflags), VM_DIRECFORWARD)) {
diff --git a/channels/chan_agent.c b/channels/chan_agent.c
index 09b1430..ad330aa 100644
--- a/channels/chan_agent.c
+++ b/channels/chan_agent.c
@@ -886,7 +886,6 @@ int agent_set_base_channel(struct ast_channel *chan, struct ast_channel *base)
 static int agent_hangup(struct ast_channel *ast)
 {
 	struct agent_pvt *p = ast->tech_pvt;
-	int howlong = 0;
 
 	ast_mutex_lock(&p->lock);
 	p->owner = NULL;
@@ -907,11 +906,8 @@ static int agent_hangup(struct ast_channel *ast)
 
 	ast_debug(1, "Hangup called for state %s\n", ast_state2str(ast->_state));
 	if (p->start && (ast->_state != AST_STATE_UP)) {
-		howlong = time(NULL) - p->start;
 		p->start = 0;
-	} else if (ast->_state == AST_STATE_RESERVED) 
-		howlong = 0;
-	else
+	} else
 		p->start = 0; 
 	if (p->chan) {
 		p->chan->_bridge = NULL;
@@ -1855,7 +1851,6 @@ static int login_exec(struct ast_channel *chan, const char *data)
 	int max_login_tries = maxlogintries;
 	struct agent_pvt *p;
 	struct ast_module_user *u;
-	int login_state = 0;
 	char user[AST_MAX_AGENT] = "";
 	char pass[AST_MAX_AGENT];
 	char agent[AST_MAX_AGENT] = "";
@@ -1949,7 +1944,6 @@ static int login_exec(struct ast_channel *chan, const char *data)
 			ast_mutex_lock(&p->lock);
 			if (!strcmp(p->agent, user) &&
 			    !strcmp(p->password, pass) && !p->pending) {
-				login_state = 1; /* Successful Login */
 
 				/* Ensure we can't be gotten until we're done */
 				p->lastdisc = ast_tvnow();
diff --git a/channels/chan_phone.c b/channels/chan_phone.c
index 531b95c..c857924 100644
--- a/channels/chan_phone.c
+++ b/channels/chan_phone.c
@@ -296,12 +296,10 @@ static int phone_call(struct ast_channel *ast, char *dest, int timeout)
 	ast_localtime(&UtcTime, &tm, NULL);
 
 	memset(&cid, 0, sizeof(PHONE_CID));
-	if(&tm != NULL) {
-		snprintf(cid.month, sizeof(cid.month), "%02d",(tm.tm_mon + 1));
-		snprintf(cid.day, sizeof(cid.day),     "%02d", tm.tm_mday);
-		snprintf(cid.hour, sizeof(cid.hour),   "%02d", tm.tm_hour);
-		snprintf(cid.min, sizeof(cid.min),     "%02d", tm.tm_min);
-	}
+    snprintf(cid.month, sizeof(cid.month), "%02d",(tm.tm_mon + 1));
+    snprintf(cid.day, sizeof(cid.day),     "%02d", tm.tm_mday);
+    snprintf(cid.hour, sizeof(cid.hour),   "%02d", tm.tm_hour);
+    snprintf(cid.min, sizeof(cid.min),     "%02d", tm.tm_min);
 	/* the standard format of ast->callerid is:  "name" <number>, but not always complete */
 	if (!ast->connected.id.name.valid
 		|| ast_strlen_zero(ast->connected.id.name.str)) {
diff --git a/channels/chan_skinny.c b/channels/chan_skinny.c
index 9fea7cb..59a61f6 100644
--- a/channels/chan_skinny.c
+++ b/channels/chan_skinny.c
@@ -3482,8 +3482,6 @@ static int manager_skinny_show_lines(struct mansession *s, const struct message
 
 static char *handle_skinny_show_lines(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	int verbose = 0;
-
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "skinny show lines [verbose]";
@@ -3498,9 +3496,7 @@ static char *handle_skinny_show_lines(struct ast_cli_entry *e, int cmd, struct a
 	}
 
 	if (a->argc == e->args) {
-		if (!strcasecmp(a->argv[e->args-1], "verbose")) {
-			verbose = 1;
-		} else {
+		if (strcasecmp(a->argv[e->args-1], "verbose")) {
 			return CLI_SHOWUSAGE;
 		}
 	} else if (a->argc != e->args - 1) {
@@ -3913,7 +3909,6 @@ static void *skinny_ss(void *data)
 static int skinny_call(struct ast_channel *ast, char *dest, int timeout)
 {
 	int res = 0;
-	int tone = 0;
 	struct skinny_subchannel *sub = ast->tech_pvt;
 	struct skinny_line *l = sub->parent;
 	struct skinny_device *d = l->device;
@@ -3943,10 +3938,8 @@ static int skinny_call(struct ast_channel *ast, char *dest, int timeout)
 	
 	switch (l->hookstate) {
 	case SKINNY_OFFHOOK:
-		tone = SKINNY_CALLWAITTONE;
 		break;
 	case SKINNY_ONHOOK:
-		tone = SKINNY_ALERT;
 		l->activesub = sub;
 		break;
 	default:
@@ -3975,7 +3968,6 @@ static int skinny_hangup(struct ast_channel *ast)
 	struct skinny_subchannel *sub = ast->tech_pvt;
 	struct skinny_line *l;
 	struct skinny_device *d;
-	struct skinnysession *s;
 
 	if (!sub) {
 		ast_debug(1, "Asked to hangup channel not connected\n");
@@ -3984,7 +3976,6 @@ static int skinny_hangup(struct ast_channel *ast)
 
 	l = sub->parent;
 	d = l->device;
-	s = d->session;
 
 	if (skinnydebug)
 		ast_verb(3,"Hanging up %s/%d\n",d->name,sub->callid);
@@ -5300,7 +5291,6 @@ static int handle_offhook_message(struct skinny_req *req, struct skinnysession *
 	struct skinny_line *tmp;
 	pthread_t t;
 	int instance;
-	int reference;
 
 	/* if any line on a device is offhook, than the device must be offhook, 
 	   unless we have shared lines CCM seems that it would never get here, 
@@ -5316,7 +5306,6 @@ static int handle_offhook_message(struct skinny_req *req, struct skinnysession *
 	}
 
 	instance = letohl(req->data.offhook.instance);
-	reference = letohl(req->data.offhook.reference);
 
 	if (instance) {
 		sub = find_subchannel_by_instance_reference(d, d->lastlineinstance, d->lastcallreference);
@@ -6629,15 +6618,11 @@ static int skinny_devicestate(void *data)
 
 static struct ast_channel *skinny_request(const char *type, format_t format, const struct ast_channel *requestor, void *data, int *cause)
 {
-	format_t oldformat;
-	
 	struct skinny_line *l;
 	struct ast_channel *tmpc = NULL;
 	char tmp[256];
 	char *dest = data;
 
-	oldformat = format;
-	
 	if (!(format &= AST_FORMAT_AUDIO_MASK)) {
 		ast_log(LOG_NOTICE, "Asked to get a channel of unsupported format '%s'\n", ast_getformatname_multiple(tmp, sizeof(tmp), format));
 		return NULL;
@@ -7218,8 +7203,6 @@ static struct ast_channel *skinny_request(const char *type, format_t format, con
   	int on = 1;
   	struct ast_config *cfg;
   	char *cat;
-  	struct skinny_device *d;
- 	struct skinny_line *l;
   	int oldport = ntohs(bindaddr.sin_port);
   	struct ast_flags config_flags = { 0 };
  	
@@ -7268,7 +7251,7 @@ static struct ast_channel *skinny_request(const char *type, format_t format, con
 	config_parse_variables(TYPE_DEF_LINE, default_line, ast_variable_browse(cfg, "lines"));
 	cat = ast_category_browse(cfg, "lines");
 	while (cat && strcasecmp(cat, "general") && strcasecmp(cat, "devices")) {
-		l = config_line(cat, ast_variable_browse(cfg, cat));
+		config_line(cat, ast_variable_browse(cfg, cat));
 		cat = ast_category_browse(cfg, cat);
 	}
 		
@@ -7278,7 +7261,7 @@ static struct ast_channel *skinny_request(const char *type, format_t format, con
 	config_parse_variables(TYPE_DEF_DEVICE, default_device, ast_variable_browse(cfg, "devices"));
 	cat = ast_category_browse(cfg, "devices");
 	while (cat && strcasecmp(cat, "general") && strcasecmp(cat, "lines")) {
-		d = config_device(cat, ast_variable_browse(cfg, cat));
+		config_device(cat, ast_variable_browse(cfg, cat));
 		cat = ast_category_browse(cfg, cat);
 	}
 
diff --git a/channels/chan_unistim.c b/channels/chan_unistim.c
index 3908207..509d1de 100644
--- a/channels/chan_unistim.c
+++ b/channels/chan_unistim.c
@@ -1892,7 +1892,7 @@ static int attempt_transfer(struct unistim_subchannel *p1, struct unistim_subcha
 	int res = 0;
 	struct ast_channel
 	 *chana = NULL, *chanb = NULL, *bridgea = NULL, *bridgeb = NULL, *peera =
-		NULL, *peerb = NULL, *peerc = NULL, *peerd = NULL;
+		NULL, *peerb = NULL, *peerc = NULL;
 
 	if (!p1->owner || !p2->owner) {
 		ast_log(LOG_WARNING, "Transfer attempted without dual ownership?\n");
@@ -1907,12 +1907,10 @@ static int attempt_transfer(struct unistim_subchannel *p1, struct unistim_subcha
 		peera = chana;
 		peerb = chanb;
 		peerc = bridgea;
-		peerd = bridgeb;
 	} else if (bridgeb) {
 		peera = chanb;
 		peerb = chana;
 		peerc = bridgeb;
-		peerd = bridgea;
 	}
 
 	if (peera && peerb && peerc && (peerb != peerc)) {
diff --git a/codecs/lpc10/dyptrk.c b/codecs/lpc10/dyptrk.c
index 216b559..45fb5eb 100644
--- a/codecs/lpc10/dyptrk.c
+++ b/codecs/lpc10/dyptrk.c
@@ -143,7 +143,7 @@ extern struct {
     /* Local variables */
     integer pbar;
     real sbar;
-    integer path[2], iptr, i__, j;
+    integer iptr, i__, j;
     real alpha, minsc, maxsc;
 
 /*       Arguments */
@@ -389,7 +389,6 @@ n*/
     for (i__ = 1; i__ <= 2; ++i__) {
 	j = j % 2 + 1;
 	*pitch = p[*pitch + j * 60 - 61];
-	path[i__ - 1] = *pitch;
     }
 
 /*       The following statement subtracts one from IPOINT, mod DEPTH.  I 
diff --git a/formats/format_wav.c b/formats/format_wav.c
index baeaf45..fdd6e14 100644
--- a/formats/format_wav.c
+++ b/formats/format_wav.c
@@ -354,8 +354,8 @@ static struct ast_frame *wav_read(struct ast_filestream *s, int *whennext)
 	int samples;	/* actual samples read */
 #if __BYTE_ORDER == __BIG_ENDIAN
 	int x;
+	short *tmp;
 #endif
-	short *tmp;
 	int bytes;
 	off_t here;
 	/* Send a frame from the file to the appropriate channel */
@@ -382,8 +381,8 @@ static struct ast_frame *wav_read(struct ast_filestream *s, int *whennext)
 	s->fr.datalen = res;
 	s->fr.samples = samples = res / 2;
 
-	tmp = (short *)(s->fr.data.ptr);
 #if __BYTE_ORDER == __BIG_ENDIAN
+	tmp = (short *)(s->fr.data.ptr);
 	/* file format is little endian so we need to swap */
 	for( x = 0; x < samples; x++)
 		tmp[x] = (tmp[x] << 8) | ((tmp[x] & 0xff00) >> 8);
diff --git a/funcs/func_enum.c b/funcs/func_enum.c
index 378187e..d8c8b25 100644
--- a/funcs/func_enum.c
+++ b/funcs/func_enum.c
@@ -161,7 +161,6 @@ static int function_enum(struct ast_channel *chan, const char *cmd, char *data,
 		AST_APP_ARG(record);
 		AST_APP_ARG(zone);
 	);
-	int res = 0;
 	char tech[80];
 	char dest[256] = "", tmp[2] = "", num[AST_MAX_EXTENSION] = "";
 	char *s, *p;
@@ -205,7 +204,7 @@ static int function_enum(struct ast_channel *chan, const char *cmd, char *data,
 		}
 
 	}
-	res = ast_get_enum(chan, num, dest, sizeof(dest), tech, sizeof(tech), args.zone, args.options, record, NULL);
+	ast_get_enum(chan, num, dest, sizeof(dest), tech, sizeof(tech), args.zone, args.options, record, NULL);
 
 	p = strchr(dest, ':');
 	if (p && strcasecmp(tech, "ALL") && !strchr(args.options, 'u')) {
@@ -414,7 +413,6 @@ static struct ast_custom_function enum_function = {
 static int function_txtcidname(struct ast_channel *chan, const char *cmd,
 			       char *data, char *buf, size_t len)
 {
-	int res;
 	AST_DECLARE_APP_ARGS(args,
 		AST_APP_ARG(number);
 		AST_APP_ARG(zone);
@@ -438,7 +436,7 @@ static int function_txtcidname(struct ast_channel *chan, const char *cmd,
 		args.zone = "e164.arpa";
 	}
 
-	res = ast_get_txt(chan, args.number, buf, len, args.zone);
+	ast_get_txt(chan, args.number, buf, len, args.zone);
 
 	return 0;
 }
diff --git a/include/asterisk/linkedlists.h b/include/asterisk/linkedlists.h
index 82db092..8e86470 100644
--- a/include/asterisk/linkedlists.h
+++ b/include/asterisk/linkedlists.h
@@ -535,7 +535,8 @@ struct {								\
 	     (var);									\
 	     __list_prev = __new_prev, (var) = __list_next,				\
 	     __new_prev = (var),							\
-	     __list_next = (var) ? (var)->field.next : NULL				\
+	     __list_next = (var) ? (var)->field.next : NULL,				\
+	     (void) __list_prev								\
 	    )
 
 #define AST_RWLIST_TRAVERSE_SAFE_BEGIN AST_LIST_TRAVERSE_SAFE_BEGIN
diff --git a/main/asterisk.c b/main/asterisk.c
index 2ce2d89..eed623b 100644
--- a/main/asterisk.c
+++ b/main/asterisk.c
@@ -362,11 +362,10 @@ const char *ast_file_version_find(const char *file)
 	struct file_version *iterator;
 
 	AST_RWLIST_WRLOCK(&file_versions);
-	AST_RWLIST_TRAVERSE_SAFE_BEGIN(&file_versions, iterator, list) {
+	AST_RWLIST_TRAVERSE(&file_versions, iterator, list) {
 		if (!strcasecmp(iterator->file, file))
 			break;
- 	}
-	AST_RWLIST_TRAVERSE_SAFE_END;
+	}
 	AST_RWLIST_UNLOCK(&file_versions);
 	if (iterator)
 		return iterator->version;
@@ -575,9 +574,9 @@ static char *handle_show_sysinfo(struct ast_cli_entry *e, int cmd, struct ast_cl
 {
 	uint64_t physmem, freeram;
 	uint64_t freeswap = 0;
-	int totalswap = 0;
 	int nprocs = 0;
 	long uptime = 0;
+	int totalswap = 0;
 #if defined(HAVE_SYSINFO)
 	struct sysinfo sys_info;
 	sysinfo(&sys_info);
@@ -660,7 +659,7 @@ static char *handle_show_sysinfo(struct ast_cli_entry *e, int cmd, struct ast_cl
 #if defined(HAVE_SYSINFO)
 	ast_cli(a->fd, "  Buffer RAM:                %" PRIu64 " KiB\n", ((uint64_t) sys_info.bufferram * sys_info.mem_unit) / 1024);
 #endif
-#if defined (HAVE_SYSCTL) && defined(HAVE_SWAPCTL)
+#if defined (HAVE_SYSCTL) || defined(HAVE_SWAPCTL)
 	ast_cli(a->fd, "  Total Swap Space:          %u KiB\n", totalswap);
 	ast_cli(a->fd, "  Free Swap Space:           %" PRIu64 " KiB\n\n", freeswap);
 #endif
diff --git a/main/audiohook.c b/main/audiohook.c
index ad977ec..7509321 100644
--- a/main/audiohook.c
+++ b/main/audiohook.c
@@ -792,28 +792,25 @@ int ast_channel_audiohook_count_by_source(struct ast_channel *chan, const char *
 
 	switch (type) {
 		case AST_AUDIOHOOK_TYPE_SPY:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->spy_list, ah, list) {
 				if (!strcmp(ah->source, source)) {
 					count++;
 				}
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		case AST_AUDIOHOOK_TYPE_WHISPER:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->whisper_list, ah, list) {
 				if (!strcmp(ah->source, source)) {
 					count++;
 				}
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		case AST_AUDIOHOOK_TYPE_MANIPULATE:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->manipulate_list, ah, list) {
 				if (!strcmp(ah->source, source)) {
 					count++;
 				}
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		default:
 			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
@@ -833,25 +830,22 @@ int ast_channel_audiohook_count_by_source_running(struct ast_channel *chan, cons
 
 	switch (type) {
 		case AST_AUDIOHOOK_TYPE_SPY:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->spy_list, ah, list) {
 				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
 					count++;
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		case AST_AUDIOHOOK_TYPE_WHISPER:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->whisper_list, ah, list) {
 				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
 					count++;
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		case AST_AUDIOHOOK_TYPE_MANIPULATE:
-			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+			AST_LIST_TRAVERSE(&chan->audiohooks->manipulate_list, ah, list) {
 				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
 					count++;
 			}
-			AST_LIST_TRAVERSE_SAFE_END;
 			break;
 		default:
 			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
diff --git a/main/cdr.c b/main/cdr.c
index f2ade21..9fe110b 100644
--- a/main/cdr.c
+++ b/main/cdr.c
@@ -716,11 +716,8 @@ void ast_cdr_merge(struct ast_cdr *to, struct ast_cdr *from)
 
 void ast_cdr_start(struct ast_cdr *cdr)
 {
-	char *chan;
-
 	for (; cdr; cdr = cdr->next) {
 		if (!ast_test_flag(cdr, AST_CDR_FLAG_LOCKED)) {
-			chan = S_OR(cdr->channel, "<unknown>");
 			check_post(cdr);
 			cdr->start = ast_tvnow();
 		}
@@ -768,11 +765,8 @@ void ast_cdr_failed(struct ast_cdr *cdr)
 
 void ast_cdr_noanswer(struct ast_cdr *cdr)
 {
-	char *chan;
-
 	while (cdr) {
 		if (!ast_test_flag(cdr, AST_CDR_FLAG_LOCKED)) {
-			chan = !ast_strlen_zero(cdr->channel) ? cdr->channel : "<unknown>";
 			check_post(cdr);
 			cdr->disposition = AST_CDR_NOANSWER;
 		}
@@ -892,11 +886,8 @@ static int cdr_seq_inc(struct ast_cdr *cdr)
 
 int ast_cdr_init(struct ast_cdr *cdr, struct ast_channel *c)
 {
-	char *chan;
-
 	for ( ; cdr ; cdr = cdr->next) {
 		if (!ast_test_flag(cdr, AST_CDR_FLAG_LOCKED)) {
-			chan = S_OR(cdr->channel, "<unknown>");
 			ast_copy_string(cdr->channel, c->name, sizeof(cdr->channel));
 			set_one_cid(cdr, c);
 			cdr_seq_inc(cdr);
@@ -1116,7 +1107,6 @@ int ast_cdr_amaflags2int(const char *flag)
 
 static void post_cdr(struct ast_cdr *cdr)
 {
-	char *chan;
 	struct ast_cdr_beitem *i;
 
 	for ( ; cdr ; cdr = cdr->next) {
@@ -1134,7 +1124,6 @@ static void post_cdr(struct ast_cdr *cdr)
 			continue;
 		}
 
-		chan = S_OR(cdr->channel, "<unknown>");
 		check_post(cdr);
 		ast_set_flag(cdr, AST_CDR_FLAG_POSTED);
 		if (ast_test_flag(cdr, AST_CDR_FLAG_POST_DISABLED))
diff --git a/main/channel.c b/main/channel.c
index 7ab5a18..18569b3 100644
--- a/main/channel.c
+++ b/main/channel.c
@@ -2502,7 +2502,7 @@ struct ast_datastore *ast_channel_datastore_find(struct ast_channel *chan, const
 	if (info == NULL)
 		return NULL;
 
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->datastores, datastore, entry) {
+	AST_LIST_TRAVERSE(&chan->datastores, datastore, entry) {
 		if (datastore->info != info) {
 			continue;
 		}
@@ -2517,7 +2517,6 @@ struct ast_datastore *ast_channel_datastore_find(struct ast_channel *chan, const
 			break;
 		}
 	}
-	AST_LIST_TRAVERSE_SAFE_END;
 
 	return datastore;
 }
diff --git a/main/config.c b/main/config.c
index 62f25dc..dc5d5fe 100644
--- a/main/config.c
+++ b/main/config.c
@@ -1021,7 +1021,6 @@ static int process_text_line(struct ast_config *cfg, struct ast_category **cat,
 	} else if (cur[0] == '#') { /* A directive - #include or #exec */
 		char *cur2;
 		char real_inclusion_name[256];
-		struct ast_config_include *inclu;
 		int do_include = 0;	/* otherwise, it is exec */
 
 		cur++;
@@ -1094,7 +1093,7 @@ static int process_text_line(struct ast_config *cfg, struct ast_category **cat,
 		}
 		/* A #include */
 		/* record this inclusion */
-		inclu = ast_include_new(cfg, cfg->include_level == 1 ? "" : configfile, cur, !do_include, cur2, lineno, real_inclusion_name, sizeof(real_inclusion_name));
+		ast_include_new(cfg, cfg->include_level == 1 ? "" : configfile, cur, !do_include, cur2, lineno, real_inclusion_name, sizeof(real_inclusion_name));
 
 		do_include = ast_config_internal_load(cur, cfg, flags, real_inclusion_name, who_asked) ? 1 : 0;
 		if (!ast_strlen_zero(exec_file))
diff --git a/main/dsp.c b/main/dsp.c
index cba01b5..bab6198 100644
--- a/main/dsp.c
+++ b/main/dsp.c
@@ -795,7 +795,6 @@ static int mf_detect(struct ast_dsp *dsp, digit_detect_state_t *s, int16_t amp[]
 	float energy[6];
 	int best;
 	int second_best;
-	float famp;
 	int i;
 	int j;
 	int sample;
@@ -820,7 +819,6 @@ static int mf_detect(struct ast_dsp *dsp, digit_detect_state_t *s, int16_t amp[]
 		/* The following unrolled loop takes only 35% (rough estimate) of the 
 		   time of a rolled loop on the machine on which it was developed */
 		for (j = sample;  j < limit;  j++) {
-			famp = amp[j];
 			/* With GCC 2.95, the following unrolled code seems to take about 35%
 			   (rough estimate) as long as a neat little 0-3 loop */
 			goertzel_sample(s->td.mf.tone_out, amp[j]);
diff --git a/main/features.c b/main/features.c
index 2f5fc4b..c9ded43 100644
--- a/main/features.c
+++ b/main/features.c
@@ -918,7 +918,7 @@ struct ast_park_call_args {
 static struct parkeduser *park_space_reserve(struct ast_channel *chan, struct ast_channel *peer, struct ast_park_call_args *args)
 {
 	struct parkeduser *pu;
-	int i, parking_space = -1, parking_range;
+	int i, parking_space = -1;
 	const char *parkinglotname = NULL;
 	const char *parkingexten;
 	struct ast_parkinglot *parkinglot = NULL;
@@ -1031,9 +1031,6 @@ static struct parkeduser *park_space_reserve(struct ast_channel *chan, struct as
 		int start;
 		struct parkeduser *cur = NULL;
 
-		/* Select parking space within range */
-		parking_range = parkinglot->parking_stop - parkinglot->parking_start + 1;
-
 		if (ast_test_flag(args, AST_PARK_OPT_RANDOMIZE)) {
 			start = ast_random() % (parkinglot->parking_stop - parkinglot->parking_start + 1);
 		} else {
@@ -1082,7 +1079,6 @@ static struct parkeduser *park_space_reserve(struct ast_channel *chan, struct as
 static int park_call_full(struct ast_channel *chan, struct ast_channel *peer, struct ast_park_call_args *args)
 {
 	struct ast_context *con;
-	int parkingnum_copy;
 	struct parkeduser *pu = args->pu;
 	const char *event_from;
 
@@ -1111,7 +1107,6 @@ static int park_call_full(struct ast_channel *chan, struct ast_channel *peer, st
 	
 	pu->start = ast_tvnow();
 	pu->parkingtime = (args->timeout > 0) ? args->timeout : pu->parkinglot->parkingtime;
-	parkingnum_copy = pu->parkingnum;
 	if (args->extout)
 		*(args->extout) = pu->parkingnum;
 
@@ -3448,7 +3443,6 @@ int ast_bridge_call(struct ast_channel *chan,struct ast_channel *peer,struct ast
 	int we_disabled_peer_cdr = 0;
 	struct ast_option_header *aoh;
 	struct ast_cdr *bridge_cdr = NULL;
-	struct ast_cdr *orig_peer_cdr = NULL;
 	struct ast_cdr *chan_cdr = chan->cdr; /* the proper chan cdr, if there are forked cdrs */
 	struct ast_cdr *peer_cdr = peer->cdr; /* the proper chan cdr, if there are forked cdrs */
 	struct ast_cdr *new_chan_cdr = NULL; /* the proper chan cdr, if there are forked cdrs */
@@ -3520,8 +3514,7 @@ int ast_bridge_call(struct ast_channel *chan,struct ast_channel *peer,struct ast
 	}
 	ast_copy_string(orig_channame,chan->name,sizeof(orig_channame));
 	ast_copy_string(orig_peername,peer->name,sizeof(orig_peername));
-	orig_peer_cdr = peer_cdr;
-	
+
 	if (!chan_cdr || (chan_cdr && !ast_test_flag(chan_cdr, AST_CDR_FLAG_POST_DISABLED))) {
 		
 		if (chan_cdr) {
diff --git a/main/fskmodem_float.c b/main/fskmodem_float.c
index f773009..bc873ea 100644
--- a/main/fskmodem_float.c
+++ b/main/fskmodem_float.c
@@ -225,9 +225,7 @@ int fsk_serial(fsk_data *fskd, short *buffer, int *len, int *outbyte)
 	int i,j,n1,r;
 	int samples = 0;
 	int olen;
-	int beginlen=*len;
-	int beginlenx;
-	
+
 	switch (fskd->state) {
 		/* Pick up where we left off */
 	case STATE_SEARCH_STARTBIT2:
@@ -255,7 +253,6 @@ int fsk_serial(fsk_data *fskd, short *buffer, int *len, int *outbyte)
 		beginning of a start bit in the TDD sceanario. It just looks for sufficient
 		level to maybe, perhaps, guess, maybe that its maybe the beginning of
 		a start bit, perhaps. This whole thing stinks! */
-		beginlenx=beginlen; /* just to avoid unused war warnings */
 		if (demodulator(fskd, &fskd->x1, GET_SAMPLE))
 			return -1;
 		samples++;
diff --git a/main/manager.c b/main/manager.c
index a8447ef..542e4bb 100644
--- a/main/manager.c
+++ b/main/manager.c
@@ -1727,7 +1727,7 @@ static const char *__astman_get_header(const struct message *m, char *var, int m
 		}
 	}
 
-	return "";
+	return result;
 }
 
 /*
diff --git a/main/pbx.c b/main/pbx.c
index 00485f2..1d4ea02 100644
--- a/main/pbx.c
+++ b/main/pbx.c
@@ -6560,7 +6560,6 @@ static int manager_show_dialplan(struct mansession *s, const struct message *m)
 	const char *exten, *context;
 	const char *id = astman_get_header(m, "ActionID");
 	char idtext[256];
-	int res;
 
 	/* Variables used for different counters */
 	struct dialplan_counters counters;
@@ -6575,7 +6574,7 @@ static int manager_show_dialplan(struct mansession *s, const struct message *m)
 	exten = astman_get_header(m, "Extension");
 	context = astman_get_header(m, "Context");
 
-	res = manager_show_dialplan_helper(s, m, idtext, context, exten, &counters, NULL);
+	manager_show_dialplan_helper(s, m, idtext, context, exten, &counters, NULL);
 
 	if (context && !counters.context_existence) {
 		char errorbuf[BUFSIZ];
@@ -7409,7 +7408,7 @@ static const char * const months[] =
 
 int ast_build_timing(struct ast_timing *i, const char *info_in)
 {
-	char *info_save, *info;
+	char *info;
 	int j, num_fields, last_sep = -1;
 
 	/* Check for empty just in case */
@@ -7418,7 +7417,7 @@ int ast_build_timing(struct ast_timing *i, const char *info_in)
 	}
 
 	/* make a copy just in case we were passed a static string */
-	info_save = info = ast_strdupa(info_in);
+	info = ast_strdupa(info_in);
 
 	/* count the number of fields in the timespec */
 	for (j = 0, num_fields = 1; info[j] != '\0'; j++) {
diff --git a/main/plc.c b/main/plc.c
index ef549ca..ef21312 100644
--- a/main/plc.c
+++ b/main/plc.c
@@ -177,10 +177,8 @@ int plc_fillin(plc_state_t *s, int16_t amp[], int len)
 	float old_weight;
 	float new_weight;
 	float gain;
-	int16_t *orig_amp;
 	int orig_len;
 
-	orig_amp = amp;
 	orig_len = len;
 	if (s->missing_samples == 0) {
 		/* As the gap in real speech starts we need to assess the last known pitch,
diff --git a/main/rtp_engine.c b/main/rtp_engine.c
index 4159170..b2b498f 100644
--- a/main/rtp_engine.c
+++ b/main/rtp_engine.c
@@ -1247,8 +1247,8 @@ enum ast_bridge_result ast_rtp_instance_bridge(struct ast_channel *c0, struct as
 			*tinstance0 = NULL, *tinstance1 = NULL;
 	struct ast_rtp_glue *glue0, *glue1;
 	struct ast_sockaddr addr1, addr2;
-	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID, text_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
-	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID, text_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
 	enum ast_bridge_result res = AST_BRIDGE_FAILED;
 	format_t codec0 = 0, codec1 = 0;
 	int unlock_chans = 1;
@@ -1275,11 +1275,9 @@ enum ast_bridge_result ast_rtp_instance_bridge(struct ast_channel *c0, struct as
 
 	audio_glue0_res = glue0->get_rtp_info(c0, &instance0);
 	video_glue0_res = glue0->get_vrtp_info ? glue0->get_vrtp_info(c0, &vinstance0) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue0_res = glue0->get_trtp_info ? glue0->get_trtp_info(c0, &tinstance0) : AST_RTP_GLUE_RESULT_FORBID;
 
 	audio_glue1_res = glue1->get_rtp_info(c1, &instance1);
 	video_glue1_res = glue1->get_vrtp_info ? glue1->get_vrtp_info(c1, &vinstance1) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue1_res = glue1->get_trtp_info ? glue1->get_trtp_info(c1, &tinstance1) : AST_RTP_GLUE_RESULT_FORBID;
 
 	/* If we are carrying video, and both sides are not going to remotely bridge... fail the native bridge */
 	if (video_glue0_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue0_res != AST_RTP_GLUE_RESULT_REMOTE)) {
@@ -1381,8 +1379,8 @@ void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c0, struc
 		*vinstance0 = NULL, *vinstance1 = NULL,
 		*tinstance0 = NULL, *tinstance1 = NULL;
 	struct ast_rtp_glue *glue0, *glue1;
-	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID, text_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
-	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID, text_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
 	format_t codec0 = 0, codec1 = 0;
 	int res = 0;
 
@@ -1402,11 +1400,9 @@ void ast_rtp_instance_early_bridge_make_compatible(struct ast_channel *c0, struc
 
 	audio_glue0_res = glue0->get_rtp_info(c0, &instance0);
 	video_glue0_res = glue0->get_vrtp_info ? glue0->get_vrtp_info(c0, &vinstance0) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue0_res = glue0->get_trtp_info ? glue0->get_trtp_info(c0, &tinstance0) : AST_RTP_GLUE_RESULT_FORBID;
 
 	audio_glue1_res = glue1->get_rtp_info(c1, &instance1);
 	video_glue1_res = glue1->get_vrtp_info ? glue1->get_vrtp_info(c1, &vinstance1) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue1_res = glue1->get_trtp_info ? glue1->get_trtp_info(c1, &tinstance1) : AST_RTP_GLUE_RESULT_FORBID;
 
 	/* If we are carrying video, and both sides are not going to remotely bridge... fail the native bridge */
 	if (video_glue0_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue0_res != AST_RTP_GLUE_RESULT_REMOTE)) {
@@ -1465,8 +1461,8 @@ int ast_rtp_instance_early_bridge(struct ast_channel *c0, struct ast_channel *c1
 			*vinstance0 = NULL, *vinstance1 = NULL,
 			*tinstance0 = NULL, *tinstance1 = NULL;
 	struct ast_rtp_glue *glue0, *glue1;
-	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID, text_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
-	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID, text_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue0_res = AST_RTP_GLUE_RESULT_FORBID, video_glue0_res = AST_RTP_GLUE_RESULT_FORBID;
+	enum ast_rtp_glue_result audio_glue1_res = AST_RTP_GLUE_RESULT_FORBID, video_glue1_res = AST_RTP_GLUE_RESULT_FORBID;
 	format_t codec0 = 0, codec1 = 0;
 	int res = 0;
 
@@ -1491,11 +1487,9 @@ int ast_rtp_instance_early_bridge(struct ast_channel *c0, struct ast_channel *c1
 
 	audio_glue0_res = glue0->get_rtp_info(c0, &instance0);
 	video_glue0_res = glue0->get_vrtp_info ? glue0->get_vrtp_info(c0, &vinstance0) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue0_res = glue0->get_trtp_info ? glue0->get_trtp_info(c0, &tinstance0) : AST_RTP_GLUE_RESULT_FORBID;
 
 	audio_glue1_res = glue1->get_rtp_info(c1, &instance1);
 	video_glue1_res = glue1->get_vrtp_info ? glue1->get_vrtp_info(c1, &vinstance1) : AST_RTP_GLUE_RESULT_FORBID;
-	text_glue1_res = glue1->get_trtp_info ? glue1->get_trtp_info(c1, &tinstance1) : AST_RTP_GLUE_RESULT_FORBID;
 
 	/* If we are carrying video, and both sides are not going to remotely bridge... fail the native bridge */
 	if (video_glue0_res != AST_RTP_GLUE_RESULT_FORBID && (audio_glue0_res != AST_RTP_GLUE_RESULT_REMOTE || video_glue0_res != AST_RTP_GLUE_RESULT_REMOTE)) {
diff --git a/main/udptl.c b/main/udptl.c
index f172c33..97233ff 100644
--- a/main/udptl.c
+++ b/main/udptl.c
@@ -664,7 +664,6 @@ struct ast_frame *ast_udptl_read(struct ast_udptl *udptl)
 	int res;
 	struct ast_sockaddr addr;
 	uint16_t seqno = 0;
-	uint16_t *udptlheader;
 	
 	/* Cache where the header will go */
 	res = ast_recvfrom(udptl->fd,
@@ -672,7 +671,6 @@ struct ast_frame *ast_udptl_read(struct ast_udptl *udptl)
 			sizeof(udptl->rawdata) - AST_FRIENDLY_OFFSET,
 			0,
 			&addr);
-	udptlheader = (uint16_t *)(udptl->rawdata + AST_FRIENDLY_OFFSET);
 	if (res < 0) {
 		if (errno != EAGAIN)
 			ast_log(LOG_WARNING, "(%s): UDPTL read error: %s\n",
diff --git a/pbx/pbx_config.c b/pbx/pbx_config.c
index cd5947f..5e52052 100644
--- a/pbx/pbx_config.c
+++ b/pbx/pbx_config.c
@@ -677,7 +677,7 @@ static char *handle_cli_dialplan_save(struct ast_cli_entry *e, int cmd, struct a
 	int incomplete = 0; /* incomplete config write? */
 	FILE *output;
 	struct ast_flags config_flags = { 0 };
-	const char *base, *slash, *file;
+	const char *base, *slash;
 
 	switch (cmd) {
 	case CLI_INIT:
@@ -716,16 +716,13 @@ static char *handle_cli_dialplan_save(struct ast_cli_entry *e, int cmd, struct a
 		if (!strstr(a->argv[2], ".conf")) { /*no, this is assumed to be a pathname */
 			/* if filename ends with '/', do not add one */
 			slash = (*(a->argv[2] + strlen(a->argv[2]) -1) == '/') ? "/" : "";
-			file = config;	/* default: 'extensions.conf' */
 		} else {	/* yes, complete file name */
 			slash = "";
-			file = "";
 		}
 	} else {
 		/* no config file, default one */
 		base = ast_config_AST_CONFIG_DIR;
 		slash = "/";
-		file = config;
 	}
 	snprintf(filename, sizeof(filename), "%s%s%s", base, slash, config);
 
@@ -1627,7 +1624,6 @@ static void pbx_load_users(void)
 	char dahdicopy[256];
 	char *ext, altcopy[256];
 	char *c;
-	int len;
 	int hasvoicemail;
 	int start, finish, x;
 	struct ast_context *con = NULL;
@@ -1641,7 +1637,6 @@ static void pbx_load_users(void)
 		if (!strcasecmp(cat, "general"))
 			continue;
 		iface[0] = '\0';
-		len = sizeof(iface);
 		if (ast_true(ast_config_option(cfg, cat, "hassip"))) {
 			snprintf(tmp, sizeof(tmp), "SIP/%s", cat);
 			append_interface(iface, sizeof(iface), tmp);
diff --git a/res/res_agi.c b/res/res_agi.c
index de76d26..ffc5373 100644
--- a/res/res_agi.c
+++ b/res/res_agi.c
@@ -1922,7 +1922,7 @@ static int handle_controlstreamfile(struct ast_channel *chan, AGI *agi, int argc
 
 static int handle_streamfile(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])
 {
-	int res, vres;
+	int res;
 	struct ast_filestream *fs, *vfs;
 	long sample_offset = 0, max_length;
 	const char *edigits = "";
@@ -1951,7 +1951,7 @@ static int handle_streamfile(struct ast_channel *chan, AGI *agi, int argc, const
 	ast_seekstream(fs, sample_offset, SEEK_SET);
 	res = ast_applystream(chan, fs);
 	if (vfs)
-		vres = ast_applystream(chan, vfs);
+		ast_applystream(chan, vfs);
 	ast_playstream(fs);
 	if (vfs)
 		ast_playstream(vfs);
@@ -1972,7 +1972,7 @@ static int handle_streamfile(struct ast_channel *chan, AGI *agi, int argc, const
 /*! \brief get option - really similar to the handle_streamfile, but with a timeout */
 static int handle_getoption(struct ast_channel *chan, AGI *agi, int argc, const char * const argv[])
 {
-	int res, vres;
+	int res;
 	struct ast_filestream *fs, *vfs;
 	long sample_offset = 0, max_length;
 	int timeout = 0;
@@ -2007,7 +2007,7 @@ static int handle_getoption(struct ast_channel *chan, AGI *agi, int argc, const
 	ast_seekstream(fs, sample_offset, SEEK_SET);
 	res = ast_applystream(chan, fs);
 	if (vfs)
-		vres = ast_applystream(chan, vfs);
+		ast_applystream(chan, vfs);
 	ast_playstream(fs);
 	if (vfs)
 		ast_playstream(vfs);
@@ -2889,7 +2889,7 @@ static int handle_speechrecognize(struct ast_channel *chan, AGI *agi, int argc,
 	struct ast_speech *speech = agi->speech;
 	const char *prompt;
 	char dtmf = 0, tmp[4096] = "", *buf = tmp;
-	int timeout = 0, offset = 0, old_read_format = 0, res = 0, i = 0;
+	int timeout = 0, offset = 0, res = 0, i = 0;
 	long current_offset = 0;
 	const char *reason = NULL;
 	struct ast_frame *fr = NULL;
@@ -2913,7 +2913,6 @@ static int handle_speechrecognize(struct ast_channel *chan, AGI *agi, int argc,
 		offset = atoi(argv[4]);
 
 	/* We want frames coming in signed linear */
-	old_read_format = chan->readformat;
 	if (ast_set_read_format(chan, AST_FORMAT_SLINEAR)) {
 		ast_agi_send(agi->fd, chan, "200 result=0\n");
 		return RESULT_SUCCESS;
diff --git a/res/res_calendar.c b/res/res_calendar.c
index dee944f..b53ce60 100644
--- a/res/res_calendar.c
+++ b/res/res_calendar.c
@@ -1665,7 +1665,7 @@ static void *do_refresh(void *data)
 	for (;;) {
 		struct timeval now = ast_tvnow();
 		struct timespec ts = {0,};
-		int res, wait;
+		int wait;
 
 		ast_mutex_lock(&refreshlock);
 
@@ -1674,7 +1674,7 @@ static void *do_refresh(void *data)
 		}
 
 		ts.tv_sec = (now.tv_sec + wait / 1000) + 1;
-		res = ast_cond_timedwait(&refresh_condition, &refreshlock, &ts);
+		ast_cond_timedwait(&refresh_condition, &refreshlock, &ts);
 
 		ast_mutex_unlock(&refreshlock);
 
@@ -1701,10 +1701,9 @@ static int unload_module(void)
 	ao2_callback(calendars, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);
 
 	AST_LIST_LOCK(&techs);
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&techs, tech, list) {
+	AST_LIST_TRAVERSE(&techs, tech, list) {
 		ast_unload_resource(tech->module, 0);
 	}
-	AST_LIST_TRAVERSE_SAFE_END;
 	AST_LIST_UNLOCK(&techs);
 
 	return 0;
diff --git a/res/res_fax.c b/res/res_fax.c
index cc2ee5e..141cf47 100644
--- a/res/res_fax.c
+++ b/res/res_fax.c
@@ -2324,9 +2324,7 @@ static char *fax_session_tab_complete(struct ast_cli_args *a)
 		}
 		ao2_ref(s, -1);
 	}
-	if (ao2_iterator_destroy != NULL) {
-		ao2_iterator_destroy(&i);
-	}
+	ao2_iterator_destroy(&i);
 	return name;
 }
 
@@ -2560,9 +2558,7 @@ static char *cli_fax_show_sessions(struct ast_cli_entry *e, int cmd, struct ast_
 			ast_log(LOG_ERROR, "error printing filenames for 'fax show sessions' command");
 			ao2_unlock(s);
 			ao2_ref(s, -1);
-			if (ao2_iterator_destroy != NULL) {
-				ao2_iterator_destroy(&i);
-			}
+			ao2_iterator_destroy(&i);
 			return CLI_FAILURE;
 		}
 
@@ -2576,9 +2572,7 @@ static char *cli_fax_show_sessions(struct ast_cli_entry *e, int cmd, struct ast_
 		ao2_unlock(s);
 		ao2_ref(s, -1);
 	}
-	if (ao2_iterator_destroy != NULL) {
-		ao2_iterator_destroy(&i);
-	}
+	ao2_iterator_destroy(&i);
 	session_count = ao2_container_count(faxregistry.container);
 	ast_cli(a->fd, "\n%d FAX sessions\n\n", session_count);
 
diff --git a/res/res_musiconhold.c b/res/res_musiconhold.c
index 45280bf..9385b1f 100644
--- a/res/res_musiconhold.c
+++ b/res/res_musiconhold.c
@@ -631,13 +631,11 @@ static void *monmp3thread(void *data)
 		}
 		if (class->timer) {
 			struct pollfd pfd = { .fd = ast_timer_fd(class->timer), .events = POLLIN, };
-			struct timeval tv;
 
 #ifdef SOLARIS
 			thr_yield();
 #endif
 			/* Pause some amount of time */
-			tv = ast_tvnow();
 			if (ast_poll(&pfd, 1, -1) > 0) {
 				ast_timer_ack(class->timer, 1);
 				res = 320;
@@ -1017,7 +1015,6 @@ static int moh_scan_files(struct mohclass *class) {
 	char filepath[PATH_MAX];
 	char *ext;
 	struct stat statbuf;
-	int dirnamelen;
 	int i;
 
 	if (class->dir[0] != '/') {
@@ -1038,7 +1035,6 @@ static int moh_scan_files(struct mohclass *class) {
 		ast_free(class->filearray[i]);
 
 	class->total_files = 0;
-	dirnamelen = strlen(dir_path) + 2;
 	if (!getcwd(path, sizeof(path))) {
 		ast_log(LOG_WARNING, "getcwd() failed: %s\n", strerror(errno));
 		return -1;
-- 
1.7.4.4

