#! /bin/sh /usr/share/dpatch/dpatch-run
## bristuff-0.2.0-RC8j.dpatch by  <msp@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad --exclude=CVS --exclude=.svn ./app_devstate.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_devstate.c
--- ./app_devstate.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_devstate.c	2005-07-14 06:58:31.588101720 +0100
@@ -0,0 +1,196 @@
+/*
+ * Devstate application
+ * 
+ * Since we like the snom leds so much, a little app to
+ * light the lights on the snom on demand ....
+ *
+ * Copyright (C) 2005, Druid Software
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/astdb.h>
+#include <asterisk/utils.h>
+#include <asterisk/cli.h>
+#include <asterisk/manager.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+static char *type = "DS";
+static char *tdesc = "Application for sending device state messages";
+
+static char *app = "Devstate";
+
+static char *synopsis = "Generate a device state change event given the input parameters";
+
+static char *descrip = 
+"  Devstate(device|state):  Generate a device state change event given the input parameters. Returns 0. State values match the asterisk device states. They are 0 = unknown, 1 = not inuse, 2 = inuse, 3 = busy, 4 = invalid, 5 = unavailable, 6 = ringing\n";
+
+static char devstate_cli_usage[] = 
+"Usage: devstate device state\n" 
+"       Generate a device state change event given the input parameters.\n Mainly used for lighting the LEDs on the snoms.\n";
+
+static int devstate_cli(int fd, int argc, char *argv[]);
+static struct ast_cli_entry  cli_dev_state =
+        { { "devstate", NULL }, devstate_cli, "Set the device state on one of the \"pseudo devices\".", devstate_cli_usage };
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int devstate_cli(int fd, int argc, char *argv[])
+{
+    char devName[128];
+    if (argc != 3)
+        return RESULT_SHOWUSAGE;
+
+    if (ast_db_put("DEVSTATES", argv[1], argv[2]))
+    {
+        ast_log(LOG_DEBUG, "ast_db_put failed\n");
+    }
+
+    snprintf(devName, sizeof(devName), "DS/%s", argv[1]);
+    ast_device_state_changed(devName);
+    return RESULT_SUCCESS;
+}
+
+static int devstate_exec(struct ast_channel *chan, void *data)
+{
+    struct localuser *u;
+    char *device, *state, *info;
+    char devName[128];
+    if (!(info = ast_strdupa(data))) {
+            ast_log(LOG_WARNING, "Unable to dupe data :(\n");
+            return -1;
+    }
+    LOCAL_USER_ADD(u);
+    
+    device = info;
+    state = strchr(info, '|');
+    if (state) {
+        *state = '\0';
+        state++;
+    }
+    else
+    {
+        ast_log(LOG_DEBUG, "No state argument supplied\n");
+        return -1;
+    }
+
+    if (ast_db_put("DEVSTATES", device, state))
+    {
+        ast_log(LOG_DEBUG, "ast_db_put failed\n");
+    }
+
+    snprintf(devName, sizeof(devName), "DS/%s", device);
+    ast_device_state_changed(devName);
+
+    LOCAL_USER_REMOVE(u);
+    return 0;
+}
+
+
+static int ds_devicestate(void *data)
+{
+    char *dest = data;
+    char stateStr[16];
+    if (ast_db_get("DEVSTATES", dest, stateStr, sizeof(stateStr)))
+    {
+        ast_log(LOG_DEBUG, "ds_devicestate couldnt get state in astdb\n");
+        return 0;
+    }
+    else
+    {
+        ast_log(LOG_DEBUG, "ds_devicestate dev=%s returning state %d\n",
+               dest, atoi(stateStr));
+        return (atoi(stateStr));
+    }
+}
+
+static char mandescr_devstate[] = 
+"Description: Put a value into astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n"
+"	Value: ...\n";
+
+static int action_devstate(struct mansession *s, struct message *m)
+{
+        char *devstate = astman_get_header(m, "Devstate");
+        char *value = astman_get_header(m, "Value");
+	char *id = astman_get_header(m,"ActionID");
+	char devName[128];
+
+	if (!strlen(devstate)) {
+		astman_send_error(s, m, "No Devstate specified");
+		return 0;
+	}
+	if (!strlen(value)) {
+		astman_send_error(s, m, "No Value specified");
+		return 0;
+	}
+
+	ast_mutex_lock(&s->lock);
+
+        if (!ast_db_put("DEVSTATES", devstate, value)) {
+	    snprintf(devName, sizeof(devName), "DS/%s", devstate);
+	    ast_device_state_changed(devName);
+	    ast_cli(s->fd, "Response: Success\r\n");
+	} else {
+	    ast_log(LOG_DEBUG, "ast_db_put failed\n");
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+	ast_mutex_unlock(&s->lock);
+	return 0;
+}
+
+int load_module(void)
+{
+    if (ast_channel_register_ex(type, tdesc, ((AST_FORMAT_MAX_AUDIO << 1) - 1), NULL, ds_devicestate)) {
+        ast_log(LOG_DEBUG, "Unable to register channel class %s\n", type);
+        return -1;
+    }
+    ast_cli_register(&cli_dev_state);  
+    ast_manager_register2( "Devstate", EVENT_FLAG_CALL, action_devstate, "Change a device state", mandescr_devstate );
+    return ast_register_application(app, devstate_exec, synopsis, descrip);
+}
+
+int unload_module(void)
+{
+    int res = 0;
+    STANDARD_HANGUP_LOCALUSERS;
+    ast_manager_unregister( "Devstate");
+    ast_cli_unregister(&cli_dev_state);
+    res = ast_unregister_application(app);
+    ast_channel_unregister(type);    
+    return res;
+}
+
+char *description(void)
+{
+    return tdesc;
+}
+
+int usecount(void)
+{
+    int res;
+    STANDARD_USECOUNT(res);
+    return res;
+}
+
+char *key()
+{
+    return ASTERISK_GPL_KEY;
+}
diff -urNad --exclude=CVS --exclude=.svn ./app_pickup.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_pickup.c
--- ./app_pickup.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_pickup.c	2005-07-14 06:59:00.714673808 +0100
@@ -0,0 +1,289 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Pickup, channel independent call pickup
+ * 
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * Copyright (C) 2004, Florian Overkamp <florian@obsimref.com>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/channel_pvt.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/features.h>
+#include <asterisk/options.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <signal.h>
+
+#include <pthread.h>
+
+
+static char *tdesc = "PickUp/PickDown/Steal/PickupChan";
+
+static char *app = "PickUp";
+
+static char *synopsis = "Channel independent call pickup.";
+
+static char *descrip = 
+"  PickDown([group]):  Tries to pickup the first ringing channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app2 = "Steal";
+
+static char *synopsis2 = "Channel independent call stealing. Just like pickup but for answered channels.";
+
+static char *descrip2 = 
+"  Steal([group]):  Tries to steal the first bridged channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app3 = "PickDown";
+
+static char *synopsis3 = "Channel independent call pickdown.";
+
+static char *descrip3 = 
+"  PickDown([group]):  Tries to hangup the first ringing channel with callgroup == group.\n"
+"                    If called without the group argument, the pickupgroup of the channel will be used.\n";
+
+static char *app4 = "PickupChan";
+
+static char *synopsis4 = "Channel independent call pickup.";
+
+static char *descrip4 = 
+"  PickupChan(Technology/resource[&Technology2/resource2...]):  Tries to pickup the first ringing channel in the parameter list.\n";
+
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int my_pickup_call(struct ast_channel *chan, unsigned int pickupgroup, int chanstate, int bridge) {
+	struct ast_channel *cur;
+	int res = -1;
+	cur = ast_channel_walk_locked(NULL);
+	while(cur) {
+		if ((cur != chan) &&
+			(pickupgroup & cur->callgroup) &&
+			 (cur->_state == chanstate)) {
+			 	break;
+		}
+		ast_mutex_unlock(&cur->lock);
+		cur = ast_channel_walk_locked(cur);
+	}
+	if (cur) {
+		if(option_verbose > 2) {
+		    if (chanstate == AST_STATE_RINGING) {
+			if (bridge == 1) {
+		    	    ast_verbose(VERBOSE_PREFIX_3 "Channel %s picked up ringing channel %s\n",chan->name,cur->name);
+			} else {
+		    	    ast_verbose(VERBOSE_PREFIX_3 "Channel %s hung up ringing channel %s\n",chan->name,cur->name);
+			}
+		    } else {
+		        ast_verbose(VERBOSE_PREFIX_3 "Channel %s stole channel %s\n",chan->name,cur->name);
+		    }
+		}
+		if (bridge == 1) {
+		    if (chan->_state != AST_STATE_UP) {
+			ast_answer(chan);
+		    }
+		    if (ast_channel_masquerade(cur, chan)) {
+			ast_log(LOG_ERROR, "unable to masquerade\n");
+		    }
+		    ast_mutex_unlock(&cur->lock);
+		    ast_mutex_unlock(&chan->lock);
+		} else {
+		    cur->_softhangup = AST_SOFTHANGUP_DEV;
+		    ast_mutex_unlock(&cur->lock);
+		}
+    	} else	{
+		if(option_verbose > 2) {
+		    ast_verbose(VERBOSE_PREFIX_3 "No channel found %d.\n",pickupgroup);
+		}
+	} 
+	return res;
+}
+
+static int my_pickup_channel(struct ast_channel *chan, void *data, int chanstate, int bridge) {
+       struct ast_channel *cur;
+       char channels[256];
+       char evalchan[256];
+       char *endptr;
+       int res = -1;
+       cur = ast_channel_walk_locked(NULL);
+       strncpy(channels, (char *)data, sizeof(channels) - 1);
+       while(cur) {
+               if ((cur != chan) &&
+                        (cur->_state == chanstate)) {
+                               /* This call is a candidate (correct ringstate and not ourselves), now check if the channel is in our list */
+                               strncpy(evalchan, (char *)cur->name, sizeof(evalchan) - 1);                             
+                               /* strip the subchannel tag */
+                               endptr = strrchr(evalchan, '-');
+                               if(endptr) {
+                                       *endptr = '\0';
+                               }
+                               /* check for each of the members if they match (probably a stristr will do ?) */
+                               /* if we match the code, break */
+                               if(strstr(channels, evalchan) != NULL) {
+                                       ast_verbose(VERBOSE_PREFIX_1 "Nice channel, I'll take it: %s\n",evalchan);
+                                       break;
+                               }
+               }
+               ast_mutex_unlock(&cur->lock);
+               cur = ast_channel_walk_locked(cur);
+       }
+       if (cur) {
+               if(option_verbose > 2) {
+                   if (chanstate == AST_STATE_RINGING) {
+                       if (bridge == 1) {
+                           ast_verbose(VERBOSE_PREFIX_3 "Channel %s picked up ringing channel %s\n",chan->name,cur->name);
+                       } else {
+                           ast_verbose(VERBOSE_PREFIX_3 "Channel %s hung up ringing channel %s\n",chan->name,cur->name);
+                       }
+                   } else {
+                       ast_verbose(VERBOSE_PREFIX_3 "Channel %s stole channel %s\n",chan->name,cur->name);
+                   }
+               }
+               if (bridge == 1) {
+	    	   if (chan->_state != AST_STATE_UP) {
+		       ast_answer(chan);
+		   }
+                   if (ast_channel_masquerade(cur, chan)) {
+                       ast_log(LOG_ERROR, "unable to masquerade\n");
+                   }
+                   ast_mutex_unlock(&cur->lock);
+                   ast_mutex_unlock(&chan->lock);
+               } else {
+                   cur->_softhangup = AST_SOFTHANGUP_DEV;
+                   ast_mutex_unlock(&cur->lock);
+               }
+       } else  {
+               if(option_verbose > 2) {
+                   ast_verbose(VERBOSE_PREFIX_3 "No channel found %s.\n",channels);
+               }
+       } 
+       return res;
+}
+
+
+static int pickup_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_RINGING, 1);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int steal_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_UP, 1);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int pickdown_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	unsigned int pickupgroup=0;
+	struct localuser *u;
+	if (!data || !strlen(data)) {
+	    pickupgroup = chan->pickupgroup;
+	} else {
+	    pickupgroup = ast_get_group(data);
+	}
+	LOCAL_USER_ADD(u);
+	if (!res) {
+		res = my_pickup_call(chan, pickupgroup, AST_STATE_RINGING, 0);
+	}
+	if (res > 0)
+		res = 0;
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int pickupchan_exec(struct ast_channel *chan, void *data) {
+       int res=0;
+       struct localuser *u;
+        if (!data) {
+                ast_log(LOG_WARNING, "PickupChan requires an argument (technology1/number1&technology2/number2...)\n");
+                return -1;
+        }
+       LOCAL_USER_ADD(u);
+       if (!res) {
+               res = my_pickup_channel(chan, data, AST_STATE_RINGING, 1);
+       }
+       if (res > 0)
+               res = 0;
+       LOCAL_USER_REMOVE(u);
+       return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	ast_unregister_application(app4);
+	ast_unregister_application(app3);
+	ast_unregister_application(app2);
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	ast_register_application(app4, pickupchan_exec, synopsis4, descrip4);
+	ast_register_application(app3, pickdown_exec, synopsis3, descrip3);
+	ast_register_application(app2, steal_exec, synopsis2, descrip2);
+	return ast_register_application(app, pickup_exec, synopsis, descrip);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_chanisavail.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_chanisavail.c
--- ./apps/app_chanisavail.c	2004-12-30 21:46:39.000000000 +0000
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_chanisavail.c	2005-07-14 06:58:31.587101872 +0100
@@ -81,7 +81,7 @@
 			}
 			*number = '\0';
 			number++;
-			if ((tempchan = ast_request(tech, chan->nativeformats, number))) {
+			if ((tempchan = ast_request(tech, chan->nativeformats, number, NULL))) {
 					pbx_builtin_setvar_helper(chan, "AVAILCHAN", tempchan->name);
 					/* Store the originally used channel too */
 					snprintf(tmp, sizeof(tmp), "%s/%s", tech, number);
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_dial.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_dial.c
--- ./apps/app_dial.c	2005-05-12 02:43:36.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_dial.c	2005-07-14 06:58:39.973826896 +0100
@@ -7,6 +7,10 @@
  *
  * Mark Spencer <markster@digium.com>
  *
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  */
@@ -56,6 +60,8 @@
 "n is the priority of the dialer instance), then it will be the next\n"
 "executed extension (this allows you to setup different behavior on busy from\n"
 "no-answer).\n"
+"If an extension with priority +201 exists and there was no channel available\n"
+"we will go there instead. So unregisterd VoIP phones will not be treaded as busy.\n"
 "  This application returns -1 if the originating channel hangs up, or if the\n"
 "call is bridged and either of the parties in the bridge terminate the call.\n"
 "The option string may contain zero or more of the following characters:\n"
@@ -66,6 +72,8 @@
 "             don't allow callerids from other extensions then the ones\n"
 "             that are assigned to you.\n"
 "      'r' -- indicate ringing to the calling party, pass no audio until answered.\n"
+"      'R' -- indicate ringing to the calling party when the called party indicates\n"
+"             ringing, pass no audio until answered.\n"
 "      'm' -- provide hold music to the calling party until answered.\n"
 "      'M(x) -- Executes the macro (x) upon connect of the call\n"
 "      'h' -- allow callee to hang up by hitting *.\n"
@@ -109,6 +117,7 @@
 	int allowredirect_in;
 	int allowredirect_out;
 	int ringbackonly;
+	int noinband;
 	int musiconhold;
 	int allowdisconnect_in;
 	int allowdisconnect_out;
@@ -151,7 +160,7 @@
 	int single;
 	struct ast_channel *winner;
 	
-	single = (outgoing && !outgoing->next && !outgoing->musiconhold && !outgoing->ringbackonly);
+	single = (outgoing && !outgoing->next && !outgoing->musiconhold && !outgoing->ringbackonly && !outgoing->noinband);
 	
 	if (single) {
 		/* Turn off hold music, etc */
@@ -180,12 +189,13 @@
 			if (numlines == (numbusy + numcongestion + numnochan)) {
 				if (option_verbose > 2)
 					ast_verbose( VERBOSE_PREFIX_2 "Everyone is busy/congested at this time\n");
-				if (numbusy)
+				if (numnochan) {
+					strncpy(status, "CHANUNAVAIL", statussize - 1);
+				} else if (numbusy) {
 					strncpy(status, "BUSY", statussize - 1);
-				else if (numcongestion)
+				} else if (numcongestion) {
 					strncpy(status, "CONGESTION", statussize - 1);
-				else if (numnochan)
-					strncpy(status, "CHANUNAVAIL", statussize - 1);
+				}
 				/* See if there is a special busy message */
 				if (ast_exists_extension(in, in->context, in->exten, in->priority + 101, in->callerid)) 
 					in->priority+=100;
@@ -229,7 +239,7 @@
 					if (option_verbose > 2)
 						ast_verbose(VERBOSE_PREFIX_3 "Now forwarding %s to '%s/%s' (thanks to %s)\n", in->name, tech, stuff, o->chan->name);
 					/* Setup parameters */
-					o->chan = ast_request(tech, in->nativeformats, stuff);
+					o->chan = ast_request(tech, in->nativeformats, stuff, NULL);
 					if (!o->chan) {
 						ast_log(LOG_NOTICE, "Unable to create local channel for call forward to '%s/%s'\n", tech, stuff);
 						o->stillgoing = 0;
@@ -356,10 +366,10 @@
 						default:
 							ast_log(LOG_DEBUG, "Dunno what to do with control type %d\n", f->subclass);
 						}
-					} else if (single && (f->frametype == AST_FRAME_VOICE) && 
+					} else 	if (single && (f->frametype == AST_FRAME_VOICE) && 
 								!(outgoing->ringbackonly || outgoing->musiconhold)) {
 						if (ast_write(in, f)) 
-							ast_log(LOG_WARNING, "Unable to forward frame\n");
+							ast_log(LOG_WARNING, "Unable to forward frame\n"); 
 					} else if (single && (f->frametype == AST_FRAME_IMAGE) && 
 								!(outgoing->ringbackonly || outgoing->musiconhold)) {
 						if (ast_write(in, f))
@@ -731,6 +741,9 @@
 			if (strchr(transfer, 'r'))
 				tmp->ringbackonly = 1;
                         else    tmp->ringbackonly = 0;
+			if (strchr(transfer, 'R'))
+				tmp->noinband = 1;
+                        else    tmp->noinband = 0;
 			if (strchr(transfer, 'm'))
 				tmp->musiconhold = 1;
                         else    tmp->musiconhold = 0;
@@ -758,7 +771,7 @@
 				ast_log(LOG_DEBUG, "Dialing by extension %s\n", numsubst);
 		}
 		/* Request the peer */
-		tmp->chan = ast_request(tech, chan->nativeformats, numsubst);
+		tmp->chan = ast_request(tech, chan->nativeformats, numsubst, NULL);
 		if (!tmp->chan) {
 			/* If we can't, just go on to the next call */
 			ast_log(LOG_NOTICE, "Unable to create channel of type '%s'\n", tech);
@@ -788,7 +801,7 @@
 				ast_verbose(VERBOSE_PREFIX_3 "Forwarding %s to '%s/%s' (thanks to %s)\n", chan->name, tech, stuff, tmp->chan->name);
 			/* Setup parameters */
 			ast_hangup(tmp->chan);
-			tmp->chan = ast_request(tech, chan->nativeformats, stuff);
+			tmp->chan = ast_request(tech, chan->nativeformats, stuff, NULL);
 			if (!tmp->chan) {
 				ast_log(LOG_NOTICE, "Unable to create local channel for call forward to '%s/%s'\n", tech, stuff);
 				free(tmp);
@@ -846,6 +859,8 @@
 		tmp->chan->adsicpe = chan->adsicpe;
 		/* pass the digital flag */
 		ast_dup_flag(tmp->chan, chan, AST_FLAG_DIGITAL);
+		/* Pass the transfer capability */
+		tmp->chan->transfercapability = chan->transfercapability;
 		/* Place the call, but don't wait on the answer */
 		res = ast_call(tmp->chan, numsubst, 0);
 
@@ -898,9 +913,12 @@
 			ast_indicate(chan, AST_CONTROL_RINGING);
 			sentringing++;
 		}
-	} else
+	} else {
 		strncpy(status, "CHANUNAVAIL", sizeof(status) - 1);
-
+		/* See if there is a special message */
+		if (ast_exists_extension(chan, chan->context, chan->exten, chan->priority + 201, chan->callerid)) 
+			chan->priority+=200;
+	}
 	time(&start_time);
 	peer = wait_for_answer(chan, outgoing, &to, &allowredir_in, &allowredir_out, &allowdisconnect_in, &allowdisconnect_out, &sentringing, &noforwardhtml, status, sizeof(status));
 
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_meetme.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_meetme.c
--- ./apps/app_meetme.c	2005-04-15 08:15:39.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_meetme.c	2005-07-14 06:58:47.227724136 +0100
@@ -220,7 +220,7 @@
 			strncpy(cnf->confno, confno, sizeof(cnf->confno) - 1);
 			strncpy(cnf->pin, pin, sizeof(cnf->pin) - 1);
 			cnf->markedusers = 0;
-			cnf->chan = ast_request("zap", AST_FORMAT_ULAW, "pseudo");
+			cnf->chan = ast_request("zap", AST_FORMAT_ULAW, "pseudo", NULL);
 			if (cnf->chan) {
 				cnf->fd = cnf->chan->fds[0];	/* for use by conf_play() */
 			} else {
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_parkandannounce.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_parkandannounce.c
--- ./apps/app_parkandannounce.c	2005-02-19 00:41:21.000000000 +0000
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_parkandannounce.c	2005-07-14 06:59:00.714673808 +0100
@@ -161,7 +161,7 @@
 
 	/* Now place the call to the extention */
 
-	dchan = ast_request_and_dial(dialtech, AST_FORMAT_SLINEAR, dialstr,30000, &outstate, chan->callerid);
+	dchan = ast_request_and_dial(dialtech, AST_FORMAT_SLINEAR, dialstr,30000, &outstate, 0, chan->callerid, NULL);
 
 	if(dchan) {
 		if(dchan->_state == AST_STATE_UP) {
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_qcall.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_qcall.c
--- ./apps/app_qcall.c	2005-04-15 08:15:39.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_qcall.c	2005-07-14 06:59:05.418958648 +0100
@@ -224,7 +224,7 @@
 		pthread_exit(NULL);
 	   }
 	*tele++ = 0;
-	channel = ast_request(dialstr,AST_FORMAT_SLINEAR,tele);
+	channel = ast_request(dialstr,AST_FORMAT_SLINEAR,tele,NULL);
 	if (channel)
 	   {
 		ast_set_read_format(channel,AST_FORMAT_SLINEAR);
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_queue.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_queue.c
--- ./apps/app_queue.c	2005-05-31 04:22:34.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_queue.c	2005-07-14 06:59:12.307911368 +0100
@@ -559,7 +559,7 @@
 		return 0;
 	}
 	/* Request the peer */
-	tmp->chan = ast_request(tmp->tech, qe->chan->nativeformats, tmp->numsubst);
+	tmp->chan = ast_request(tmp->tech, qe->chan->nativeformats, tmp->numsubst, NULL);
 	if (!tmp->chan) {			/* If we can't, just go on to the next call */
 #if 0
 		ast_log(LOG_NOTICE, "Unable to create channel of type '%s'\n", cur->tech);
diff -urNad --exclude=CVS --exclude=.svn ./apps/app_zapras.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_zapras.c
--- ./apps/app_zapras.c	2004-06-22 20:32:52.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/apps/app_zapras.c	2005-07-14 06:59:17.789078104 +0100
@@ -159,7 +159,7 @@
 				}
 			}
 			/* Throw back into audio mode */
-			x = 1;
+			x = 0;
 			ioctl(chan->fds[0], ZT_AUDIOMODE, &x);
 
 			/* Double check buffering too */
diff -urNad --exclude=CVS --exclude=.svn ./app_segfault.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_segfault.c
--- ./app_segfault.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_segfault.c	2005-07-14 06:59:12.308911216 +0100
@@ -0,0 +1,75 @@
+/*
+ * Segfault application
+ * 
+ * An application to provoke a segmentation fault from the dialplan.
+ * (I know what you are thinking now...., but since Asterisk is too stable...
+ *  I needed something to test my failover switches.)
+ *
+ * Copyright (C) 2005 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License. THIS APPLICATION _WILL_ CRASH YOUR
+ * ASTERISK SERVER SO OF COURSE THERE IS NOT LIABILITY FOR NOTHING!
+ */
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+static char *tdesc = "Application for crashing Asterisk with a segmentation fault";
+
+static char *app = "Segfault";
+
+static char *synopsis = "This application will crash Asterisk with a segmentation fault.";
+
+static char *descrip = 
+"  Segfault():  Crash with a segfault. Never returns nufin.\n";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int segfault_exec(struct ast_channel *chan, void *data)
+{
+    struct localuser *u;
+    LOCAL_USER_ADD(u);
+    ((char *)0)[0] = 0;
+    LOCAL_USER_REMOVE(u);
+    return 0;
+}
+
+int unload_module(void)
+{
+    STANDARD_HANGUP_LOCALUSERS;
+    return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+    return ast_register_application(app, segfault_exec, synopsis, descrip);
+}
+
+char *description(void)
+{
+    return tdesc;
+}
+
+int usecount(void)
+{
+    int res;
+    STANDARD_USECOUNT(res);
+    return res;
+}
+
+char *key()
+{
+    return ASTERISK_GPL_KEY;
+}
diff -urNad --exclude=CVS --exclude=.svn ./app_settransfercapability.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_settransfercapability.c
--- ./app_settransfercapability.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/app_settransfercapability.c	2005-07-14 06:59:12.308911216 +0100
@@ -0,0 +1,115 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * App to set the ISDN Transfer Capability
+ * 
+ * Copyright (C) 2005, Frank Sautter, levigo holding gmbh, www.levigo.de
+ *
+ * Frank Sautter - asterisk+at+sautter+dot+com 
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include "asterisk/logger.h"
+#include "asterisk/channel.h"
+#include "asterisk/channel_pvt.h"
+#include "asterisk/pbx.h"
+#include "asterisk/module.h"
+#include "asterisk/options.h"
+#include "asterisk/transcap.h"
+#include <string.h>
+#include <stdlib.h>
+
+
+static char *app = "SetTransferCapability";
+
+static char *synopsis = "Set ISDN Transfer Capability";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static struct {	int val; char *name; } transcaps[] = {
+	{ AST_TRANS_CAP_SPEECH,				"SPEECH" },
+	{ AST_TRANS_CAP_DIGITAL,			"DIGITAL" },
+	{ AST_TRANS_CAP_RESTRICTED_DIGITAL,	"RESTRICTED_DIGITAL" },
+	{ AST_TRANS_CAP_3_1K_AUDIO,			"3K1AUDIO" },
+	{ AST_TRANS_CAP_DIGITAL_W_TONES,	"DIGITAL_W_TONES" },
+	{ AST_TRANS_CAP_VIDEO,				"VIDEO" },
+};
+
+static char *descrip = 
+"  SetTransferCapability(transfercapability): Set the ISDN Transfer \n"
+"Capability of a call to a new value.\n"
+"Always returns 0.  Valid Transfer Capabilities are:\n"
+"\n"
+"  SPEECH             : 0x00 - Speech (default, voice calls)\n"
+"  DIGITAL            : 0x08 - Unrestricted digital information (data calls)\n"
+"  RESTRICTED_DIGITAL : 0x09 - Restricted digital information\n"
+"  3K1AUDIO           : 0x10 - 3.1kHz Audio (fax calls)\n"
+"  DIGITAL_W_TONES    : 0x11 - Unrestricted digital information with tones/announcements\n"
+"  VIDEO              : 0x18 - Video:\n"
+"\n"
+;
+
+static int settransfercapability_exec(struct ast_channel *chan, void *data)
+{
+	char tmp[256] = "";
+	struct localuser *u;
+	int x;
+	char *opts;
+	int transfercapability = -1;
+	
+	if (data)
+		strncpy(tmp, (char *)data, sizeof(tmp) - 1);
+	opts = strchr(tmp, '|');
+	if (opts)
+		*opts = '\0';
+	for (x=0;x<sizeof(transcaps) / sizeof(transcaps[0]);x++) {
+		if (!strcasecmp(transcaps[x].name, tmp)) {
+			transfercapability = transcaps[x].val;
+			break;
+		}
+	}
+	if (transfercapability < 0) {
+		ast_log(LOG_WARNING, "'%s' is not a valid transfer capability (see 'show application SetTransferCapability')\n", tmp);
+		return 0;
+	} else {
+		LOCAL_USER_ADD(u);
+		chan->transfercapability = (unsigned short)transfercapability;
+		LOCAL_USER_REMOVE(u);
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Setting transfer capability to: 0x%.2x - %s.\n", transfercapability, tmp);			
+		return 0;
+	}
+}
+
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, settransfercapability_exec, synopsis, descrip);
+}
+
+char *description(void)
+{
+	return descrip;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
diff -urNad --exclude=CVS --exclude=.svn ./astconf.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/astconf.h
--- ./astconf.h	2003-01-30 15:03:20.000000000 +0000
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/astconf.h	2005-07-14 06:59:17.789078104 +0100
@@ -28,5 +28,6 @@
 extern char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
+extern char ast_config_AST_SYMBOLIC_NAME[20];
 
 #endif
diff -urNad --exclude=CVS --exclude=.svn ./asterisk.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/asterisk.c
--- ./asterisk.c	2005-05-16 04:04:58.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/asterisk.c	2005-07-14 06:59:17.790077952 +0100
@@ -124,6 +124,7 @@
 char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
 char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
 char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
+char ast_config_AST_SYMBOLIC_NAME[20];
 
 static char *_argv[256];
 static int shuttingdown = 0;
@@ -1511,6 +1512,7 @@
 	strncpy((char *)ast_config_AST_PID,AST_PID,sizeof(ast_config_AST_PID)-1);
 	strncpy((char *)ast_config_AST_SOCKET,AST_SOCKET,sizeof(ast_config_AST_SOCKET)-1);
 	strncpy((char *)ast_config_AST_RUN_DIR,AST_RUN_DIR,sizeof(ast_config_AST_RUN_DIR)-1);
+	strncpy((char *)ast_config_AST_SYMBOLIC_NAME,AST_SYMBOLIC_NAME,sizeof(ast_config_AST_SYMBOLIC_NAME)-1);
 	
 	/* no asterisk.conf? no problem, use buildtime config! */
 	if (!cfg) {
@@ -1562,6 +1564,8 @@
 			option_cache_record_files = ast_true(v->value);
 		}  else if (!strcasecmp(v->name, "record_cache_dir")) {
 			strncpy(record_cache_dir,v->value,AST_CACHE_DIR_LEN);
+		} else if (!strcasecmp(v->name, "uniquename")) {
+			strncpy(ast_config_AST_SYMBOLIC_NAME,v->value,sizeof(ast_config_AST_SYMBOLIC_NAME));
 		}
 		v = v->next;
 	}
diff -urNad --exclude=CVS --exclude=.svn ./asterisk.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/asterisk.h
--- ./asterisk.h	2004-09-07 16:02:53.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/asterisk.h	2005-07-14 06:59:17.790077952 +0100
@@ -29,6 +29,7 @@
 #define AST_KEY_DIR	ASTVARLIBDIR "/keys"
 #define AST_DB		ASTVARLIBDIR "/astdb"
 #define AST_TMP_DIR	ASTSPOOLDIR "/tmp"
+#define AST_SYMBOLIC_NAME	"asterisk"
 
 #define AST_CONFIG_FILE ASTCONFPATH
 
diff -urNad --exclude=CVS --exclude=.svn ./channel.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channel.c
--- ./channel.c	2005-06-14 19:41:48.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channel.c	2005-07-14 06:59:17.792077648 +0100
@@ -38,6 +38,8 @@
 #include <asterisk/causes.h>
 #include <asterisk/utils.h>
 #include <asterisk/lock.h>
+#include <asterisk/transcap.h>
+#include "astconf.h"
 #ifdef ZAPTEL_OPTIMIZATIONS
 #include <sys/ioctl.h>
 #ifdef __linux__
@@ -56,8 +58,10 @@
 #define MONITOR_DELAY	150 * 8		/* 150 ms of MONITORING DELAY */
 #endif
 
+extern int ast_mainpid; /* provided by asterisk.c */
 static int shutting_down = 0;
 static int uniqueint = 0;
+AST_MUTEX_DEFINE_STATIC(uniquelock);
 
 /* XXX Lock appropriately in more functions XXX */
 
@@ -229,6 +233,26 @@
 	}
 }
 
+char *ast_transfercapability2str(int transfercapability)
+{
+	switch(transfercapability) {
+	case AST_TRANS_CAP_SPEECH:
+		return "SPEECH";
+	case AST_TRANS_CAP_DIGITAL:
+		return "DIGITAL";
+	case AST_TRANS_CAP_RESTRICTED_DIGITAL:
+		return "RESTRICTED_DIGITAL";
+	case AST_TRANS_CAP_3_1K_AUDIO:
+		return "3K1AUDIO";
+	case AST_TRANS_CAP_DIGITAL_W_TONES:
+		return "DIGITAL_W_TONES";
+	case AST_TRANS_CAP_VIDEO:
+		return "VIDEO";
+	default:
+		return "UNKNOWN";
+	}
+}
+
 
 int ast_best_codec(int fmts)
 {
@@ -271,13 +295,25 @@
 	return 0;
 }
 
+char *ast_alloc_uniqueid(void) {
+    char *uniqueid;
+    uniqueid = malloc(64);
+    if (!uniqueid) return NULL;
+    ast_mutex_lock(&uniquelock);
+    snprintf(uniqueid, 63, "%s-%d-%li.%d", ast_config_AST_SYMBOLIC_NAME, ast_mainpid, (long)time(NULL), uniqueint++);
+    ast_mutex_unlock(&uniquelock);
+//    ast_log(LOG_NOTICE,"uid = %s\n",uniqueid);
+    return uniqueid;
+}
+
 struct ast_channel *ast_channel_alloc(int needqueue)
 {
 	struct ast_channel *tmp;
 	struct ast_channel_pvt *pvt;
 	int x;
 	int flags;
-	struct varshead *headp;        
+	struct varshead *headp;
+	char *tmpuniqueid;
 	        
 	
 	/* If shutting down, don't allocate any new channels */
@@ -336,7 +372,12 @@
 					tmp->data = NULL;
 					tmp->fin = 0;
 					tmp->fout = 0;
-					snprintf(tmp->uniqueid, sizeof(tmp->uniqueid), "%li.%d", (long)time(NULL), uniqueint++);
+					tmpuniqueid = ast_alloc_uniqueid();
+					snprintf(tmp->uniqueid, sizeof(tmp->uniqueid), tmpuniqueid);
+					if (tmpuniqueid) { 
+					    free(tmpuniqueid);
+					    tmpuniqueid = NULL;
+					}
 					headp=&tmp->varshead;
 					ast_mutex_init(&tmp->lock);
 				        AST_LIST_HEAD_INIT(headp);
@@ -520,6 +561,19 @@
 	return NULL;
 }
 
+struct ast_channel *ast_get_channel_by_uniqueid_locked(char *uniqueid)
+{
+	struct ast_channel *chan;
+	chan = ast_channel_walk_locked(NULL);
+	while(chan) {
+		if (!strcasecmp(chan->uniqueid, uniqueid))
+			return chan;
+		ast_mutex_unlock(&chan->lock);
+		chan = ast_channel_walk_locked(chan);
+	}
+	return NULL;
+}
+
 int ast_safe_sleep_conditional(	struct ast_channel *chan, int ms,
 								int (*cond)(void*), void *data )
 {
@@ -1755,14 +1809,14 @@
 	return 0;
 }
 
-struct ast_channel *__ast_request_and_dial(char *type, int format, void *data, int timeout, int *outstate, char *callerid, struct outgoing_helper *oh)
+struct ast_channel *__ast_request_and_dial(char *type, int format, void *data, int timeout, int *outstate, int callingpres, char *callerid, struct outgoing_helper *oh, char* uniqueid)
 {
 	int state = 0;
 	struct ast_channel *chan;
 	struct ast_frame *f;
 	int res = 0;
 	char *variable;
-	chan = ast_request(type, format, data);
+	chan = ast_request(type, format, data, uniqueid);
 	if (chan) {
 		if (oh) {
 			char *tmp, *var;
@@ -1784,6 +1838,7 @@
 		if (callerid && !ast_strlen_zero(callerid))
 			ast_set_callerid(chan, callerid, 1);
 
+		chan->callingpres = callingpres;
 		if (!ast_call(chan, data, 0)) {
 			while(timeout && (chan->_state != AST_STATE_UP)) {
 				res = ast_waitfor(chan, timeout);
@@ -1806,6 +1861,7 @@
 					if (f->subclass == AST_CONTROL_RINGING)
 						state = AST_CONTROL_RINGING;
 					else if ((f->subclass == AST_CONTROL_BUSY) || (f->subclass == AST_CONTROL_CONGESTION)) {
+						res = 0;
 						state = f->subclass;
 						ast_frfree(f);
 						break;
@@ -1865,12 +1921,12 @@
 	return chan;
 }
 
-struct ast_channel *ast_request_and_dial(char *type, int format, void *data, int timeout, int *outstate, char *callerid)
+struct ast_channel *ast_request_and_dial(char *type, int format, void *data, int timeout, int *outstate, int callingpres, char *callerid, char *uniqueid)
 {
-	return __ast_request_and_dial(type, format, data, timeout, outstate, callerid, NULL);
+	return __ast_request_and_dial(type, format, data, timeout, outstate, 0, callerid, NULL, uniqueid);
 }
 
-struct ast_channel *ast_request(char *type, int format, void *data)
+struct ast_channel *ast_request(char *type, int format, void *data, char *uniqueid)
 {
 	struct chanlist *chan;
 	struct ast_channel *c = NULL;
@@ -1896,6 +1952,7 @@
 			if (chan->requester)
 				c = chan->requester(type, capabilities, data);
 			if (c) {
+				if (uniqueid) strncpy(c->uniqueid, uniqueid, sizeof(c->uniqueid));
 				if (c->_state == AST_STATE_DOWN) {
 					manager_event(EVENT_FLAG_CALL, "Newchannel",
 					"Channel: %s\r\n"
@@ -1928,8 +1985,12 @@
 		cut = strchr(name,'-');
 		if (cut)
 		        *cut = 0;
-		if (!strcmp(name, device))
-		        return AST_DEVICE_INUSE;
+		if (!strcmp(name, device)) {
+ 		    if (chan->_state == AST_STATE_RINGING)
+ 			return AST_DEVICE_RINGING;
+ 		    else				
+ 		        return AST_DEVICE_INUSE;
+ 		}
 		chan = ast_channel_walk_locked(chan);
 	}
 	return AST_DEVICE_UNKNOWN;
@@ -2193,6 +2254,29 @@
 	return res;
 }
 
+int ast_channel_masquerade_locked(struct ast_channel *original, struct ast_channel *clone)
+{
+	struct ast_frame null = { AST_FRAME_NULL, };
+	int res = -1;
+	ast_log(LOG_DEBUG, "Planning to masquerade %s into the structure of %s\n",
+		clone->name, original->name);
+	if (original->masq) {
+		ast_log(LOG_WARNING, "%s is already going to masquerade as %s\n", 
+			original->masq->name, original->name);
+	} else if (clone->masqr) {
+		ast_log(LOG_WARNING, "%s is already going to masquerade as %s\n", 
+			clone->name, clone->masqr->name);
+	} else {
+		original->masq = clone;
+		clone->masqr = original;
+		ast_queue_frame(original, &null);
+		ast_queue_frame(clone, &null);
+		ast_log(LOG_DEBUG, "Done planning to masquerade %s into the structure of %s\n", original->name, clone->name);
+		res = 0;
+	}
+	return res;
+}
+
 void ast_change_name(struct ast_channel *chan, char *newname)
 {
 	char tmp[256];
@@ -2303,6 +2387,7 @@
 	}
 
 	/* Start by disconnecting the original's physical side */
+
 	if (clone->pvt->hangup)
 		res = clone->pvt->hangup(clone);
 	if (res) {
@@ -2460,6 +2545,7 @@
 			"Uniqueid: %s\r\n",
 			chan->name, ast_state2str(chan->_state), chan->callerid ? chan->callerid : "<unknown>", chan->uniqueid);
 		} else {
+			ast_device_state_changed(chan->name);
 			manager_event(EVENT_FLAG_CALL, "Newstate", 
 				"Channel: %s\r\n"
 				"State: %s\r\n"
@@ -2534,6 +2620,10 @@
 
 	flags = (config->allowdisconnect_out||config->allowredirect_out ? AST_BRIDGE_DTMF_CHANNEL_0 : 0) + (config->allowdisconnect_in||config->allowredirect_in ? AST_BRIDGE_DTMF_CHANNEL_1 : 0);
 
+	if (IS_DIGITAL(c0->transfercapability) || IS_DIGITAL(c1->transfercapability)) {
+	    flags = 0;
+	}
+
 	firstpass = config->firstpass;
 	config->firstpass = 0;
 
diff -urNad --exclude=CVS --exclude=.svn ./channels/chan_agent.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_agent.c
--- ./channels/chan_agent.c	2005-05-10 04:28:01.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_agent.c	2005-07-14 06:59:25.150958928 +0100
@@ -1091,7 +1091,7 @@
 						chan = agent_new(p, AST_STATE_DOWN);
 					} else if (!p->owner && !ast_strlen_zero(p->loginchan)) {
 						/* Adjustable agent */
-						p->chan = ast_request("Local", format, p->loginchan);
+						p->chan = ast_request("Local", format, p->loginchan, NULL);
 						if (p->chan)
 							chan = agent_new(p, AST_STATE_DOWN);
 					}
diff -urNad --exclude=CVS --exclude=.svn ./channels/chan_sip.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_sip.c
--- ./channels/chan_sip.c	2005-06-21 15:15:55.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_sip.c	2005-07-14 06:59:56.922128976 +0100
@@ -296,6 +296,7 @@
 	struct sip_pvt *refer_call;		/* Call we are referring */
 	struct sip_route *route;		/* Head of linked list of routing steps (fm Record-Route) */
 	int route_persistant;			/* Is this the "real" route? */
+	char *vxml_url;
 	char from[256];				/* The From: header */
 	char useragent[256];			/* User agent in SIP request */
 	char context[AST_MAX_EXTENSION];	/* Context for this call */
@@ -1462,6 +1463,7 @@
 		if (strcasecmp(ast_var_name(current),"VXML_URL")==0)
 	        {
 			vxml_url = ast_var_value(current);
+			p->vxml_url=vxml_url;
 		} else
 		/* Check whether there is a ALERT_INFO variable */
 		if (strcasecmp(ast_var_name(current),"ALERT_INFO")==0)
@@ -3724,12 +3726,11 @@
 	}
 	strncpy(p->uri, invite, sizeof(p->uri) - 1);
 	/* If there is a VXML URL append it to the SIP URL */
-	if (vxml_url)
-	{
-		snprintf(to, sizeof(to), "<%s>;%s", invite, vxml_url);
-	}
-	else
-	{
+	if (vxml_url) {
+		snprintf(to, sizeof(to), "<%s;%s>", invite, vxml_url);
+	} else if (p->vxml_url) {
+		snprintf(to, sizeof(to), "<%s;%s>", invite, p->vxml_url);
+	} else {
 		snprintf(to, sizeof(to), "<%s>", invite);
 	}
 	memset(req, 0, sizeof(struct sip_request));
@@ -3817,6 +3818,7 @@
 	char *mfrom, *mto;
 	struct sip_request req;
 	char clen[20];
+ 	char *StateString;
 
 	memset(from, 0, sizeof(from));
 	memset(to, 0, sizeof(to));
@@ -3851,6 +3853,7 @@
 		add_header(&req, "Subscription-State", "active");
 		add_header(&req, "Content-Type", "application/xpidf+xml");
 
+
 		if ((state==AST_EXTENSION_UNAVAILABLE) || (state==AST_EXTENSION_BUSY))
 			state = 2;
 		else if (state==AST_EXTENSION_INUSE)
@@ -3889,6 +3892,21 @@
 		add_header(&req, "Event", "dialog");
 		add_header(&req, "Content-Type", "application/dialog-info+xml");
 
+ 		switch(state) {
+ 			case AST_EXTENSION_RINGING:
+ 				StateString = "trying";
+// 				StateString = "early";
+ 				break;
+ 			case AST_EXTENSION_INUSE:
+ 			case AST_EXTENSION_BUSY:		
+ 				StateString = "confirmed";
+ 				break;
+ 			case AST_EXTENSION_UNAVAILABLE:
+ 			case AST_EXTENSION_NOT_INUSE:
+ 			default:
+ 				StateString = "terminated";
+ 		}
+
 		t = tmp;		
 		maxbytes = sizeof(tmp);
 		bytes = snprintf(t, maxbytes, "<?xml version=\"1.0\"?>\n");
@@ -3900,9 +3918,19 @@
 		bytes = snprintf(t, maxbytes, "<dialog id=\"%s\">\n", p->exten);
 		t += bytes;
 		maxbytes -= bytes;
-		bytes = snprintf(t, maxbytes, "<state>%s</state>\n", state ? "confirmed" : "terminated");
+ //		ast_log(LOG_NOTICE, "State: %d %s\n", state,StateString);
+ 		bytes = snprintf(t, maxbytes, "<state>%s</state>\n", StateString);
 		t += bytes;
 		maxbytes -= bytes;
+/*		if (state == AST_EXTENSION_RINGING) {
+ 		    bytes = snprintf(t, maxbytes, "<local><identity display=\"%s\">sip:667@192.168.1.241</identity><target uri=\"sip:667@192.168.1.241\"/></local>\n", "test");
+		    t += bytes;
+		    maxbytes -= bytes;
+ 		    bytes = snprintf(t, maxbytes, "<remote><identity display=\"%s\">sip:667@192.168.1.241</identity><target uri=\"sip:667@192.168.1.241\"/></remote>\n", "test");
+		    t += bytes;
+		    maxbytes -= bytes;
+		} 
+*/
 		bytes = snprintf(t, maxbytes, "</dialog>\n</dialog-info>\n");	
 	}
 	if (t > tmp + sizeof(tmp))
@@ -6309,7 +6337,7 @@
 		return -1;
 	}
 	/* Now we have a reply digest */
-	return transmit_invite(p,msg,!strcasecmp(msg, "INVITE"),digest, respheader, NULL,NULL,NULL, init); 
+	return transmit_invite(p,msg,!strcasecmp(msg, "INVITE"),digest, respheader, p->vxml_url,NULL,NULL, init); 
 }
 
 /*--- reply_digest: reply to authentication for outbound registrations ---*/
diff -urNad --exclude=CVS --exclude=.svn ./channels/chan_zap.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_zap.c
--- ./channels/chan_zap.c	2005-06-22 15:01:26.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/channels/chan_zap.c	2005-07-14 07:00:03.933063152 +0100
@@ -7,6 +7,10 @@
  *
  * Mark Spencer <markster@digium.com>
  *
+ * Copyright (C) 2003, 2004, 2005 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  */
@@ -39,6 +43,7 @@
 #include <asterisk/causes.h>
 #include <asterisk/term.h>
 #include <asterisk/utils.h>
+#include <asterisk/transcap.h>
 #include <sys/signal.h>
 #include <errno.h>
 #include <stdlib.h>
@@ -146,8 +151,8 @@
 #define SIG_GR303FXOKS   (0x100000 | ZT_SIG_FXOKS)
 #define SIG_GR303FXSKS   (0x200000 | ZT_SIG_FXSKS)
 
-#define NUM_SPANS 	32
-#define NUM_DCHANS	4		/* No more than 4 d-channels */
+#define NUM_SPANS 	128 	/* "32 spans", muahahaha, us alaws like to have some more... */
+#define NUM_DCHANS	4	/* No more than 4 d-channels */
 #define MAX_CHANNELS	672	/* No more than a DS3 per trunk group */
 #define RESET_INTERVAL	3600	/* How often (in seconds) to reset unused channels */
 
@@ -164,6 +169,9 @@
 static char context[AST_MAX_EXTENSION] = "default";
 static char callerid[256] = "";
 
+static char nocid[256] = "No CID available";
+static char withheldcid[256] = "CID withheld";
+
 static char language[MAX_LANGUAGE] = "";
 static char musicclass[MAX_LANGUAGE] = "";
 static char progzone[10]= "";
@@ -250,7 +258,9 @@
 static char idleext[AST_MAX_EXTENSION];
 static char idledial[AST_MAX_EXTENSION];
 static int overlapdial = 0;
+static int usercid = 0;
 static struct ast_channel inuse = { "GR-303InUse" };
+
 #endif
 
 /* Wait up to 16 seconds for first digit (FXO logic) */
@@ -284,7 +294,9 @@
 static int restart_monitor(void);
 
 static int zt_bridge(struct ast_channel *c0, struct ast_channel *c1, int flags, struct ast_frame **fo, struct ast_channel **rc);
-
+#ifdef ZAPATA_PRI
+static int zt_prisendtext(struct ast_channel *c, char *text);
+#endif
 static int zt_sendtext(struct ast_channel *c, char *text);
 
 static inline int zt_get_event(int fd)
@@ -331,6 +343,27 @@
 #define PRI_CHANNEL(p) ((p) & 0xff)
 #define PRI_SPAN(p) (((p) >> 8) & 0xff)
 
+struct zt_suspended_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char callid[10];			/* the callID provided by the user */
+	int parked_at;			/* extension in the call parking context */
+	struct zt_suspended_call *next;
+};
+
+struct zt_holded_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char uniqueid[AST_MAX_EXTENSION];	/* unique id of the onhold channel */
+	int tei;
+	int cref;
+	int alreadyhungup;
+	struct ast_channel *channel;
+	struct ast_channel *bridge;
+	q931_call *call;	/* this also covers tei mumbojumbo */
+	struct zt_holded_call *next;
+};
+
 struct zt_pri {
 	pthread_t master;			/* Thread of master */
 	ast_mutex_t lock;		/* Mutex */
@@ -344,6 +377,10 @@
 	int nsf;			/* Network-Specific Facilities */
 	int dialplan;			/* Dialing plan */
 	int localdialplan;		/* Local dialing plan */
+	char nocid[256];
+	char withheldcid[256];
+	char nationalprefix[AST_MAX_EXTENSION];	/* prefix to add for national numbers */
+	char internationalprefix[AST_MAX_EXTENSION];	/* prefix to add for international numbers */
 	int dchannels[NUM_DCHANS];	/* What channel are the dchannels on */
 	int trunkgroup;			/* What our trunkgroup is */
 	int mastertrunkgroup;	/* What trunk group is our master */
@@ -359,10 +396,13 @@
 	int span;
 	int resetting;
 	int resetpos;
+	int usercid;	/* trust user provided caller id?? */
 	time_t lastreset;
 	struct zt_pvt *pvts[MAX_CHANNELS];	/* Member channel pvt structs */
 	struct zt_pvt *crvs;				/* Member CRV structs */
 	struct zt_pvt *crvend;				/* Pointer to end of CRV structs */
+	struct zt_suspended_call *suspended_calls; /* Calls parked with SUSPEND messages */
+	struct zt_holded_call *holded_calls; /* Calls on hold */
 };
 
 
@@ -385,6 +425,8 @@
 static int nsf = PRI_NSF_NONE;
 static int dialplan = PRI_NATIONAL_ISDN + 1;
 static int localdialplan = PRI_NATIONAL_ISDN + 1;
+static char nationalprefix[AST_MAX_EXTENSION];	
+static char internationalprefix[AST_MAX_EXTENSION];
 
 #else
 /* Shut up the compiler */
@@ -545,8 +587,9 @@
 	int distinctivering;	/* Which distinctivering to use */
 	int cidrings;			/* Which ring to deliver CID on */
 	
-	int faxhandled;			/* Has a fax tone already been handled? */
-	
+	int faxhandled;			/* Has a fax tone already been handled? If yes, we should never enable EC. */
+					/* KPJ: i will abuse this flag to implement a zapata option for dialing out
+					   on a zap channel with EC to be off no matter what happens. */
 	char mate;			/* flag to say its in MATE mode */
 	int pulsedial;		/* whether a pulse dial phone is detected */
 	int dtmfrelax;		/* whether to run in relaxed DTMF mode */
@@ -557,7 +600,9 @@
 	struct zt_pri *pri;
 	struct zt_pvt *bearer;
 	struct zt_pvt *realcall;
+	int tei;	/* channel in use by this tei */
 	q931_call *call;
+	q931_call *holdedcall;
 	int isidlecall;
 	int resetting;
 	int prioffset;
@@ -585,6 +630,13 @@
 struct zt_pvt *round_robin[32];
 
 #ifdef ZAPATA_PRI
+struct app_tmp {
+	char app[256];
+	char data[256];
+	struct ast_channel *chan;
+	pthread_t t;
+};
+
 static inline int pri_grab(struct zt_pvt *pvt, struct zt_pri *pri)
 {
 	int res;
@@ -634,6 +686,108 @@
 #define CANBUSYDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 #define CANPROGRESSDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 
+static int zt_devicestate(void *data)
+{
+	int groupmatch = 0;
+	int channelmatch = 0;
+	struct zt_pvt *p;
+	char *dest=NULL;
+	int x,d;
+	char *s;
+	char opt=0;
+	int res, y=0;
+	struct zt_pvt *exit, *start, *end;
+	ast_mutex_t *lock;
+	
+	/* Assume we're locking the iflock */
+	lock = &iflock;
+	start = iflist;
+	end = ifend;
+
+	if (data) {
+		dest = ast_strdupa((char *)data);
+	} else {
+		ast_log(LOG_WARNING, "Channel requested with no data\n");
+		return AST_DEVICE_INVALID;
+	}
+	if (toupper(dest[0]) == 'G' || toupper(dest[0])=='R') {
+		/* Retrieve the group number */
+		char *stringp=NULL;
+		stringp=dest + 1;
+		s = strsep(&stringp, "/");
+		if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine group for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		}
+		groupmatch = 1 << x;
+	} else {
+		char *stringp=NULL;
+		stringp=dest;
+		s = strsep(&stringp, "/");
+		p = iflist;
+		if (!strcasecmp(s, "pseudo")) {
+			/* Special case for pseudo */
+			x = CHAN_PSEUDO;
+			channelmatch = x;
+			/* bail out */
+			return AST_DEVICE_INVALID;
+		} 
+
+		else if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine channel for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		} else {
+			channelmatch = x;
+		}
+	}
+	/* Search for an unowned channel */
+	if (ast_mutex_lock(lock)) {
+		ast_log(LOG_ERROR, "Unable to lock interface list???\n");
+		return AST_DEVICE_INVALID;
+	}
+	p = iflist;
+	exit = iflist;
+	res = AST_DEVICE_INVALID; /* start pessimistic */
+	while(p) {
+		if (p) {
+		    ast_mutex_lock(&p->lock);
+		    if ((groupmatch && ((p->group & groupmatch) != 0)) || (channelmatch && (p->channel == channelmatch))) {
+#ifdef ZAPATA_PRI
+			if (p->pri) {
+			    for(d=0;d<NUM_DCHANS;d++) {
+				if (p->pri->dchanavail[d] & DCHAN_UP) {
+			    	    res = AST_DEVICE_UNKNOWN;
+				}
+			    }
+			}
+#endif
+			if ((!ast_strlen_zero(p->callerid) && (strncasecmp(p->callerid, dest, strlen(p->callerid)))) || (!ast_strlen_zero(p->dnid) && (strncasecmp(p->dnid, dest, strlen(p->dnid))))) {
+			    res = AST_DEVICE_UNKNOWN;
+			    if (p->owner) {
+				    if ((p->owner->_state == AST_STATE_RINGING) && (p->outgoing)) {
+			    		res = AST_DEVICE_RINGING;
+				    }
+				    if (((p->owner->_state == AST_STATE_RINGING) && (!p->outgoing)) || (p->owner->_state == AST_STATE_UP) || (p->owner->_state == AST_STATE_DIALING) || (p->owner->_state == AST_STATE_RESERVED) || (p->owner->_state == AST_STATE_RING)){
+			    		res = AST_DEVICE_INUSE;
+				    }
+			    }
+			    if ((res == AST_DEVICE_INUSE) || (res == AST_DEVICE_RINGING)) {
+				/* stop searching now, one non-idle channel is sufficient */
+				ast_mutex_unlock(&p->lock);
+				break;
+			    }
+			}
+		    }
+		    ast_mutex_unlock(&p->lock);
+		}		
+		p = p->next;
+	}
+	ast_mutex_unlock(lock);
+
+	return res;
+
+}
+
 static int zt_get_index(struct ast_channel *ast, struct zt_pvt *p, int nullok)
 {
 	int res;
@@ -1211,11 +1365,15 @@
 {
 	int x;
 	int res;
+	if (p->faxhandled)  {
+		ast_log(LOG_DEBUG, "Not enabling echo cancellation on a fax/modem call\n");
+		return;
+	}
 	if (p->echocanon) {
 		ast_log(LOG_DEBUG, "Echo cancellation already on\n");
 		return;
 	}
-	if (p && p->echocancel) {
+	if (p && p->echocancel && !p->digital) {
 		if (p->sig == SIG_PRI) {
 			x = 1;
 			res = ioctl(p->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &x);
@@ -1238,7 +1396,7 @@
 {
 	int x;
 	int res;
-	if (p && p->echocancel && p->echotraining) {
+	if (p && p->echocancel && p->echotraining && (!p->digital) && (!p->faxhandled)) {
 		x = p->echotraining;
 		res = ioctl(p->subs[SUB_REAL].zfd, ZT_ECHOTRAIN, &x);
 		if (res) 
@@ -1511,7 +1669,11 @@
 		ast_log(LOG_WARNING, "Unable to flush input on channel %d\n", p->channel);
 	p->outgoing = 1;
 
-	set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	if (!IS_DIGITAL(ast->transfercapability)) {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	} else {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, 0, 0, p->law);
+	}
 
 	switch(p->sig) {
 	case SIG_FXOLS:
@@ -1731,6 +1893,14 @@
 #ifdef ZAPATA_PRI
 	if (p->pri) {
 		struct pri_sr *sr;
+		int pridialplan;
+		int dp_strip;
+
+		if ((p->pri->nodetype == BRI_NETWORK_PTMP) || (p->pri->nodetype == BRI_NETWORK)) {
+		    // pass NO audio when ringing an isdn phone
+		    p->dialing = 1;
+		    // maybe we could allow passing audio when calling a p2p PBX, but well... ;-)
+		}
 		c = strchr(dest, '/');
 		if (c)
 			c++;
@@ -1751,6 +1921,7 @@
 			ast_mutex_unlock(&p->lock);
 			return -1;
 		}
+		strncpy(p->dnid, (c + p->stripmsd), sizeof(p->dnid)-1);
 		if (p->sig != SIG_FXSKS) {
 			p->dop.op = ZT_DIAL_OP_REPLACE;
 			s = strchr(c + p->stripmsd, 'w');
@@ -1774,6 +1945,8 @@
 			pri_rel(p->pri);
 			ast_mutex_unlock(&p->lock);
 			return -1;
+		} else {
+		//	ast_log(LOG_NOTICE, "call %d\n", p->call);
 		}
 		if (!(sr = pri_sr_new())) {
 			ast_log(LOG_WARNING, "Failed to allocate setup request channel %d\n", p->channel);
@@ -1788,19 +1961,36 @@
 				ast_log(LOG_DEBUG, "I'm being setup with no bearer right now...\n");
 			pri_set_crv(p->pri->pri, p->call, p->channel, 0);
 		}
-		p->digital = ast_test_flag(ast,AST_FLAG_DIGITAL);
+		p->digital = IS_DIGITAL(ast->transfercapability);
 		pri_sr_set_channel(sr, p->bearer ? PVT_TO_CHANNEL(p->bearer) : PVT_TO_CHANNEL(p), 
 								p->pri->nodetype == PRI_NETWORK ? 0 : 1, 1);
-		pri_sr_set_bearer(sr, p->digital ? PRI_TRANS_CAP_DIGITAL : PRI_TRANS_CAP_SPEECH, 
+		pri_sr_set_bearer(sr, p->digital ? PRI_TRANS_CAP_DIGITAL : ast->transfercapability, 
 					(p->digital ? -1 : 
 						((p->law == ZT_LAW_ALAW) ? PRI_LAYER_1_ALAW : PRI_LAYER_1_ULAW)));
-		pri_sr_set_called(sr, c + p->stripmsd, p->pri->dialplan - 1,  s ? 1 : 0);
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Requested transfer capability: 0x%.2x - %s\n", ast->transfercapability, ast_transfercapability2str(ast->transfercapability));
+		pridialplan = p->pri->dialplan - 1;
+//  ast_log(LOG_NOTICE, "p->digital = %d\n", p->digital);
+		dp_strip = 0;
+		if (pridialplan == -1) { // compute dynamically
+			if (strncmp(c + p->stripmsd, p->pri->internationalprefix, strlen(p->pri->internationalprefix)) == 0) {
+				dp_strip = strlen(p->pri->internationalprefix);
+				pridialplan = PRI_INTERNATIONAL_ISDN;
+			} else if (strncmp(c + p->stripmsd, p->pri->nationalprefix, strlen(p->pri->nationalprefix)) == 0) {
+				dp_strip = strlen(p->pri->nationalprefix);
+				pridialplan = PRI_NATIONAL_ISDN;
+			} else {
+                                pridialplan = PRI_LOCAL_ISDN;
+			}
+		}
+		pri_sr_set_called(sr, c + p->stripmsd + dp_strip, pridialplan,  s ? 1 : 0);
 		pri_sr_set_caller(sr, l, n, p->pri->localdialplan - 1, 
 					l ? (ast->restrictcid ? PRES_PROHIB_USER_NUMBER_PASSED_SCREEN : 
 						(p->use_callingpres ? ast->callingpres : PRES_ALLOWED_USER_NUMBER_PASSED_SCREEN)) : 
 						 PRES_NUMBER_NOT_AVAILABLE);
 		if (pri_setup(p->pri->pri, p->call,  sr)) {
-			ast_log(LOG_WARNING, "Unable to setup call to %s\n", c + p->stripmsd);
+			ast_log(LOG_WARNING, "Unable to setup call to %s (using pridialplan %d)\n", 
+						c + p->stripmsd + dp_strip, pridialplan);
 			pri_rel(p->pri);
 			ast_mutex_unlock(&p->lock);
 			pri_sr_free(sr);
@@ -1935,8 +2125,9 @@
 	}
 	if (newslot < 0) {
 		newslot = 0;
-		ast_log(LOG_WARNING, "No D-channels available!  Using Primary on channel anyway %d!\n",
-			pri->dchannels[newslot]);
+		if (pri->nodetype != BRI_CPE_PTMP) {
+		    ast_log(LOG_WARNING, "No D-channels available!  Using Primary on channel anyway %d!\n", pri->dchannels[newslot]);
+		}
 	}
 	if (old && (oldslot != newslot))
 		ast_log(LOG_NOTICE, "Switching from from d-channel %d to channel %d!\n",
@@ -2130,6 +2321,13 @@
 								icause = atoi(cause);
 						}
 						pri_hangup(p->pri->pri, p->call, icause);
+						if (p->pri->nodetype == BRI_NETWORK_PTMP) {
+						    // fix for hangup in NT mode
+						    // XXX check me
+						    if ((ast->_state == AST_STATE_RINGING) || (ast->_state == AST_STATE_DIALING)) {
+							p->call = NULL;
+						    }
+						}
 					}
 					if (res < 0) 
 						ast_log(LOG_WARNING, "pri_disconnect failed\n");
@@ -2322,10 +2520,14 @@
 			p->proceeding = 2;
 			res = pri_answer(p->pri->pri, p->call, 0, 1);
 			pri_rel(p->pri);
+			/* stop ignoring inband dtmf */
+			p->ignoredtmf = 0;
 		} else {
 			ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
 			res= -1;
 		}
+		/* the audio path is complete now, train the echo canceler */
+		zt_train_ec(p);
 		break;
 #endif
 #ifdef ZAPATA_R2
@@ -2581,7 +2783,7 @@
 	int os1 = -1, os2 = -1;
 	struct ast_channel *oc1, *oc2;
 
-	/* if need DTMF, cant native bridge */
+	/* if need DTMF, cant native bridge (at least not yet...) */
 	if (flags & (AST_BRIDGE_DTMF_CHANNEL_0 | AST_BRIDGE_DTMF_CHANNEL_1))
 		return -2;
 		
@@ -2826,8 +3028,17 @@
 
 static int zt_fixup(struct ast_channel *oldchan, struct ast_channel *newchan)
 {
-	struct zt_pvt *p = newchan->pvt->pvt;
+	struct zt_pvt *p = NULL;
 	int x;
+	if (newchan && newchan->pvt) {
+	    p = newchan->pvt->pvt;
+	}
+	if (!p) {
+	    if (newchan) {
+		ast_log(LOG_ERROR, "channel %s has no pvt->pvt structure\n", newchan->name);
+	    }
+	    return 0;
+	}
 	ast_mutex_lock(&p->lock);
 	ast_log(LOG_DEBUG, "New owner for channel %d is %s\n", p->channel, newchan->name);
 	if (p->owner == oldchan) {
@@ -4037,8 +4248,9 @@
 				}
 			} else if (f->frametype == AST_FRAME_DTMF) {
 #ifdef ZAPATA_PRI
-				if ((p->proceeding < 2) && p->sig==SIG_PRI && p->pri && p->pri->overlapdial) {
-					/* Don't accept in-band DTMF when in overlap dial mode */
+				if ((p->proceeding < 2) && p->sig==SIG_PRI && p->pri && (p->pri->overlapdial || p->ignoredtmf)) {
+					/* Don't accept in-band DTMF when in overlap dial mode 
+					   or when in non-overlap overlapdialing mode ... */
 					f->frametype = AST_FRAME_NULL;
 					f->subclass = 0;
 				}
@@ -4172,7 +4384,9 @@
 #endif
 	/* Write a frame of (presumably voice) data */
 	if (frame->frametype != AST_FRAME_VOICE) {
-		if (frame->frametype != AST_FRAME_IMAGE)
+		if (frame->frametype == AST_FRAME_TEXT) {
+			ast_log(LOG_NOTICE, "text\n");
+		} else if (frame->frametype != AST_FRAME_IMAGE)
 			ast_log(LOG_WARNING, "Don't know what to do with frame type '%d'\n", frame->frametype);
 		return 0;
 	}
@@ -4241,7 +4455,7 @@
 		switch(condition) {
 		case AST_CONTROL_BUSY:
 #ifdef ZAPATA_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_USER_BUSY;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -4311,7 +4525,7 @@
 		case AST_CONTROL_CONGESTION:
 			chan->hangupcause = AST_CAUSE_CONGESTION;
 #ifdef ZAPATA_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -4341,40 +4555,16 @@
 	return res;
 }
 
-#ifdef ZAPATA_PRI
-static void set_calltype(struct ast_channel *chan, int ctype)
-{
-	char *s = "UNKNOWN";
-	switch(ctype) {
-	case PRI_TRANS_CAP_SPEECH:
-		s = "SPEECH";
-		break;
-	case PRI_TRANS_CAP_DIGITAL:
-		s = "DIGITAL";
-		break;
-	case PRI_TRANS_CAP_RESTRICTED_DIGITAL:
-		s = "RESTRICTED_DIGITAL";
-		break;
-	case PRI_TRANS_CAP_3_1K_AUDIO:
-		s = "31KAUDIO";
-		break;
-	case PRI_TRANS_CAP_7K_AUDIO:
-		s = "7KAUDIO";
-		break;
-	case PRI_TRANS_CAP_VIDEO:
-		s = "VIDEO";
-		break;
-	}
-	pbx_builtin_setvar_helper(chan, "CALLTYPE", s);
-}
-#endif
-static struct ast_channel *zt_new(struct zt_pvt *i, int state, int startpbx, int index, int law, int ctype)
+static struct ast_channel *zt_new(struct zt_pvt *i, int state, int startpbx, int index, int law, int transfercapability)
 {
 	struct ast_channel *tmp;
 	int deflaw;
 	int res;
 	int x,y;
 	int features;
+#ifdef ZAPATA_PRI
+	struct zt_pri *pri = NULL;
+#endif
 	ZT_PARAMS ps;
 	tmp = ast_channel_alloc(0);
 	if (tmp) {
@@ -4458,7 +4648,21 @@
 			tmp->rings = 1;
 		tmp->pvt->pvt = i;
 		tmp->pvt->send_digit = zt_digit;
-		tmp->pvt->send_text = zt_sendtext;
+#ifdef ZAPATA_PRI
+		if (i->sig == SIG_PRI) {
+		    pri = i->pri;
+		    if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK) || (pri->nodetype == PRI_NETWORK)) {
+			/* only networks may send displays */
+			tmp->pvt->send_text = zt_prisendtext;
+		    } else {
+			tmp->pvt->send_text = zt_sendtext;
+		    }
+		} else {
+		    tmp->pvt->send_text = zt_sendtext;
+		}
+#else
+ 		tmp->pvt->send_text = zt_sendtext;
+#endif
 		tmp->pvt->call = zt_call;
 		tmp->pvt->hangup = zt_hangup;
 		tmp->pvt->answer = zt_answer;
@@ -4469,8 +4673,12 @@
 		tmp->pvt->indicate = zt_indicate;
 		tmp->pvt->fixup = zt_fixup;
 		tmp->pvt->setoption = zt_setoption;
-		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
-			/* Only FXO signalled stuff can be picked up */
+#ifdef ZAPATA_PRI
+		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS) || (i->sig == SIG_PRI)) {
+#else
+ 		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
+#endif
+		/* Only FXO signalled stuff can be picked up */ /* i dont think so, mr. ulaw! we alaws like to pick up BRIs/PRIs */
 			tmp->callgroup = i->callgroup;
 			tmp->pickupgroup = i->pickupgroup;
 		}
@@ -4507,14 +4715,14 @@
 		tmp->restrictcid = i->restrictcid;
 		tmp->callingpres = i->callingpres;
 #ifdef ZAPATA_PRI
-		set_calltype(tmp, ctype);
+		tmp->transfercapability = transfercapability;
+		pbx_builtin_setvar_helper(tmp, "TRANSFERCAPABILITY", ast_transfercapability2str(transfercapability));
+		if (transfercapability & PRI_TRANS_CAP_DIGITAL) {
+			i->digital = 1;
+		}
 		/* Assume calls are not idle calls unless we're told differently */
 		i->isidlecall = 0;
 		i->alreadyhungup = 0;
-		if (ctype & PRI_TRANS_CAP_DIGITAL) {
-			i->digital = 1;
-			ast_set_flag(tmp, AST_FLAG_DIGITAL);
-		}
 #endif
 		/* clear the fake event in case we posted one before we had ast_chanenl */
 		i->fake_event = 0;
@@ -4643,8 +4851,28 @@
 		while((len < AST_MAX_EXTENSION-1) && ast_matchmore_extension(chan, chan->context, exten, 1, p->callerid)) {
 			if (len && !ast_ignore_pattern(chan->context, exten))
 				tone_zone_play_tone(p->subs[index].zfd, -1);
-			else
+			else {
+			    if ((p->pri->nodetype == BRI_NETWORK_PTMP) || (p->pri->nodetype == BRI_NETWORK)) {
+				// dont double digits if the phone sends CPN and dtmf!
+    				if (ast_app_has_voicemail(p->callerid)) {
+				    int newm, oldm;
+				    char temp[256];
+				    ast_app_messagecount(p->callerid,&newm,&oldm);
+				    snprintf(temp,sizeof(temp)-1,"VoiceMail (%d/%d)",newm,oldm); 
+				    //    pri_information_display(pri->pri,pri->pvt[chan]->call,(char *)temp); 
+				    //    strncpy(pri->pvts[chanpos]->call->display,sizeof(pri->pvt[chan]->call->display), temp);
+#ifdef ZT_TONE_STUTTER
+				    tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_STUTTER);
+#else
+				    tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALRECALL);
+#endif
+				} else {
+			    	    tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+				}
+			    } else {
 				tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+			    }
+			}
 			if (ast_exists_extension(chan, chan->context, exten, 1, p->callerid))
 				timeout = matchdigittimeout;
 			else
@@ -4680,6 +4908,10 @@
 			ast_log(LOG_DEBUG, "No such possible extension '%s' in context '%s'\n", exten, chan->context);
 			chan->hangupcause = AST_CAUSE_UNALLOCATED;
 			ast_hangup(chan);
+			if ((p->pri->nodetype == BRI_NETWORK_PTMP) || (p->pri->nodetype == BRI_NETWORK)) {
+			    // this might apply for pri, too...
+			    p->call = NULL;
+			}
 		}
 		return NULL;
 		break;
@@ -6083,6 +6315,8 @@
 		} else {
 			if (si->totalchans == 31) { /* if it's an E1 */
 				pris[*span].dchannels[0] = 16 + offset;
+			} else if (si->totalchans == 3) { /* if it's an S0 ZAPBRI */
+				pris[*span].dchannels[0] = 3 + offset;
 			} else {
 				pris[*span].dchannels[0] = 24 + offset;
 			}
@@ -6333,6 +6567,11 @@
 						destroy_zt_pvt(&tmp);
 						return NULL;
 					}
+                                        if ((pris[span].localdialplan) && (pris[span].localdialplan != localdialplan)) {
+                                                ast_log(LOG_ERROR, "Span %d is already a %s local dialing plan\n", span + 1, pri_plan2str(pris[span].localdialplan));
+                                                free(tmp);
+                                                return NULL;
+					}
 					if (!ast_strlen_zero(pris[span].idledial) && strcmp(pris[span].idledial, idledial)) {
 						ast_log(LOG_ERROR, "Span %d already has idledial '%s'.\n", span + 1, idledial);
 						destroy_zt_pvt(&tmp);
@@ -6360,6 +6599,11 @@
 						return NULL;
 					}
 					pris[span].nodetype = pritype;
+// XXX
+					if (pritype == BRI_NETWORK_PTMP) {
+					    pris[span].dchanavail[0] =  DCHAN_AVAILABLE;
+					    pri_find_dchan(&pris[span]);
+					}
 					pris[span].switchtype = myswitchtype;
 					pris[span].nsf = nsf;
 					pris[span].dialplan = dialplan;
@@ -6368,8 +6612,15 @@
 					pris[span].minunused = minunused;
 					pris[span].minidle = minidle;
 					pris[span].overlapdial = overlapdial;
+					pris[span].usercid = usercid;
+					pris[span].suspended_calls = NULL;
+					pris[span].holded_calls = NULL;
 					strncpy(pris[span].idledial, idledial, sizeof(pris[span].idledial) - 1);
 					strncpy(pris[span].idleext, idleext, sizeof(pris[span].idleext) - 1);
+					strncpy(pris[span].nocid, nocid, sizeof(pris[span].nocid) - 1);
+					strncpy(pris[span].withheldcid, withheldcid, sizeof(pris[span].withheldcid) - 1);
+					strncpy(pris[span].nationalprefix, nationalprefix, sizeof(pris[span].nationalprefix) - 1);
+					strncpy(pris[span].internationalprefix, internationalprefix, sizeof(pris[span].internationalprefix) - 1);
 					
 					tmp->pri = &pris[span];
 					tmp->prioffset = offset;
@@ -6764,7 +7015,7 @@
 			break;
 		if (!backwards && (x >= pri->numchans))
 			break;
-		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner) {
+		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner && !pri->pvts[x]->call) {
 			ast_log(LOG_DEBUG, "Found empty available channel %d/%d\n", 
 				pri->pvts[x]->logicalspan, pri->pvts[x]->prioffset);
 			return x;
@@ -6809,7 +7060,7 @@
 	end = ifend;
 	/* We do signed linear */
 	oldformat = format;
-	format &= (AST_FORMAT_SLINEAR | AST_FORMAT_ULAW);
+	format &= (AST_FORMAT_SLINEAR | AST_FORMAT_ULAW | AST_FORMAT_ALAW);
 	if (!format) {
 		ast_log(LOG_NOTICE, "Asked to get a channel of unsupported format '%d'\n", oldformat);
 		return NULL;
@@ -6966,8 +7217,15 @@
 				} else if (opt == 'd') {
 					/* If this is an ISDN call, make it digital */
 					p->digital = 1;
-					if (tmp)
-						ast_set_flag(tmp, AST_FLAG_DIGITAL);
+					if (tmp) { 
+					    tmp->transfercapability = AST_TRANS_CAP_DIGITAL;
+					}
+				} else if (opt == 'm') {
+					/* If this is a modem/fax call, pretend to have the fax handled and dont do EC */
+					p->faxhandled = 1;
+					if (tmp) { 
+					    tmp->transfercapability = AST_TRANS_CAP_3_1K_AUDIO;
+					}
 				} else {
 					ast_log(LOG_WARNING, "Unknown option '%c' in '%s'\n", opt, (char *)data);
 				}
@@ -7025,6 +7283,57 @@
 	return NULL;
 }
 
+static int pri_find_tei(struct zt_pri *pri, q931_call *c, int tei)
+{
+	int x=0;
+	for (x=0;x<pri->numchans;x++) {
+		if (!pri->pvts[x]) continue;
+		if ((pri->pvts[x]->tei == tei) && (pri->pvts[x]-> call != c)) {
+		    return x;
+		}
+	}
+	return -1;
+}
+
+static struct zt_holded_call *pri_get_callonhold(struct zt_pri *pri, int cref, int tei) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if ((zhc->tei == tei) && ((zhc->cref == cref) || (cref == -1))) {
+		return zhc;
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	return NULL;	
+}
+
+static int pri_destroy_callonhold(struct zt_pri *pri, struct zt_holded_call *onhold) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if (zhc == onhold) {
+		if (zhctemp) {
+		    zhctemp->next = zhc->next;
+		    zhc = zhctemp;
+		} else {
+		    pri->holded_calls = zhc->next;
+		    zhc = pri->holded_calls;
+		    zhctemp = NULL;
+		}
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	if (onhold) {
+	    free(onhold);
+	    onhold = NULL;
+	    return 1;	
+	}
+	return 0;	
+}
 
 static int pri_find_principle(struct zt_pri *pri, int channel)
 {
@@ -7034,6 +7343,8 @@
 	span = PRI_SPAN(channel);
 	channel = PRI_CHANNEL(channel);
 	
+//	ast_log(LOG_NOTICE, "span %d channel %d\n",span,channel);
+	
 	for (x=0;x<pri->numchans;x++) {
 		if (pri->pvts[x] && (pri->pvts[x]->prioffset == channel) && (pri->pvts[x]->logicalspan == span)) {
 			principle = x;
@@ -7047,7 +7358,9 @@
 static int pri_fixup_principle(struct zt_pri *pri, int principle, q931_call *c)
 {
 	int x;
+	int res = 0;
 	struct zt_pvt *crv;
+	char tmpname[256];
 	if (!c) {
 		if (principle < 0)
 			return -1;
@@ -7061,6 +7374,7 @@
 	/* First, check for other bearers */
 	for (x=0;x<pri->numchans;x++) {
 		if (!pri->pvts[x]) continue;
+// ast_log(LOG_NOTICE, "principle %d channel %d call %d channel[x]->call %d\n",principle, x, c, pri->pvts[x]->call);
 		if (pri->pvts[x]->call == c) {
 			/* Found our call */
 			if (principle != x) {
@@ -7074,17 +7388,53 @@
 				}
 				/* Fix it all up now */
 				pri->pvts[principle]->owner = pri->pvts[x]->owner;
+ 				pri->pvts[principle]->outgoing = pri->pvts[x]->outgoing;
 				if (pri->pvts[principle]->owner) {
 					pri->pvts[principle]->owner->pvt->pvt = pri->pvts[principle];
 					pri->pvts[principle]->owner->fds[0] = pri->pvts[principle]->subs[SUB_REAL].zfd;
 					pri->pvts[principle]->subs[SUB_REAL].owner = pri->pvts[x]->subs[SUB_REAL].owner;
-				} else
+				} else {
 					ast_log(LOG_WARNING, "Whoa, there's no  owner, and we're having to fix up channel %d to channel %d\n", pri->pvts[x]->channel, pri->pvts[principle]->channel);
+				}
 				pri->pvts[principle]->call = pri->pvts[x]->call;
+ 				pri->pvts[principle]->dsp = pri->pvts[x]->dsp;
+ 				pri->pvts[principle]->alreadyhungup = pri->pvts[x]->alreadyhungup;
+				pri->pvts[principle]->digital = pri->pvts[x]->digital;
+ 				pri->pvts[principle]->faxhandled = pri->pvts[x]->faxhandled;
+
+ 				if ((pri->nodetype == BRI_CPE_PTMP) || (pri->nodetype == BRI_CPE)) { 
+ 				    /* this might also apply for other pri types! */
+ 				    pri->pvts[principle]->law = pri->pvts[x]->law;
+ 				    if (ioctl(pri->pvts[principle]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &pri->pvts[principle]->law) == -1)
+ 					ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", pri->pvts[principle]->channel, pri->pvts[principle]->law);
+ 				    res = zt_setlaw(pri->pvts[principle]->subs[SUB_REAL].zfd, pri->pvts[principle]->law);
+ 				    if (res < 0) 
+ 					ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[principle]->channel);
+				    if (!pri->pvts[principle]->digital) {
+ 					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, pri->pvts[principle]->rxgain, pri->pvts[principle]->txgain, pri->pvts[principle]->law);
+ 				    } else {
+ 					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[principle]->law);
+				    }
+				    if (res < 0) 
+ 				        ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[principle]->channel);
+ 				    zt_confmute(pri->pvts[x], 0);
+ 				    update_conf(pri->pvts[x]);
+ 				    reset_conf(pri->pvts[x]);
+ 				    restore_gains(pri->pvts[x]);
+ 				    zt_disable_ec(pri->pvts[x]);
+ 				    zt_setlinear(pri->pvts[x]->subs[SUB_REAL].zfd, 0);
+ 				}
+ 
+ 				if (pri->pvts[principle]->owner) {
+ 				    snprintf(tmpname, sizeof(tmpname), "Zap/%d-1", pri->pvts[principle]->channel);
+ 				    ast_change_name(pri->pvts[principle]->owner, tmpname);
+ 				}
+
 				/* Free up the old channel, now not in use */
 				pri->pvts[x]->subs[SUB_REAL].owner = NULL;
 				pri->pvts[x]->owner = NULL;
 				pri->pvts[x]->call = NULL;
+				pri->pvts[x]->dsp = NULL;
 			}
 			return principle;
 		}
@@ -7113,7 +7463,9 @@
 		}
 		crv = crv->next;
 	}
-	ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+	    ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	}
 	return -1;
 }
 
@@ -7184,6 +7536,9 @@
 
 static int pri_check_restart(struct zt_pri *pri)
 {
+	if ((pri->nodetype != PRI_NETWORK) || (pri->nodetype != PRI_CPE)) {
+	    return 0;
+	}
 	do {
 		pri->resetpos++;
 	} while((pri->resetpos < pri->numchans) &&
@@ -7227,6 +7582,29 @@
 	return 0;
 }
 
+static void pri_make_callerid(struct zt_pri *pri, char *callerid,char *callingnum, char *callingname,int callingplan, int callingpres, int stripmsd) {
+    char tmpstr[256];
+
+    if (callingnum && (strlen(callingnum) > stripmsd)) {
+	callingnum += stripmsd;
+    }
+
+    switch (callingplan) {
+	case PRI_NATIONAL_ISDN:
+	    snprintf(callerid, AST_MAX_EXTENSION, "%s%s",pri->nationalprefix, callingnum);
+	    break;
+	case PRI_INTERNATIONAL_ISDN:
+	    snprintf(callerid, AST_MAX_EXTENSION, "%s%s", pri->internationalprefix, callingnum);
+	    break;
+	default:
+	    strncpy(callerid, callingnum, AST_MAX_EXTENSION);
+	}
+	if (!ast_strlen_zero(callingname)) {
+	    strncpy(tmpstr, callingnum, sizeof(tmpstr));
+	    snprintf(callerid, AST_MAX_EXTENSION, "\"%s\" <%s>", callingname, tmpstr);
+	}
+}
+
 static void *pri_dchannel(void *vpri)
 {
 	struct zt_pri *pri = vpri;
@@ -7312,6 +7690,8 @@
 				} else if (pri->pvts[x] && pri->pvts[x]->owner && pri->pvts[x]->isidlecall)
 					activeidles++;
 			}
+	//    ast_log(LOG_NOTICE, "name = %s condition = %d index = %d (%d) zfd = %d res = %d\n",chan->name, condition, index, SUB_REAL, p->subs[index].zfd, res);
+
 #if 0
 			printf("nextidle: %d, haveidles: %d, minunsed: %d\n",
 				nextidle, haveidles, minunused);
@@ -7444,37 +7824,103 @@
 					break;
 			}
 		} else if (errno != EINTR)
-			ast_log(LOG_WARNING, "pri_event returned error %d (%s)\n", errno, strerror(errno));
+			ast_log(LOG_WARNING, "pri_event returned error %d (%s) on span %d\n", errno, strerror(errno), pri->span);
 
 		if (e) {
 			if (pri->debug)
 				pri_dump_event(pri->dchans[which], e);
 			switch(e->e) {
 			case PRI_EVENT_DCHAN_UP:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
-				pri->dchanavail[which] |= DCHAN_UP;
-				pri_find_dchan(pri);
+				if (pri->nodetype == BRI_NETWORK_PTMP) {
+				    if (option_verbose > 3) 
+					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+				    pri->dchanavail[which] |= (DCHAN_PROVISIONED | DCHAN_NOTINALARM | DCHAN_UP);
+				    pri_find_dchan(pri);
 
-				/* Note presense of D-channel */
-				time(&pri->lastreset);
+				    /* Note presense of D-channel */
+				    time(&pri->lastreset);
 
-				/* Restart in 5 seconds */
-				pri->lastreset -= RESET_INTERVAL;
-				pri->lastreset += 5;
-				pri->resetting = 0;
-				/* Take the channels from inalarm condition */
-				for (i=0; i<pri->numchans; i++)
+				    pri->resetting = 0;
+				    /* Take the channels from inalarm condition */
+				    for (i=0; i<pri->numchans; i++)
 					if (pri->pvts[i]) {
 						pri->pvts[i]->inalarm = 0;
 					}
+				} else {
+				    if (pri->nodetype == BRI_CPE_PTMP) {
+					if (option_verbose > 3) 
+					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+				    } else {
+					if (option_verbose > 1) 
+					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+				    }
+				    pri->dchanavail[which] |= (DCHAN_PROVISIONED | DCHAN_NOTINALARM | DCHAN_UP);
+				    pri_find_dchan(pri);
+
+				    /* Note presense of D-channel */
+				    time(&pri->lastreset);
+
+				    /* Restart in 5 seconds */
+				    pri->lastreset -= RESET_INTERVAL;
+				    pri->lastreset += 5;
+				    pri->resetting = 0;
+				    /* Take the channels from inalarm condition */
+ 				    for (i=0; i<pri->numchans; i++) {
+					struct zt_pvt *p = pri->pvts[i];
+  					if (p) {
+  					    p->inalarm = 0;
+// XXX COLT
+//					    pri_reset(pri->pri, PVT_TO_CHANNEL(p));
+					    /* just to be sure */
+					    if (p->call) {
+						if (p->pri && p->pri->pri) {
+						    pri_destroycall(p->pri->pri, p->call);
+						    p->call = NULL;
+						}
+					    }
+  					}
+				    }
+				}
 				break;
 			case PRI_EVENT_DCHAN_DOWN:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
-				pri->dchanavail[which] &= ~DCHAN_UP;
-				pri_find_dchan(pri);
-				if (!pri_is_up(pri)) {
+				if (pri->nodetype == BRI_NETWORK_PTMP) {
+				    if (option_verbose > 3) 
+					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+				    // PTMP BRIs have N dchans, handled by libpri
+				    if (e->gen.tei == 0) break;
+				    /* Hangup active channels */
+				    for (i=0; i<pri->numchans; i++) {
+				    	struct zt_pvt *p = pri->pvts[i];
+					if (p) {
+			//		ast_log(LOG_NOTICE, "chan %d tei %d\n",i,p->tei);
+					    if (p->tei == e->gen.tei) {
+						if (p->call) {
+							if (p->pri && p->pri->pri) {
+								pri_hangup(p->pri->pri, p->call, -1);
+								pri_destroycall(p->pri->pri, p->call);
+								p->tei = -1;
+								p->call = NULL;
+							} else
+								ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
+						}
+						if (p->owner)
+						    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+						p->inalarm = 1;
+						p->tei = 0;
+					    }
+					}
+				    } 
+				} else {
+				    if (pri->nodetype == BRI_CPE_PTMP) {
+					if (option_verbose > 3) 
+					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+				    } else {
+					if (option_verbose > 1) 
+					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+				    }
+				    pri->dchanavail[which] &= ~DCHAN_UP;
+				    pri_find_dchan(pri);
+				    if (!pri_is_up(pri)) {
 					pri->resetting = 0;
 					/* Hangup active channels and put them in alarm mode */
 					for (i=0; i<pri->numchans; i++) {
@@ -7495,6 +7941,7 @@
 							p->inalarm = 1;
 						}
 					}
+				    }
 				}
 				break;
 			case PRI_EVENT_RESTART:
@@ -7545,9 +7992,11 @@
 				} else {
 					chanpos = pri_fixup_principle(pri, chanpos, e->ring.call);
 					if (chanpos > -1) {
+//					ast_log(LOG_NOTICE, "INFO received on  channel %d/%d span %d\n", 
+//						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						/* queue DTMF frame if the PBX for this call was already started (we're forwarding INFORMATION further on */
-						if (pri->overlapdial && pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
+						if (pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
 							/* how to do that */
 							int digitlen = strlen(e->ring.callednum);
 							char digit;
@@ -7559,6 +8008,14 @@
 									zap_queue_frame(pri->pvts[chanpos], &f, pri);
 								}
 							}
+							if (!pri->overlapdial) {
+							    strncat(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
+							    if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+							    } else {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+							    }
+							} 
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
@@ -7572,14 +8029,23 @@
 					chanpos = pri_find_principle(pri, e->ring.channel);
 				/* if no channel specified find one empty */
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Ring requested on unconfigured channel %d/%d span %d\n", 
+					if (pri->nodetype == BRI_CPE_PTMP) {
+					    if (option_verbose > 2)
+						ast_verbose(VERBOSE_PREFIX_3 "Ignoring callwaiting SETUP on channel %d/%d span %d %d\n", PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span, e->ring.channel);
+					    
+					    pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_USER_BUSY);
+					    break;
+					} else {
+					    ast_log(LOG_WARNING, "Ring requested on unconfigured channel %d/%d span %d\n", 
 						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+					}
 				} else {
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
 					if (pri->pvts[chanpos]->owner) {
 						if (pri->pvts[chanpos]->call == e->ring.call) {
 							ast_log(LOG_WARNING, "Duplicate setup requested on channel %d/%d already in use on span %d\n", 
 								PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+							ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 							break;
 						} else {
 							ast_log(LOG_WARNING, "Ring requested on channel %d/%d already in use on span %d.  Hanging up owner.\n", 
@@ -7599,6 +8065,9 @@
 					chanpos = pri_find_empty_chan(pri, 1);
 				if (chanpos > -1) {
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					/* this channel is owned by this TEI */
+					pri->pvts[chanpos]->tei = e->ring.tei;
+					// ast_log(LOG_NOTICE, "setting tei %d for chan %d\n",e->ring.tei, chanpos);
 					if (pri->switchtype == PRI_SWITCH_GR303_TMC) {
 						/* Should be safe to lock CRV AFAIK while bearer is still locked */
 						crv = pri_find_crv(pri, pri_get_crv(pri->pri, e->ring.call, NULL));
@@ -7620,15 +8089,23 @@
 						}
 					}
 					pri->pvts[chanpos]->call = e->ring.call;
+					/* dont double digits when TAs send DTMF and CPN! */
+					pri->pvts[chanpos]->ignoredtmf = 1;
 					/* Get caller ID */
 					if (pri->pvts[chanpos]->use_callerid) {
-						if (!ast_strlen_zero(e->ring.callingname)) {
-							snprintf(pri->pvts[chanpos]->callerid, sizeof(pri->pvts[chanpos]->callerid), "\"%s\" <%s>", e->ring.callingname, e->ring.callingnum);
-						} else
-							strncpy(pri->pvts[chanpos]->callerid, e->ring.callingnum, sizeof(pri->pvts[chanpos]->callerid)-1);
-					} else
-						pri->pvts[chanpos]->callerid[0] = '\0';
-					strncpy(pri->pvts[chanpos]->rdnis, e->ring.redirectingnum, sizeof(pri->pvts[chanpos]->rdnis) - 1);
+					    if (pri->usercid) {
+						pri_make_callerid(pri, pri->pvts[chanpos]->callerid, e->ring.callingnumuser, "", e->ring.callingplanuser, e->ring.callingpresuser, 0);
+					    } else {
+						pri_make_callerid(pri, pri->pvts[chanpos]->callerid, e->ring.callingnum, e->ring.callingname, e->ring.callingplan, e->ring.callingpres, 0);
+					    }
+					} else {
+					    pri->pvts[chanpos]->callerid[0] = '\0';
+					}
+					strncpy(pri->pvts[chanpos]->rdnis, e->ring.redirectingnum, sizeof(pri->pvts[chanpos]->rdnis)-1);
+					if (pri->pvts[chanpos]->owner) {
+						pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "PRI_REDIRECTING_NUM", e->ring.redirectingnum);
+					}
+
 					/* If immediate=yes go to s|1 */
 					if (pri->pvts[chanpos]->immediate) {
 						if (option_verbose > 2)
@@ -7638,10 +8115,50 @@
 					}
 					/* Get called number */
 					else if (!ast_strlen_zero(e->ring.callednum)) {
-						strncpy(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten)-1);
-						strncpy(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid) - 1);
-					} else
-						pri->pvts[chanpos]->exten[0] = '\0';
+						if (strlen(e->ring.useruserinfo)) {
+						    if (pri->pvts[chanpos]->owner) {
+							pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "UUI", e->ring.useruserinfo);
+						    }
+						}
+						pri_make_callerid(pri, pri->pvts[chanpos]->dnid, e->ring.callednum, "", e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+						pri_make_callerid(pri, pri->pvts[chanpos]->exten, e->ring.callednum, "", e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						    /* if we get the next digit we should stop the dialtone */
+						    if (!pri->overlapdial) {
+							// with overlapdial=no the exten is always prefixed by "s"
+							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+							} else {
+							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+							}
+						    } else {
+							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten)) {
+							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+							} else {
+							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+							}
+						    }
+						}
+					} else {
+					    if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						if (!pri->overlapdial) {
+						    // be able to set digittimeout for BRI phones
+						    pri->pvts[chanpos]->exten[0] = 's';
+						    pri->pvts[chanpos]->exten[1] = '\0';
+						    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+						} else {
+						    pri->pvts[chanpos]->exten[0] = '\0';
+						}
+					    } else {
+						if (pri->nodetype == BRI_CPE) { 
+						    /* fix for .at p2p bri lines */
+						    pri->pvts[chanpos]->exten[0] = 's';
+						    pri->pvts[chanpos]->exten[1] = '\0';
+						} else {
+						    pri->pvts[chanpos]->exten[0] = '\0';
+						}
+					    }
+					}
 					/* Set DNID on all incoming calls -- even immediate */
 					if (!ast_strlen_zero(e->ring.callednum))
 						strncpy(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid) - 1);
@@ -7670,20 +8187,43 @@
 						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
 						if (res < 0) 
 							ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[chanpos]->channel);
-						res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+						if (!pri->pvts[chanpos]->digital) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						} else {
+ 						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						}
 						if (res < 0)
-							ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[chanpos]->channel);
-						if (e->ring.complete || !pri->overlapdial) {
+						    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[chanpos]->channel);
+						if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+						    if (e->ring.complete || !pri->overlapdial) {
 							/* Just announce proceeding */
 							pri_proceeding(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 0);
-						} else  {
+						    } else  {
 							if (pri->switchtype != PRI_SWITCH_GR303_TMC) 
 								pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
 							else
 								pri_answer(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+						    }
+						} else {
+							if (pri->overlapdial || (!strcasecmp(pri->pvts[chanpos]->exten, "s"))) {
+							    pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+							} else {
+							    pri_acknowledge(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+							}
 						}
 						/* Get the use_callingpres state */
 						pri->pvts[chanpos]->callingpres = e->ring.callingpres;
+						switch (e->ring.callingpres) {
+						    case PRES_PROHIB_USER_NUMBER_NOT_SCREENED:
+						    case PRES_PROHIB_USER_NUMBER_PASSED_SCREEN:
+						    case PRES_PROHIB_USER_NUMBER_FAILED_SCREEN:
+						    case PRES_PROHIB_NETWORK_NUMBER:
+							strncpy(pri->pvts[chanpos]->callerid, pri->withheldcid, sizeof(pri->pvts[chanpos]->callerid));
+							break;
+						    case PRES_NUMBER_NOT_AVAILABLE:
+							strncpy(pri->pvts[chanpos]->callerid, pri->nocid, sizeof(pri->pvts[chanpos]->callerid));
+							break;
+						}
 						/* Start PBX */
 						if (pri->overlapdial && ast_matchmore_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->callerid)) {
 							/* Release the PRI lock while we create the channel */
@@ -7696,15 +8236,29 @@
 								ast_log(LOG_DEBUG, "Started up crv %d:%d on bearer channel %d\n", pri->trunkgroup, crv->channel, crv->bearer->channel);
 							} else {
 								c = zt_new(pri->pvts[chanpos], AST_STATE_RESERVED, 0, SUB_REAL, law, e->ring.ctype);
+								zt_enable_ec(pri->pvts[chanpos]);
+							}
+							if (!ast_strlen_zero(e->ring.useruserinfo)) {
+								pbx_builtin_setvar_helper(c, "UUI", e->ring.useruserinfo);
 							}
 							if(!ast_strlen_zero(e->ring.callingsubaddr)) {
 								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
 							}
+					    		if (!ast_strlen_zero(e->ring.callingnum)) {
+							    char tmpstr[256];
+							    pri_make_callerid(pri, tmpstr, e->ring.callingnum, e->ring.callingname, e->ring.callingplan, e->ring.callingpres, 0);
+							    pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+							}
+							if (!ast_strlen_zero(e->ring.callingnumuser)) {
+							    char tmpstr[256];
+							    pri_make_callerid(pri, tmpstr, e->ring.callingnumuser, "", e->ring.callingplanuser, e->ring.callingpresuser, 0);
+							    pbx_builtin_setvar_helper(c, "PRI_USER_CID", e->ring.callednum);
+							}
 							ast_mutex_lock(&pri->lock);
 							if (c && !ast_pthread_create(&threadid, &attr, ss_thread, c)) {
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap call from '%s' to '%s' on channel %d/%d, span %d\n",
-										e->ring.callingnum, !ast_strlen_zero(pri->pvts[chanpos]->exten) ? pri->pvts[chanpos]->exten : "<unspecified>", 
+									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+										pri->pvts[chanpos]->digital ? "data" : "voice", e->ring.callingnum, !ast_strlen_zero(pri->pvts[chanpos]->exten) ? pri->pvts[chanpos]->exten : "<unspecified>", 
 										pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
@@ -7723,10 +8277,26 @@
 							ast_mutex_lock(&pri->lock);
 							if (c) {
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting call from '%s' to '%s' on channel %d/%d, span %d\n",
-										e->ring.callingnum, pri->pvts[chanpos]->exten, 
+									ast_verbose(VERBOSE_PREFIX_3 "Accepting %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+										pri->pvts[chanpos]->digital ? "data" : "voice", e->ring.callingnum, pri->pvts[chanpos]->exten, 
 											pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
-								zt_enable_ec(pri->pvts[chanpos]);
+							    zt_enable_ec(pri->pvts[chanpos]);
+							    if (e->ring.useruserinfo) {
+								pbx_builtin_setvar_helper(c, "UUI", e->ring.useruserinfo);
+							    }
+							    if(!ast_strlen_zero(e->ring.callingsubaddr)) {
+								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
+							    }
+					    		    if (!ast_strlen_zero(e->ring.callingnum)) {
+								char tmpstr[256];
+							        pri_make_callerid(pri, tmpstr, e->ring.callingnum, e->ring.callingname, e->ring.callingplan, e->ring.callingpres, 0);
+							        pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+							    }
+							    if (!ast_strlen_zero(e->ring.callingnumuser)) {
+								char tmpstr[256];
+							        pri_make_callerid(pri, tmpstr, e->ring.callingnumuser, "", e->ring.callingplanuser, e->ring.callingpresuser, 0);
+							        pbx_builtin_setvar_helper(c, "PRI_USER_CID", e->ring.callednum);
+							    }
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
@@ -7764,7 +8334,7 @@
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (ast_strlen_zero(pri->pvts[chanpos]->dop.dialstr)) {
-							zt_enable_ec(pri->pvts[chanpos]);
+				//			zt_enable_ec(pri->pvts[chanpos]);
 							pri->pvts[chanpos]->subs[SUB_REAL].needringing =1;
 							pri->pvts[chanpos]->proceeding=2;
 						} else
@@ -7777,7 +8347,13 @@
 				/* Get chan value if e->e is not PRI_EVNT_RINGING */
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
-					if (pri->overlapdial && !pri->pvts[chanpos]->proceeding) {
+					if ((e->proceeding.cause == PRI_CAUSE_USER_BUSY) && (pri->pvts[chanpos]->priindication_oob != 2)) {
+					    /* received PROGRESS with cause BUSY, no inband callprogress wanted => hang up! */
+					    if (pri->pvts[chanpos]->owner) {
+						pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					    }
+					} else {
+					    if (pri->overlapdial && !pri->pvts[chanpos]->proceeding) {
 						struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, };
 						
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
@@ -7785,13 +8361,21 @@
 								pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset,pri->span);
 							zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    }
 					}
 				}
 				break;
 			case PRI_EVENT_PROCEEDING:
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
-					if (pri->overlapdial && !pri->pvts[chanpos]->proceeding) {
+					chanpos = pri_fixup_principle(pri, chanpos, e->proceeding.call);
+					if (chanpos < 0) {
+						ast_log(LOG_WARNING, "Received PROCEEDING on channel %d/%d not in use on span %d\n", 
+							PRI_SPAN(e->proceeding.channel), PRI_CHANNEL(e->proceeding.channel), pri->span);
+						chanpos = -1;
+					} else {
+//				    pri->pvts[chanpos]->ignoredtmf = 0;
+					    if (pri->overlapdial && !pri->pvts[chanpos]->proceeding) {
 						struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_PROGRESS, };
 						
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
@@ -7802,6 +8386,7 @@
 						zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						pri->pvts[chanpos]->proceeding=2;
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    }
 					}
 				}
 				break;
@@ -7827,7 +8412,296 @@
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
 				}
-				break;				
+				break;
+			case PRI_EVENT_SUSPEND_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->suspend_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Suspend requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (pri->pvts[chanpos]->owner) {
+					if (pri->pvts[chanpos]->owner->bridge) {
+					    struct zt_suspended_call *zpc;
+					    char tmpstr[256];
+					    zpc = malloc(sizeof(struct zt_suspended_call));
+					    if (!zpc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_suspended_call\n");
+						break;
+					    }
+					    strncpy(zpc->msn,  pri->pvts[chanpos]->callerid, sizeof(zpc->msn));
+					    strncpy(zpc->callid,  e->suspend_req.callid, sizeof(zpc->callid));
+					    ast_masq_park_call(pri->pvts[chanpos]->owner->bridge, NULL, 0, &zpc->parked_at);
+					    zpc->next = pri->suspended_calls;
+					    pri->suspended_calls = zpc;
+					    snprintf(tmpstr, sizeof(tmpstr), "Parked at %d", zpc->parked_at);
+					    pri_suspend_acknowledge(pri->pri, e->suspend_req.call,tmpstr);
+					    pri->pvts[chanpos]->call = NULL;
+					    pri->pvts[chanpos]->tei = -1;
+					    pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					} else {
+					    pri_suspend_reject(pri->pri, e->suspend_req.call, "cant park a non-bridge");
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    break;
+					}
+				    } else {
+					pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_RESUME_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_resume_reject(pri->pri, e->resume_req.call,"All channels busy");
+					ast_log(LOG_WARNING, "Resume requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				} else if (!pri->pvts[chanpos]) {
+					pri_resume_reject(pri->pri, e->resume_req.call,"General protection fault in module 0x0BRI");
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+    				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (!pri->pvts[chanpos]->owner) {
+					struct zt_suspended_call *zpc, *zpcl;
+					int unparked=0;
+					char extenstr[255], temp[255];
+					zpc = NULL;
+					zpcl = pri->suspended_calls;
+					while (zpcl) {
+					//    ast_log(LOG_NOTICE, "zpc->parked_at %d zpcl->callid %s\n",zpcl->parked_at, zpcl->callid);
+					    if (((strlen(zpcl->callid) == 0) && (strlen(e->resume_req.callid)==0)) || (!strcmp(zpcl->callid,e->resume_req.callid))) {
+						int law;
+						// found a parked call
+						snprintf(extenstr, sizeof(extenstr), "%d", zpcl->parked_at);
+						strncpy(pri->pvts[chanpos]->exten, extenstr, sizeof(pri->pvts[chanpos]->exten));
+					//	strncpy(pri->pvts[chanpos]->context, ast_parking_con(), sizeof(pri->pvts[chanpos]->context));
+					        pri->pvts[chanpos]->call = e->resume_req.call;
+    					        law = 1;
+					        if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    	    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+						law = ZT_LAW_ALAW;
+						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+						if (res < 0) 
+						    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						if (!pri->pvts[chanpos]->digital) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						} else {
+ 						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						}
+						if (res < 0)
+						    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						/* Start PBX */
+						c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 1, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+						if (c) {
+						    pri->pvts[chanpos]->owner = c;
+						    pri->pvts[chanpos]->call = e->resume_req.call;
+						    zt_enable_ec(pri->pvts[chanpos]);
+						    zt_train_ec(pri->pvts[chanpos]);
+						} else {
+						    ast_log(LOG_ERROR, "unable to start pbx\n");
+						}
+
+						if (zpc) {
+						    zpc->next = zpcl->next;
+						    free(zpcl);
+						    zpcl = zpc->next;
+						} else {
+						    // remove head
+						    pri->suspended_calls = zpcl->next;
+						    free(zpcl);
+						    zpcl = pri->suspended_calls;
+						    zpc = NULL;
+						}
+						unparked = 1;
+						snprintf(temp, sizeof(temp), "Unparked %s", extenstr);
+						pri_resume_acknowledge(pri->pri, e->resume_req.call, chanpos + 1, temp);
+					        break;
+					    }
+					    zpc = zpcl;
+					    if (zpcl) zpcl = zpcl->next;
+					}
+					if (!unparked)
+					    pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    } else {
+					pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_HOLD_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_hold_reject(pri->pri, e->hold_req.call);
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->hold_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Hold requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+				if (chanpos > -1) {
+				//    ast_log(LOG_NOTICE, "Hold request for channel number %d span %d\n", chanpos, pri->span);
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (pri->pvts[chanpos]->owner) {
+					struct zt_pvt *p = pri->pvts[chanpos];
+					struct zt_holded_call *zhc;
+					int holdacked=0;
+					
+//					ast_log(LOG_NOTICE,"HOLD request from channel %s tei %d\n",p->owner->name, e->hold_req.tei);
+				    	if (p->owner->bridge) {
+					    zhc = malloc(sizeof(struct zt_holded_call));
+					    if (!zhc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_holded_call\n");
+						break;
+					    }
+					    memset(zhc, 0, sizeof(zhc));
+					    strncpy(zhc->msn,  pri->pvts[chanpos]->callerid, sizeof(zhc->msn));
+					    strncpy(zhc->uniqueid,  p->owner->bridge->uniqueid, sizeof(zhc->uniqueid));
+					    zhc->tei = e->hold_req.tei;
+					    zhc->cref = e->hold_req.cref;
+					    zhc->call = e->hold_req.call;
+					    zhc->channel = p->owner;
+					    zhc->alreadyhungup = 0;
+					    zhc->bridge = p->owner->bridge;
+					    zhc->next = pri->holded_calls;
+					    pri->holded_calls = zhc;
+
+					    /* put channel on hold */
+					    ast_masq_hold_call(p->owner->bridge, p->owner);
+
+					    pri_hold_acknowledge(pri->pri, e->hold_req.call);
+					    holdacked = 1;
+					    p->call = NULL; // free the bchannel withouth destroying the call
+					    p->tei = -1;
+					} else {
+					    // cant hold a non-bridge,...yet
+					    
+					    // make a fake channel
+					    
+					    // masquerade
+					    
+					    // put on hold
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+					}
+				    } else {
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				} else {
+					pri_hold_reject(pri->pri, e->hold_req.call);
+				}
+				break; 
+			case PRI_EVENT_RETRIEVE_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					ast_log(LOG_WARNING, "Retrieve requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+					break;
+				} else if (!pri->pvts[chanpos]) {
+					ast_log(LOG_WARNING, "Retrieve requested on unconfigured channel number %d span %d\n", chanpos, pri->span);
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					chanpos = -1;
+					break;
+				}
+				if (chanpos > -1) {
+				    struct zt_holded_call *onhold = NULL;
+				    int retrieved = 0;
+				    int res = -1;
+				    struct app_tmp *tmp;
+				    pthread_attr_t attr;
+				    int law;
+
+				    onhold = pri_get_callonhold(pri, e->retrieve_req.cref, e->retrieve_req.tei);
+
+				    if (!onhold) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					break;
+				    }
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					// found a parked call
+    					law = 1;
+					if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+					law = ZT_LAW_ALAW;
+					res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+					if (res < 0) 
+					    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+					if (res < 0)
+					    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					/* Start PBX */
+					c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 0, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+					if (c) {
+					    pri->pvts[chanpos]->owner = c;
+					    pri->pvts[chanpos]->outgoing = 1; /* for not sending proceedings... */
+					    pri->pvts[chanpos]->call = e->retrieve_req.call;
+					    pri->pvts[chanpos]->tei = e->retrieve_req.tei;
+				    	    zt_enable_ec(pri->pvts[chanpos]);
+				    	    zt_train_ec(pri->pvts[chanpos]);
+					} else {
+					    ast_log(LOG_ERROR, "unable to start pbx\n");
+					}
+
+					retrieved = 1;
+				//	ast_log(LOG_NOTICE, "sending RETRIEVE ACK on channel %d, span %d for tei %d cref %d\n",chanpos,pri->span, e->retrieve_req.tei,  e->retrieve_req.cref);
+					pri_retrieve_acknowledge(pri->pri, e->retrieve_req.call, chanpos + 1);
+
+					// the magic begins here: ....
+					tmp = malloc(sizeof(struct app_tmp));
+					if (tmp) {
+					    memset(tmp, 0, sizeof(struct app_tmp));
+					    strncpy(tmp->app, "holdedcall", sizeof(tmp->app) - 1);
+					    strncpy(tmp->data, onhold->uniqueid, sizeof(tmp->data) - 1);
+					    tmp->chan = c;
+					}
+					pri_destroy_callonhold(pri, onhold);
+					onhold = NULL;
+
+					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					pthread_attr_init(&attr);
+					pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+					if (ast_pthread_create(&tmp->t, &attr, ast_pbx_run_app, tmp)) {
+					    ast_log(LOG_WARNING, "Unable to spawn execute thread on %s: %s\n", c->name, strerror(errno));
+					    free(tmp);
+					    ast_hangup(c);
+					    retrieved = 0;
+					}
+
+				    if (!retrieved) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    }
+				}
+				break; 
+			case PRI_EVENT_DISPLAY_RECEIVED:
+				ast_log(LOG_NOTICE, "DISPLAY IE: [ %s ] received\n",e->display.text);
+				chanpos = pri_find_principle(pri, e->display.channel);
+				if (chanpos < 0) {
+				    ast_log(LOG_WARNING, "odd channel number %d span %d\n", chanpos, pri->span);
+				    chanpos = -1;
+				} 
+				if (chanpos > -1) {
+				    if (pri->pvts[chanpos]->owner) {
+			//		ast_sendtext(pri->pvt[chanpos]->owner, e->display.text);
+				    }
+				}				
+				break;
 			case PRI_EVENT_ANSWER:
 				chanpos = pri_find_principle(pri, e->answer.channel);
 				if (chanpos < 0) {
@@ -7843,6 +8717,8 @@
 						chanpos = -1;
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
+						pri->pvts[chanpos]->tei = e->answer.tei;
+					//	ast_log(LOG_NOTICE, "TEI %d answered\n", e->answer.tei);
 						if (pri->pvts[chanpos]->master && (pri->pvts[chanpos]->master->sig == SIG_FXSKS)) {
 							ast_log(LOG_DEBUG, "Starting up GR-303 trunk now that we got CONNECT...\n");
 							x = ZT_START;
@@ -7865,9 +8741,13 @@
 						} else if (pri->pvts[chanpos]->confirmanswer) {
 							ast_log(LOG_DEBUG, "Waiting on answer confirmation on channel %d!\n", pri->pvts[chanpos]->channel);
 						} else {
+							pri->pvts[chanpos]->dialing = 0;
 							pri->pvts[chanpos]->subs[SUB_REAL].needanswer =1;
 							/* Enable echo cancellation if it's not on already */
 							zt_enable_ec(pri->pvts[chanpos]);
+							zt_train_ec(pri->pvts[chanpos]);
+							// stop ignoring inband dtmf
+							pri->pvts[chanpos]->ignoredtmf = 0;
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
@@ -7890,6 +8770,9 @@
 							if (pri->pvts[chanpos]->master) 
 								pri_hangup_all(pri->pvts[chanpos]->master, pri);
 							else if (pri->pvts[chanpos]->owner) {
+							//	char tmpstr[256];
+							//	snprintf(tmpstr, sizeof(tmpstr), "%d", e->hangup.cause);
+							//	pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "PRI_CAUSE", tmpstr);
 								/* Queue a BUSY instead of a hangup if our cause is appropriate */
 								pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
 								switch(e->hangup.cause) {
@@ -7914,18 +8797,33 @@
 						} else {
 							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
 							pri->pvts[chanpos]->call = NULL;
+							pri->pvts[chanpos]->tei = -1;
 						}
 						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
+							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+							    if (option_verbose > 2)
 								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d on span %d since channel reported in use\n", 
 									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
+							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+							    pri->pvts[chanpos]->resetting = 1;
+							}
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
+						struct zt_holded_call *onhold = NULL;
+						/* check calls on hold */
+						onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+						
+						if (onhold) {
+						    // ast_log(LOG_NOTICE, "hangup, found cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+						    pri_hangup(pri->pri, onhold->call, e->hangup.cause);
+						    pri_destroy_callonhold(pri, onhold);
+						    onhold = NULL;
+						} else {
+						    ast_log(LOG_NOTICE, "hangup, did not find cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+						    ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
 							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+						}
 					}
 				} 
 				break;
@@ -7935,17 +8833,25 @@
 			case PRI_EVENT_HANGUP_REQ:
 				chanpos = pri_find_principle(pri, e->hangup.channel);
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
+					if (pri->nodetype == BRI_NETWORK_PTMP) {
+					    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause);
+					} else {
+					    ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
 						PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+					}
 					chanpos = -1;
 				}
-				if (chanpos > -1) {
+				/* dont hangup if we want to hear inband progress */
+				if ((chanpos > -1) && ((pri->pvts[chanpos]->priindication_oob !=2) | (!e->hangup.inband_progress) | (!pri->pvts[chanpos]->outgoing))) {
 					chanpos = pri_fixup_principle(pri, chanpos, e->hangup.call);
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (pri->pvts[chanpos]->master) 
 							pri_hangup_all(pri->pvts[chanpos]->master, pri);
 						else if (pri->pvts[chanpos]->owner) {
+							char tmpstr[256];
+							snprintf(tmpstr, sizeof(tmpstr), "%d", e->hangup.cause);
+							pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "PRI_CAUSE", tmpstr);
 							pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
 							switch(e->hangup.cause) {
 							case PRI_CAUSE_USER_BUSY:
@@ -7964,20 +8870,81 @@
 							}
 							if (option_verbose > 2) 
 								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d got hangup\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+							if (pri->nodetype == BRI_NETWORK_PTMP) {
+							    // check for bri transfers, not everybody uses ECT...
+							    if (pri->pvts[chanpos]->owner) {
+								// find on hold call
+								struct zt_holded_call *onhold = NULL;
+								struct ast_channel *transferee = NULL;
+
+								onhold = pri_get_callonhold(pri, -1, e->hangup.tei);
+
+								if (onhold) {
+									
+								    if (((pri->pvts[chanpos]->owner->_state != AST_STATE_RING) && (pri->pvts[chanpos]->owner->_state != AST_STATE_RESERVED)) || ((!ast_strlen_zero(pri->pvts[chanpos]->exten)) && (strncasecmp(pri->pvts[chanpos]->exten, "s", sizeof(pri->pvts[chanpos]->exten))))) {
+								        transferee = ast_get_holded_call(onhold->uniqueid);
+
+									if (transferee) {
+									    if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+									    	ast_indicate(transferee, AST_CONTROL_RINGING);
+									    }
+
+									    pri->pvts[chanpos]->owner->_softhangup &= ~AST_SOFTHANGUP_DEV;
+    
+    									    ast_mutex_unlock(&transferee->lock);
+									    if (ast_channel_masquerade(pri->pvts[chanpos]->owner, transferee)) {
+										ast_log(LOG_WARNING, "unable to masquerade\n");
+									    } else { 
+										/* beware of zombies!!! */
+										transferee->zombie = 1;
+										pri->pvts[chanpos]->owner = NULL;
+										pri->pvts[chanpos]->tei = -1;
+									    }
+									}
+								    } else { 
+									ast_retrieve_call_to_death(onhold->uniqueid);
+								    }
+								    onhold->alreadyhungup = 1;	
+								    pri_hangup(pri->pri, onhold->call, e->hangup.cause);
+								    onhold = NULL;
+								    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+								    break;
+								}
+							    }
+							}
 						} else {
 							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
 							pri->pvts[chanpos]->call = NULL;
+							pri->pvts[chanpos]->tei = -1;
 						}
 						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
+							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+							    if (option_verbose > 2)
 								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d span %d since channel reported in use\n", 
 									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
+							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+							    pri->pvts[chanpos]->resetting = 1;
+							}
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+						if (pri->nodetype != BRI_NETWORK_PTMP) {
+						    ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+						} else {
+						    // check holded_calls!!!
+						    struct zt_holded_call *onhold = NULL;
+
+						    onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+
+						    if (onhold) {
+							    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause);
+							    ast_retrieve_call_to_death(onhold->uniqueid);
+							    pri_destroy_callonhold(pri, onhold);
+							    onhold = NULL;
+						    } else {
+							ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+						    }
+						}
 					}
 				} 
 				break;
@@ -7992,6 +8959,7 @@
 					chanpos = pri_fixup_principle(pri, chanpos, e->hangup.call);
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
+						pri->pvts[chanpos]->tei = -1;
 						pri->pvts[chanpos]->call = NULL;
 						pri->pvts[chanpos]->resetting = 0;
 						if (pri->pvts[chanpos]->owner) {
@@ -8066,17 +9034,98 @@
 					ast_log(LOG_WARNING, "Received SETUP_ACKNOWLEDGE on unconfigured channel %d/%d span %d\n", 
 						PRI_SPAN(e->setup_ack.channel), PRI_CHANNEL(e->setup_ack.channel), pri->span);
 				} else {
-					ast_mutex_lock(&pri->pvts[chanpos]->lock);
-					pri->pvts[chanpos]->setup_ack = 1;
-					/* Send any queued digits */
-					for (x=0;x<strlen(pri->pvts[chanpos]->dialdest);x++) {
+					chanpos = pri_fixup_principle(pri, chanpos, e->setup_ack.call);
+					if (chanpos < 0) {
+						ast_log(LOG_WARNING, "Received SETUP_ACK on channel %d/%d not in use on span %d\n", 
+							PRI_SPAN(e->setup_ack.channel), PRI_CHANNEL(e->setup_ack.channel), pri->span);
+						chanpos = -1;
+					} else {
+					    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					    pri->pvts[chanpos]->setup_ack = 1;
+					    if (pri->pvts[chanpos]->owner) {
+					    //    ast_log(LOG_NOTICE, "SETUP_ACK for '%s'\n", pri->pvts[chanpos]->owner->name);
+					    }
+					    /* Send any queued digits */
+					    for (x=0;x<strlen(pri->pvts[chanpos]->dialdest);x++) {
 						ast_log(LOG_DEBUG, "Sending pending digit '%c'\n", pri->pvts[chanpos]->dialdest[x]);
 						pri_information(pri->pri, pri->pvts[chanpos]->call, 
 							pri->pvts[chanpos]->dialdest[x]);
+					    }
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
-					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 				}
 				break;
+			case PRI_EVENT_FACILITY:
+				    if (e->facility.operation == 0x06) {
+					struct ast_channel *chan = NULL;
+					struct zt_holded_call *onhold = NULL;
+					if (option_verbose > 2) {
+					    ast_verbose(VERBOSE_PREFIX_3 "ECT requested by TEI %d for cref %d\n", e->facility.tei, e->facility.cref);
+					}
+					/* search for cref/tei in held calls */
+					onhold = pri_get_callonhold(pri, e->facility.cref, e->facility.tei);
+					if (onhold) {
+					    chan = ast_get_holded_call(onhold->uniqueid);
+					    onhold->alreadyhungup = 1;
+					    onhold = NULL;
+					    if (!chan) {
+						/* hang up */
+					        pri_hangup(pri->pri, e->facility.call, 16);
+						break;
+					    }
+					} else {
+					    /* unknown cref/tei */
+					    ast_log(LOG_WARNING, "did not find call on hold for cref %d tei %d\n", e->facility.tei, e->facility.cref);
+					    /* hang up */
+					    pri_hangup(pri->pri, e->facility.call, 16);
+					    break;
+					}
+
+					/* find an active call for the same tei */
+					chanpos = pri_find_tei(pri, e->facility.call, e->facility.tei);
+					if (chanpos < 0) {
+					    /* did not find active call, hangup call on hold */
+					    if (chan) {
+						ast_hangup(chan);
+						chan = NULL;
+					    }
+					} else {
+					    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					    /* transfer */
+					    if (pri->pvts[chanpos]->owner) {
+						if (option_verbose > 3) {
+						    ast_verbose(VERBOSE_PREFIX_3 "ECT: found %s on channel %d for tei %d\n", pri->pvts[chanpos]->owner->name ,chanpos, e->facility.tei);
+						}
+						/* pass callprogress if the channel is not up yet */
+						if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+						    ast_indicate(chan, AST_CONTROL_RINGING);
+						}
+						/* unlock the channel we removed from hold */
+						ast_mutex_unlock(&chan->lock);
+						if (ast_channel_masquerade(pri->pvts[chanpos]->owner, chan)) {
+					    	    ast_log(LOG_WARNING, "unable to masquerade\n");
+						} else {
+						    /* beware of zombies !!! */
+						    chan->zombie = 1;
+						}
+					    }
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					}
+					/* disconnect */
+					pri_hangup(pri->pri, e->facility.call, 16);
+				    } else if (e->facility.operation == 0x0D) {
+					ast_log(LOG_NOTICE, "call deflection to %s requested.\n", e->facility.forwardnum);
+					/* mmmmmkay */
+					
+					/* lock the channel */
+					
+					/* async goto */
+					
+					/* disconnect isdn layer */
+				    } else {
+					ast_log(LOG_WARNING, "Unknown facility operation %#x requested.\n", e->facility.operation);
+				    }
+				break;
 			default:
 				ast_log(LOG_DEBUG, "Event: %d\n", e->e);
 			}
@@ -8225,6 +9274,7 @@
 
 
 
+
 static int handle_pri_no_debug(int fd, int argc, char *argv[])
 {
 	int span;
@@ -8345,6 +9395,18 @@
 	"Usage: pri show span <span>\n"
 	"       Displays PRI Information\n";
 
+static char bri_debug_help[] = 
+	"Usage: bri debug span <span>\n"
+	"       Enables debugging on a given BRI span\n";
+	
+static char bri_no_debug_help[] = 
+	"Usage: bri no debug span <span>\n"
+	"       Disables debugging on a given BRI span\n";
+
+static char bri_really_debug_help[] = 
+	"Usage: bri intensive debug span <span>\n"
+	"       Enables debugging down to the Q.921 level\n";
+
 static struct ast_cli_entry pri_debug = {
 	{ "pri", "debug", "span", NULL }, handle_pri_debug, "Enables PRI debugging on a span", pri_debug_help, complete_span_4 };
 
@@ -8357,8 +9419,53 @@
 static struct ast_cli_entry pri_show_span = {
 	{ "pri", "show", "span", NULL }, handle_pri_show_span, "Displays PRI Information", pri_show_span_help, complete_span_4 };
 
+static struct ast_cli_entry bri_debug = {
+	{ "bri", "debug", "span", NULL }, handle_pri_debug, "Enables BRI debugging on a span", bri_debug_help, complete_span_4 };
+
+static struct ast_cli_entry bri_no_debug = {
+	{ "bri", "no", "debug", "span", NULL }, handle_pri_no_debug, "Disables BRI debugging on a span", bri_no_debug_help, complete_span_5 };
+
+static struct ast_cli_entry bri_really_debug = {
+	{ "bri", "intense", "debug", "span", NULL }, handle_pri_really_debug, "Enables REALLY INTENSE BRI debugging", bri_really_debug_help, complete_span_5 };
+
 #endif /* ZAPATA_PRI */
 
+static int app_zapEC(struct ast_channel *chan, void *data)
+{
+    int res=-1;
+    struct zt_pvt *p = NULL;
+
+    if (!data) {
+	ast_log(LOG_WARNING, "zapEC requires one argument (on | off)\n");
+    }
+    if (chan && !strcasecmp("ZAP",chan->type)) {
+	p = chan->pvt->pvt;
+	if (!p) return res;
+	if (!strcasecmp("on",(char *)data)) {
+	    zt_enable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Enabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else if (!strcasecmp("off",(char *)data)) {
+	    zt_disable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Disabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else {
+    	    ast_log(LOG_WARNING, "Unknown argument %s to zapEC\n", (char *)data);
+	}
+    } else {
+        ast_log(LOG_WARNING, "zapNoEC only works on ZAP channels, check your extensions.conf!\n");
+    }
+
+    return res;
+}
+
+static char *zapEC_tdesc = "Enable/disable Echo cancelation";
+static char *zapEC_app = "zapEC";
+static char *zapEC_synopsis = "Enable/Disable Echo Cancelation on a Zap channel";
 
 #ifdef ZAPATA_R2
 static int handle_r2_no_debug(int fd, int argc, char *argv[])
@@ -8920,6 +10027,10 @@
 	ast_cli_unregister(&pri_no_debug);
 	ast_cli_unregister(&pri_really_debug);
 	ast_cli_unregister(&pri_show_span);
+
+	ast_cli_unregister(&bri_debug);
+	ast_cli_unregister(&bri_no_debug);
+	ast_cli_unregister(&bri_really_debug);
 #endif
 #ifdef ZAPATA_R2
 	ast_cli_unregister(&r2_debug);
@@ -8936,6 +10047,7 @@
 	ast_manager_unregister( "ZapDNDon" );
 	ast_manager_unregister("ZapShowChannels");
 	ast_unregister_application(app_callingpres);
+	ast_unregister_application(zapEC_app);
 	ast_channel_unregister(typecompat);
 	ast_channel_unregister(type);
 	if (!ast_mutex_lock(&iflock)) {
@@ -9283,7 +10395,7 @@
 			}
 		} else if (!strcasecmp(v->name, "echotraining")) {
 			if (sscanf(v->value, "%i", &y) == 1) {
-				if ((y < 10) || (y > 4000)) {
+				if ((y < 10) || (y > 2000)) {
 					ast_log(LOG_WARNING, "Echo training time must be within the range of 10 to 2000 ms at line %d\n", v->lineno);					
 				} else {
 					echotraining = y;
@@ -9462,6 +10574,22 @@
 				cur_signalling = SIG_GR303FXSKS;
 				cur_radio = 0;
 				pritype = PRI_CPE;
+			} else if (!strcasecmp(v->value, "bri_net_ptmp")) {
+				cur_radio = 0;
+				cur_signalling = SIG_PRI;
+				pritype = BRI_NETWORK_PTMP;
+			} else if (!strcasecmp(v->value, "bri_cpe_ptmp")) {
+				cur_signalling = SIG_PRI;
+				cur_radio = 0;
+				pritype = BRI_CPE_PTMP;
+			} else if (!strcasecmp(v->value, "bri_net")) {
+				cur_radio = 0;
+				cur_signalling = SIG_PRI;
+				pritype = BRI_NETWORK;
+			} else if (!strcasecmp(v->value, "bri_cpe")) {
+				cur_signalling = SIG_PRI;
+				cur_radio = 0;
+				pritype = BRI_CPE;
 #endif
 #ifdef ZAPATA_R2
 			} else if (!strcasecmp(v->value, "r2")) {
@@ -9490,6 +10618,8 @@
 				dialplan = PRI_INTERNATIONAL_ISDN + 1;
 			} else if (!strcasecmp(v->value, "local")) {
 				dialplan = PRI_LOCAL_ISDN + 1;
+			} else if (!strcasecmp(v->value, "dynamic")) {
+				dialplan = 0;
 			} else {
 				ast_log(LOG_WARNING, "Unknown PRI dialplan '%s' at line %d.\n", v->value, v->lineno);
 			}
@@ -9505,8 +10635,16 @@
 			} else if (!strcasecmp(v->value, "local")) {
 				localdialplan = PRI_LOCAL_ISDN + 1;
 			} else {
-				ast_log(LOG_WARNING, "Unknown PRI dialplan '%s' at line %d.\n", v->value, v->lineno);
+				ast_log(LOG_WARNING, "Unknown PRI local dialplan '%s' at line %d.\n", v->value, v->lineno);
 			}
+		} else if (!strcasecmp(v->name, "nocid")) {
+			strncpy(nocid, v->value, sizeof(nocid) - 1);
+		} else if (!strcasecmp(v->name, "withheldcid")) {
+			strncpy(withheldcid, v->value, sizeof(withheldcid) - 1);
+		} else if (!strcasecmp(v->name, "nationalprefix")) {
+			strncpy(nationalprefix, v->value, sizeof(nationalprefix) - 1);
+    		} else if (!strcasecmp(v->name, "internationalprefix")) {
+			strncpy(internationalprefix, v->value, sizeof(internationalprefix) - 1);
 		} else if (!strcasecmp(v->name, "switchtype")) {
 			if (!strcasecmp(v->value, "national")) 
 				switchtype = PRI_SWITCH_NI2;
@@ -9544,15 +10682,18 @@
 				priindication_oob = 1;
 			else if (!strcasecmp(v->value, "inband"))
 				priindication_oob = 0;
+			else if (!strcasecmp(v->value, "passthrough"))
+				priindication_oob = 2;
 			else
-				ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband' or 'outofband' at line %d\n",
-					v->value, v->lineno);
+			    ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband' , 'outofband' or 'passthrough' at line %d\n",v->value, v->lineno);
 		} else if (!strcasecmp(v->name, "minunused")) {
 			minunused = atoi(v->value);
 		} else if (!strcasecmp(v->name, "idleext")) {
 			strncpy(idleext, v->value, sizeof(idleext) - 1);
 		} else if (!strcasecmp(v->name, "idledial")) {
 			strncpy(idledial, v->value, sizeof(idledial) - 1);
+		} else if (!strcasecmp(v->name, "pritrustusercid")) {
+			usercid = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "overlapdial")) {
 			overlapdial = ast_true(v->value);
 #endif		
@@ -9708,12 +10849,12 @@
 	if(res) {
 	  return -1;
 	}
-	if (ast_channel_register(type, tdesc, AST_FORMAT_SLINEAR |  AST_FORMAT_ULAW, zt_request)) {
+	if (ast_channel_register_ex(type, tdesc, AST_FORMAT_SLINEAR |  AST_FORMAT_ULAW | AST_FORMAT_ALAW, zt_request, zt_devicestate)) {
 		ast_log(LOG_ERROR, "Unable to register channel class %s\n", type);
 		__unload_module();
 		return -1;
 	}
-	if (ast_channel_register(typecompat, tdesc, AST_FORMAT_SLINEAR |  AST_FORMAT_ULAW, zt_request)) {
+	if (ast_channel_register_ex(typecompat, tdesc, AST_FORMAT_SLINEAR |  AST_FORMAT_ULAW | AST_FORMAT_ALAW, zt_request, zt_devicestate)) {
 		ast_log(LOG_ERROR, "Unable to register channel class %s\n", typecompat);
 		__unload_module();
 		return -1;
@@ -9723,6 +10864,10 @@
 	ast_cli_register(&pri_no_debug);
 	ast_cli_register(&pri_really_debug);
 	ast_cli_register(&pri_show_span);
+
+	ast_cli_register(&bri_debug);
+	ast_cli_register(&bri_no_debug);
+	ast_cli_register(&bri_really_debug);
 #endif	
 #ifdef ZAPATA_R2
 	ast_cli_register(&r2_debug);
@@ -9734,6 +10879,7 @@
 	ast_cli_register(&zap_show_cadences_cli);
 
 	ast_register_application(app_callingpres, change_callingpres, synopsis_callingpres, descrip_callingpres);
+	ast_register_application(zapEC_app, app_zapEC, zapEC_synopsis, zapEC_tdesc);
 	memset(round_robin, 0, sizeof(round_robin));
 	ast_manager_register( "ZapTransfer", 0, action_transfer, "Transfer Zap Channel" );
 	ast_manager_register( "ZapHangup", 0, action_transferhangup, "Hangup Zap Channel" );
@@ -10007,6 +11153,22 @@
 			} else if (!strcasecmp(v->value, "pri_cpe")) {
 				cur_signalling = SIG_PRI;
 				pritype = PRI_CPE;
+			} else if (!strcasecmp(v->value, "bri_net_ptmp")) {
+				cur_radio = 0;
+				cur_signalling = SIG_PRI;
+				pritype = BRI_NETWORK_PTMP;
+			} else if (!strcasecmp(v->value, "bri_cpe_ptmp")) {
+				cur_signalling = SIG_PRI;
+				cur_radio = 0;
+				pritype = BRI_CPE_PTMP;
+			} else if (!strcasecmp(v->value, "bri_net")) {
+				cur_radio = 0;
+				cur_signalling = SIG_PRI;
+				pritype = BRI_NETWORK;
+			} else if (!strcasecmp(v->value, "bri_cpe")) {
+				cur_signalling = SIG_PRI;
+				cur_radio = 0;
+				pritype = BRI_CPE;
 #endif
 			} else {
 				ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
@@ -10081,6 +11243,26 @@
 }
 #endif
 
+#ifdef ZAPATA_PRI
+static int zt_prisendtext(struct ast_channel *c, char *text)
+{
+    struct zt_pvt *p = (struct zt_pvt *)c->pvt->pvt;
+    ast_log(LOG_NOTICE, "text\n");
+    if (!p) return -1;
+    if (!p->pri) return -1;
+	    if (strlen(text)) {
+		if (p->pri) {		
+		    if (!pri_grab(p, p->pri)) {
+		//	ast_log(LOG_NOTICE, "Sending Display IE  '%s'\n", text);
+			pri_information_display(p->pri->pri,p->call,text);
+			pri_rel(p->pri);
+	    	    } else ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
+		}
+	    }
+    return 0;
+}
+#endif
+
 static int zt_sendtext(struct ast_channel *c, char *text)
 {
 #define	END_SILENCE_LEN 400
diff -urNad --exclude=CVS --exclude=.svn ./codecs/codec_ilbc.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/codecs/codec_ilbc.c
--- ./codecs/codec_ilbc.c	2004-06-22 19:49:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/codecs/codec_ilbc.c	2005-07-14 07:00:10.546057824 +0100
@@ -32,7 +32,7 @@
 #include "slin_ilbc_ex.h"
 #include "ilbc_slin_ex.h"
 
-#define USE_ILBC_ENHANCER	0
+#define USE_ILBC_ENHANCER	1
 
 AST_MUTEX_DEFINE_STATIC(localuser_lock);
 static int localusecnt=0;
diff -urNad --exclude=CVS --exclude=.svn ./cwain/cwain.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/cwain.c
--- ./cwain/cwain.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/cwain.c	2005-07-14 07:01:26.948442896 +0100
@@ -0,0 +1,1326 @@
+/*
+ * cwain.c - Zaptel driver for the Junghanns.NET E1 card
+ *
+ * c.w.a.i.n. == card without an interesting name
+ *
+ * single/double E1 board
+ *
+ * Copyright (C) 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <zaptel.h>
+#include "cwain.h"
+
+#if CONFIG_PCI
+
+static int ports=-1; /* autodetect */
+static int debug=0;
+static struct zt_cwain *cwain_span_list = NULL;
+static int cwain_span_count = 0;
+static struct zt_cwain_card *cwain_card_list = NULL;
+static int cwain_card_count = 0;
+static struct pci_dev *multi_cwain = NULL;
+static spinlock_t cwain_span_registerlock = SPIN_LOCK_UNLOCKED;
+static spinlock_t cwain_card_registerlock = SPIN_LOCK_UNLOCKED;
+
+static int ztcwain_shutdown(struct zt_span *span);
+
+int cwain_waitbusy(struct zt_cwain *cwaintmp) {
+    int x=1000;
+    while (x-- && (cwain_inb(cwaintmp,cwain_R_STATUS) & 1));
+    if (x < 0) {
+	return -1;
+    } else {
+	return 0;
+    }
+}
+
+void cwain_unregister_zap_span(struct zt_cwain *cwainspan) {
+    if (!cwainspan) {
+	printk(KERN_INFO "cwain: shutting down NULL span!\n");
+	return;
+    }
+    if(cwainspan->span.flags & ZT_FLAG_RUNNING) {
+        ztcwain_shutdown(&cwainspan->span);
+        if (debug)
+            printk(KERN_INFO "cwain: shutdown span %d.\n",cwainspan->cardno);
+    }
+    if(cwainspan->span.flags & ZT_FLAG_REGISTERED) {
+        zt_unregister(&cwainspan->span);
+        if (debug)
+    	printk(KERN_INFO "cwain: unregistered span %d.\n",cwainspan->cardno);
+    }
+}
+
+void cwain_shutdown_span(struct zt_cwain *cwainspan) {
+    
+    if (!cwainspan) {
+	printk(KERN_INFO "cwain: shutting down NULL span!\n");
+	return;
+    }
+
+    if (cwainspan->pci_io == NULL) {
+	return;
+    }
+
+    if (debug)
+	printk(KERN_INFO "cwain: shutting down span %d (cardID %d) at %p.\n",cwainspan->cardno,cwainspan->cardID,cwainspan->pci_io);
+
+    // turn off irqs
+    cwain_outb(cwainspan,cwain_R_IRQ_CTRL, 0); 
+    cwain_outb(cwainspan,cwain_R_IRQMSK_MISC, 0); 
+
+    // softreset
+    cwain_outb(cwainspan,cwain_R_CIRM,0x8);
+    cwain_outb(cwainspan,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwainspan);
+
+    cwain_outb(cwainspan,cwain_R_IRQMSK_MISC, 0); 
+    cwain_outb(cwainspan,cwain_R_IRQ_CTRL, 0); 
+
+    iounmap((void *) cwainspan->pci_io);
+    cwainspan->pci_io = NULL;
+
+    if (cwainspan->pcidev != NULL) {
+        pci_disable_device(cwainspan->pcidev);
+    }
+    pci_write_config_word(cwainspan->pcidev, PCI_COMMAND, 0);	// disable memio
+}
+
+void cwain_shutdown_card(struct zt_cwain_card *cwaintmp) {
+    unsigned long flags = 0;
+    int i = 0;
+    
+    if (!cwaintmp) {
+	printk(KERN_INFO "cwain: shutting down NULL card!\n");
+	return;
+    }
+
+    cwaintmp->dead = 1;
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	cwain_unregister_zap_span(cwaintmp->span[i]);
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+
+    // turn off irqs
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQ_CTRL, 0); 
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQMSK_MISC, 0); 
+
+    free_irq(cwaintmp->irq,cwaintmp);
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	cwain_shutdown_span(cwaintmp->span[i]);
+    }
+
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+}
+
+void cwain_doLEDs(struct zt_cwain *cwaintmp) {
+    /*
+     O1 O3 (red)
+     O2 O4 (green)
+    */
+    if (!(cwaintmp->span.flags & ZT_FLAG_RUNNING)) {
+	return;
+    }
+    if ((cwaintmp->type == 0xb553) || (cwaintmp->type == 0xb554)) {
+	/* sync status */
+	if (((cwaintmp->sync_sta & 0x07) == 0x07) && cwaintmp->sync) {
+	    cwaintmp->leds[0] = 1;    
+	    cwaintmp->leds[1] = 0;    
+	} else {
+	    cwaintmp->leds[0] = 0;    
+	    cwaintmp->leds[1] = 1;    
+	}
+	/* multiframe alignment */
+	if ((cwaintmp->sync_sta & 0x20) == 0x20) {
+    	    cwaintmp->leds[2] = 1;    
+	    cwaintmp->leds[3] = 0;    
+	} else {
+	    if ((cwaintmp->span.lineconfig & ZT_CONFIG_CRC4) && cwaintmp->sync) {
+		/* CRC4 requested */
+		cwaintmp->leds[2] = 0;    
+		cwaintmp->leds[3] = 1;    
+	    } else {
+		/* no CRC4, disable 3 and 4 */
+		cwaintmp->leds[2] = 1;    
+		cwaintmp->leds[3] = 1;    
+	    }
+	}
+	cwain_outb(cwaintmp,cwain_R_GPIO_OUT1,(cwaintmp->leds[0] | (cwaintmp->leds[1] << 1) | (cwaintmp->leds[2] << 2) | (cwaintmp->leds[3] << 3)));
+    }
+}
+
+void cwain_reset_span(struct zt_cwain *cwaintmp) {
+    pci_write_config_word(cwaintmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+
+    /* FIFO, HDLC reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x10);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+
+    /* PCM reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x20);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+
+    /* E1 reset */
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x40);
+    cwain_outb(cwaintmp,cwain_R_CIRM,0x0); 
+    cwain_waitbusy(cwaintmp);
+
+    /* 128 byte B chans, 4096 byte D chans */
+    cwain_outb(cwaintmp,cwain_R_FIFO_MD,0x36);
+    cwain_outb(cwaintmp,cwain_R_BRG_PCM_CFG,0x0); 
+    cwain_outb(cwaintmp,cwain_R_CTRL,0x0); 
+
+    /* no blinky blink */
+    cwain_outb(cwaintmp,cwain_R_GPIO_SEL,0x20 | 0x10);
+    cwain_outb(cwaintmp,cwain_R_GPIO_EN1,0x0f);
+    cwain_outb(cwaintmp,cwain_R_GPIO_OUT1,0x0f);
+
+    cwaintmp->leds[0] = 1;    
+    cwaintmp->leds[1] = 1;    
+    cwaintmp->leds[2] = 1;    
+    cwaintmp->leds[3] = 1;    
+    
+    cwaintmp->ticks = 0;
+    cwaintmp->clicks = 0;
+}
+
+struct zt_cwain_card *cwain_get_card(unsigned int pcibus) {
+    struct zt_cwain_card *cwaintmp = cwain_card_list;
+    spin_lock(&cwain_card_registerlock);
+    while (cwaintmp) {
+	if (cwaintmp->pcibus == pcibus) {
+	    break;
+	}
+	cwaintmp = cwaintmp->next;
+    }
+    spin_unlock(&cwain_card_registerlock);
+    return cwaintmp;
+}
+
+
+void cwain_register_card(struct zt_cwain_card *cwaincard) {
+    spin_lock(&cwain_card_registerlock);
+    if (cwaincard != NULL) {
+	cwaincard->prev = NULL;
+	cwaincard->next = cwain_card_list;
+	if (cwain_card_list) {
+	    cwain_card_list->prev = cwaincard;
+	}
+	cwain_card_list = cwaincard;
+	cwain_card_count++;
+    } else {
+	printk(KERN_INFO "cwain: trying to register NULL card.\n");
+    }
+    spin_unlock(&cwain_card_registerlock);
+}
+
+int cwain_register_span(struct zt_cwain *cwainspan) {
+    struct zt_cwain_card *cwaintmp;
+    spin_lock(&cwain_span_registerlock);
+    if (cwainspan != NULL) {
+	cwainspan->prev = NULL;
+	cwainspan->next = cwain_span_list;
+	if (cwain_span_list) {
+	    cwain_span_list->prev = cwainspan;
+	}
+	cwain_span_list = cwainspan;
+	cwainspan->cardno = ++cwain_span_count;
+    } else {
+	printk(KERN_INFO "cwain: trying to register NULL span.\n");
+    }
+    spin_unlock(&cwain_span_registerlock);
+
+    if (cwainspan->type == 0xb553) {
+	cwaintmp = kmalloc(sizeof(struct zt_cwain_card),GFP_KERNEL);
+	if (!cwaintmp) {
+	    printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	    return -1;
+	}
+	memset(cwaintmp, 0x0, sizeof(struct zt_cwain_card));
+	
+	spin_lock_init(&cwaintmp->lock);
+	cwaintmp->pcibus = cwainspan->pcibus;
+	cwaintmp->span[0] = cwainspan;
+	cwaintmp->syncs[0] = -1;
+	cwaintmp->spans = 1;
+	cwaintmp->cardID = cwainspan->cardID;
+	cwain_register_card(cwaintmp);
+	printk(KERN_INFO
+	        "cwain: Junghanns.NET singleE1 PCI ISDN card configured at mem %#x IRQ %d HZ %d CardID %d\n",
+	          (u_int) cwainspan->pci_io,
+	        cwaintmp->span[0]->irq, HZ, cwainspan->cardID);
+    } else {
+	cwaintmp = cwain_get_card(cwainspan->pcibus);
+	if (!cwaintmp) {
+	    cwaintmp = kmalloc(sizeof(struct zt_cwain_card),GFP_KERNEL);
+	    if (!cwaintmp) {
+		printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	        return -1;
+	    }
+	    memset(cwaintmp, 0x0, sizeof(struct zt_cwain_card));
+	
+	    spin_lock_init(&cwaintmp->lock);
+	    cwaintmp->pcibus = cwainspan->pcibus;
+	    cwaintmp->spans = cwainspan->type - 46419;
+	    cwaintmp->span[0] = cwainspan;
+	    cwaintmp->cardID = cwainspan->cardID;
+	    cwaintmp->syncs[0] = -1;
+	    cwain_register_card(cwaintmp);
+	} else {
+	    cwaintmp->spans = cwainspan->type - 46418;
+	    if (cwainspan->cardID < cwaintmp->cardID) {
+		cwaintmp->cardID = cwainspan->cardID;
+		cwaintmp->span[1] = cwaintmp->span[0];
+		cwaintmp->syncs[1] = cwaintmp->syncs[0];
+	        cwaintmp->span[0] = cwainspan;
+	    } else {
+	        cwaintmp->span[1] = cwainspan;
+		cwaintmp->syncs[1] = -1;
+	    }
+	    printk(KERN_INFO
+	        "cwain: Junghanns.NET doubleE1 PCI ISDN card configured at mem (%#x / %#x) IRQ %d HZ %d CardID (%d / %d) bus %#x\n",
+	          (u_int) cwaintmp->span[0]->pci_io, (u_int) cwaintmp->span[0]->pci_io,
+	        cwaintmp->span[0]->irq, HZ, cwaintmp->span[0]->cardID, cwaintmp->span[1]->cardID, cwaintmp->pcibus);
+	}
+    }
+    return 0;
+}
+
+static int cwain_dfifo_tx(struct zt_cwain *cwaintmp) {
+    int chan = 15;
+    int x=0;
+    char fifo = 0;
+
+    fifo = 0x1F;
+
+    if (cwaintmp->chans[chan].bytes2transmit < 1) {
+	return 0;
+    } else {
+	/* select fifo */
+	cwain_outb(cwaintmp,cwain_R_FIFO,fifo << 1);    
+	cwain_waitbusy(cwaintmp);
+    
+	if (debug)
+	    printk(KERN_INFO "cwain: card %d TX [ ", cwaintmp->cardno);
+	/* copy frame to fifo */
+    	for (x=0;x<cwaintmp->chans[chan].bytes2transmit;x++) {
+	    if (debug)
+	        printk("%#x ",cwaintmp->dtxbuf[x]);
+    	    cwain_outb(cwaintmp,cwain_A_FIFO_DATA0,cwaintmp->dtxbuf[x]);
+	}
+	if (debug)
+	    printk("]\n");
+	if (debug)
+    	    printk(KERN_INFO "ztx %d bytes\n",cwaintmp->chans[chan].bytes2transmit);
+
+	if (cwaintmp->chans[chan].eoftx == 1) {
+	    /* transmit HDLC frame */
+    	    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x1);    
+    	    cwain_waitbusy(cwaintmp);
+	}
+    }
+    return 0;
+}
+
+static int cwain_fifo_tx(struct zt_cwain *cwaintmp, char fifo) {
+    int chan;
+    if (fifo >= 15) {
+	chan = fifo;
+    } else {
+	chan = fifo;
+    }
+    /* select fifo */
+    cwain_outb(cwaintmp,cwain_R_FIFO,0x80 | (fifo << 1));    
+    cwain_waitbusy(cwaintmp);
+    /* transmit 8 bytes of transparent data */
+    cwain_outdw(cwaintmp,cwain_A_FIFO_DATA0,*((unsigned int *) &cwaintmp->txbuf[chan][0]));
+    cwain_outdw(cwaintmp,cwain_A_FIFO_DATA0,*((unsigned int *) &cwaintmp->txbuf[chan][4]));
+	    
+    return 0;
+}
+
+static int cwain_dfifo_rx(struct zt_cwain *cwaintmp) {
+    int chan = 15;
+    unsigned char f1=1,f2=1,data,stat;
+    unsigned char of1=0,of2=0;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    char fifo = 0;
+
+    fifo = 0x1F;
+    
+    /* select fifo */
+    cwain_outb(cwaintmp,cwain_R_FIFO,(fifo << 1) | 1);    
+    cwain_waitbusy(cwaintmp);
+    
+    while ((oz1 != z1) && (oz2 != z2)) {
+        oz1 = z1;
+        oz2 = z2;
+    	z1 = cwain_inw(cwaintmp,cwain_A_Z1) & 0xfff;
+	z2 = cwain_inw(cwaintmp,cwain_A_Z2) & 0xfff;
+    }
+    
+    len = z1-(z2 & 0xfff);
+    if (len < 0) {
+        len += cwain_DFIFO_SIZE;
+    }
+
+    while ((of1 != f1) && (of2 != f2)) {
+        of1 = f1;
+        of2 = f2;
+        f1 = cwain_inb(cwaintmp,cwain_A_F1) & 0xf;
+        f2 = cwain_inb(cwaintmp,cwain_A_F2) & 0xf;
+    }
+
+    if (len > cwain_DFIFO_SIZE) {
+	printk(KERN_INFO "\ncwain: buffer overflow in D channel RX!\n");
+	cwaintmp->chans[chan].bytes2receive = 0;
+	cwaintmp->chans[chan].eofrx = 0;
+    } else {
+	if (debug) printk(KERN_INFO "cwain: card %d RX [ ", cwaintmp->cardno);
+	for (i=0; i<len; i++) {
+    	    data = cwain_inb(cwaintmp,cwain_A_FIFO_DATA0);
+	    cwaintmp->drxbuf[i] = data;
+	    if (debug) printk("%#x ",data);
+	}
+	if (debug) printk("] %d bytes\n", i);
+	cwaintmp->chans[chan].bytes2receive = i;
+	cwaintmp->chans[chan].eofrx = 1;
+    }
+
+    stat = cwain_inb(cwaintmp,cwain_A_FIFO_DATA0);
+    if (stat != 0x0) {
+	// bad CRC, skip it
+	if (cwaintmp->sync) {
+	    if (debug)
+		printk(KERN_INFO "cwain: BAD CRC for hdlc frame on card %d (cardID %d)\n",cwaintmp->cardno, cwaintmp->cardID);
+	}
+	cwaintmp->chans[chan].bytes2receive = 0;
+	cwaintmp->chans[chan].eofrx = 0;
+//	    zt_qevent_nolock(&cwaintmp->spans[stport].chans[chan], ZT_EVENT_BADFCS);
+    }
+    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x1);    
+    cwain_waitbusy(cwaintmp);
+
+    /* frame received */
+    cwaintmp->drx--;
+    return 0;
+}
+
+
+static int cwain_fifo_rx(struct zt_cwain *cwaintmp, char fifo) {
+    int chan;
+    unsigned char data;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    int mumbojumbo=0;
+
+    if (fifo >= 15) {
+	chan = fifo; /* +1 */
+    } else {
+	chan = fifo;
+    }
+
+    // select rx fifo
+    
+	// no hdlc, transparent data
+	cwain_outb(cwaintmp,cwain_R_FIFO,0x80 | (fifo << 1) | 1);    
+        cwain_waitbusy(cwaintmp);
+    
+	while ((oz1 != z1) && (oz2 != z2)) {
+	    oz1 = z1;
+	    oz2 = z2;
+	    z1 = cwain_inw(cwaintmp,cwain_A_Z1) & 0x1ff;
+    	    z2 = cwain_inw(cwaintmp,cwain_A_Z2) & 0x1ff;
+	}
+    
+	len = z1-(z2 & 0x1ff);
+	if (len < 0) {
+	    len += cwain_FIFO_SIZE;
+	}
+	if (len > 2 * ZT_CHUNKSIZE) {
+	    mumbojumbo = len - (2 * ZT_CHUNKSIZE);
+	    len = ZT_CHUNKSIZE;
+	    for (i=0;i<mumbojumbo;i++) {
+    		data = cwain_inb(cwaintmp,cwain_A_FIFO_DATA0);
+	    }
+	    cwaintmp->clicks++;
+	}
+	if (len < ZT_CHUNKSIZE) {
+//	    printk(KERN_INFO "cwain: not enough to receive (%d bytes)\n",len);
+	    return 0;
+	} else {
+	    *((unsigned int *) &cwaintmp->rxbuf[chan][0]) = cwain_indw(cwaintmp,cwain_A_FIFO_DATA0);
+	    *((unsigned int *) &cwaintmp->rxbuf[chan][4]) = cwain_indw(cwaintmp,cwain_A_FIFO_DATA0);
+	}
+
+	zt_ec_chunk(&cwaintmp->span.chans[chan], cwaintmp->span.chans[chan].readchunk, cwaintmp->span.chans[chan].writechunk);
+
+	if (cwaintmp->clicks > 1000) {
+//	    printk(KERN_INFO "cwain: span %d dropped audio fifo %d\n", cwaintmp->cardID, fifo);
+	    cwaintmp->clicks = 0;
+	}
+//    printk(KERN_INFO "s/t port %d, channel %d, dbufi=%d, f1=%d, f2=%d, z1=%d, z2=%d  => len = %d stat=%#x, hdlc=%d\n",stport,chan,cwaintmp->st[stport].dbufi,f1,f2,z1,z2,len,stat,hdlc);    
+    return 0;
+}
+
+void cwain_set_master(struct zt_cwain_card *cwaintmp, int span) {
+    int i=0;
+
+    for (i=0; i < cwaintmp->spans; i++) {
+    	cwain_outb(cwaintmp->span[i],cwain_R_PCM_MD0, 0x90);
+	if (cwaintmp->syncs[i] > 0) {
+	    /* enable PCM slave mode, PCM64, synced to E1 receive */
+	    cwain_outb(cwaintmp->span[i],cwain_R_PCM_MD1, 0x10);
+	    cwain_outb(cwaintmp->span[i],cwain_R_PCM_MD2, 0x0);
+	} else {
+	    /* enable PCM slave mode, PCM64 */
+	    cwain_outb(cwaintmp->span[i],cwain_R_PCM_MD1, 0x10);
+	    cwain_outb(cwaintmp->span[i],cwain_R_PCM_MD2, 0x4);
+	}
+	cwaintmp->master[i] = 0;
+    }
+
+    cwain_outb(cwaintmp->span[span],cwain_R_PCM_MD0, 0x91);
+    if (cwaintmp->syncs[span] > 0) {
+        /* enable PCM slave mode, PCM64, synced to E1 receive */
+        cwain_outb(cwaintmp->span[span],cwain_R_PCM_MD1, 0x10);
+        cwain_outb(cwaintmp->span[span],cwain_R_PCM_MD2, 0x0);
+    } else {
+        /* enable PCM slave mode, PCM64 */
+        cwain_outb(cwaintmp->span[span],cwain_R_PCM_MD1, 0x10);
+        cwain_outb(cwaintmp->span[span],cwain_R_PCM_MD2, 0x4);
+    }
+    
+    cwaintmp->master[span] = 1;
+    cwaintmp->syncsrc = span;
+
+    if (debug)
+	printk(KERN_INFO "cwain: cardID %d new master %d\n", cwaintmp->cardID, span);
+}
+
+void cwain_check_timing(struct zt_cwain_card *cwaintmp) {
+    int i=0;
+    /* sync lost, need new master */
+    if (!(cwaintmp->span[cwaintmp->syncsrc]->sync)) {
+	for (i=0; i < cwaintmp->spans; i++) {
+	    if ((cwaintmp->span[i]->sync_sta & 0x7) == 0x7) {
+		cwain_set_master(cwaintmp, i);
+	    }
+	}
+	if (i == cwaintmp->spans) {
+	    for (i=0; i < cwaintmp->spans; i++) {
+
+//		printk(KERN_INFO "cwain: span %d new sync %#x\n", i, cwaintmp->syncs[i]);
+		if (cwaintmp->syncs[i] == 0) {
+		    cwain_set_master(cwaintmp, i);
+		}
+	    }
+	}
+    }
+}
+
+static inline void cwain_isr_run(struct zt_cwain *cwaintmp) {
+    int fifo=0;
+    if (cwaintmp->span.flags & ZT_FLAG_RUNNING) {
+        /* oh zaptel! tell us what to transmit... */
+        zt_transmit(&cwaintmp->span);
+	/* B chans 1-15 mapped to fifos 0-14 */
+	/* B chans 17-31 mapped to fifos 15-29 */
+	for (fifo=0; fifo < 30; fifo++) {
+	    /* B xmit */
+	    cwain_fifo_tx(cwaintmp, fifo);
+	}
+	if (cwaintmp->sync) {
+	    cwain_dfifo_tx(cwaintmp);
+	}
+
+        cwaintmp->chans[15].bytes2receive = 0;
+	cwaintmp->chans[15].bytes2transmit = 0;
+	cwaintmp->chans[15].eofrx = 0;
+	cwaintmp->chans[15].eoftx = 0;
+
+	for (fifo=0; fifo < 30; fifo++) {
+	    /* B rx */
+	    cwain_fifo_rx(cwaintmp, fifo);
+	}
+
+	/* d-chan data */
+	if ((cwaintmp->drx > 0) && cwaintmp->sync){
+	    if (debug > 2)
+	    	printk(KERN_CRIT "drx = %d\n", cwaintmp->drx);
+	    cwain_dfifo_rx(cwaintmp);
+	}
+	/* oh zaptel! thou shall receive! */
+	zt_receive(&(cwaintmp->span));
+    }
+}
+
+void cwain_isr_sync(struct zt_cwain *cwainspan) {
+    unsigned char sync_sta;
+    unsigned char sync_ok = 0;
+    unsigned char jatt_sta = 0;
+
+    sync_sta = cwain_inb(cwainspan, cwain_R_SYNC_STA);
+
+if ((!cwainspan->sync) || (sync_sta != cwainspan->sync_sta)) {
+    cwainspan->sync_sta = sync_sta;
+    if (debug)
+	printk(KERN_CRIT "cwain: cardID %d R_SYNC_STA =%#x\n", cwainspan->cardID, sync_sta);
+    if (cwainspan->span.lineconfig & ZT_CONFIG_CRC4) {
+	if ((sync_sta & 0x27) == 0x27) {
+	    sync_ok = 0x27;
+	} else {
+	    sync_ok = 0x00;
+	}
+    } else {
+	if ((sync_sta & 0x07) == 0x07) {
+	    sync_ok = 0x07;
+	} else {
+	    sync_ok = 0x00;
+	}
+    }
+
+    jatt_sta = cwain_inb(cwainspan, cwain_R_JATT_STA);
+    if ((jatt_sta & 0x60) != 0x60) {
+	if (debug)
+	    printk(KERN_INFO "cwain: %d jitter attenuator %#x\n", cwainspan->cardID, (jatt_sta & 0x60) >> 5);
+	sync_ok = 0x00;
+    } else if (!cwainspan->sync) {
+	if (debug)
+	    printk(KERN_CRIT "cwain: %d jitter attenuator %#x ok!\n", cwainspan->cardID, (jatt_sta & 0x60) >> 5);
+	/* elastic buffer offsets */
+	cwain_outb(cwainspan,cwain_R_RX_OFFS,0x06);
+	cwain_outb(cwainspan,cwain_R_TX_OFFS,0x06);
+    }
+
+    if (sync_ok && (!cwainspan->sync)) {
+	if (debug > 2)
+	    printk(KERN_INFO "cwain: enabling D channel fifos\n");
+	cwain_outb(cwainspan,cwain_R_FIFO,0x1F << 1);
+	cwain_waitbusy(cwainspan);
+	cwain_outb(cwainspan,cwain_A_CON_HDLC,0xd);
+	cwain_outb(cwainspan,cwain_A_IRQ_MSK,0x1);
+	
+	cwain_outb(cwainspan,cwain_R_FIFO,(0x1F << 1) | 1);
+	cwain_waitbusy(cwainspan);
+	cwain_outb(cwainspan,cwain_A_CON_HDLC,0xd);
+	cwain_outb(cwainspan,cwain_A_IRQ_MSK,0x1);
+    }
+    if (!sync_ok && cwainspan->sync) {
+	if (debug > 2)
+	    printk(KERN_INFO "cwain: disabling D channel fifos\n");
+	cwain_outb(cwainspan,cwain_R_FIFO,0x1F << 1);
+	cwain_waitbusy(cwainspan);
+	cwain_outb(cwainspan,cwain_A_CON_HDLC,0x1);
+	cwain_outb(cwainspan,cwain_A_IRQ_MSK,0x0);
+	cwain_outb(cwainspan,cwain_R_FIFO,(0x1F << 1) | 1);
+	cwain_waitbusy(cwainspan);
+	cwain_outb(cwainspan,cwain_A_CON_HDLC,0x1);
+	cwain_outb(cwainspan,cwain_A_IRQ_MSK,0x0);
+    }
+
+    cwainspan->sync = sync_ok;
+    if (sync_ok) {
+	switch (cwainspan->type) {
+	    case 0xb553:
+		sprintf(cwainspan->span.desc,"Junghanns.NET singleE1 PCI ISDN Card %d (cardID %d) SYNCED",cwainspan->cardno,cwainspan->cardID);
+		break;
+    	    case 0xb554:
+		sprintf(cwainspan->span.desc,"Junghanns.NET doubleE1 PCI ISDN Card %d (cardID %d) (1 E1 port) SYNCED",cwainspan->cardno,cwainspan->cardID);
+	        break;
+	}
+    } else {
+	switch (cwainspan->type) {
+	    case 0xb553:
+		sprintf(cwainspan->span.desc,"Junghanns.NET singleE1 PCI ISDN Card %d (cardID %d) NO SYNC (sync_sta = %#x)",cwainspan->cardno,cwainspan->cardID, sync_sta);
+		break;
+    	    case 0xb554:
+		sprintf(cwainspan->span.desc,"Junghanns.NET doubleE1 PCI ISDN Card %d (cardID %d) (1 E1 port) NO SYNC (sync_sta = %#x)",cwainspan->cardno,cwainspan->cardID, sync_sta);
+	        break;
+	}
+    }
+    cwain_doLEDs(cwainspan);
+}
+}
+
+int cwain_isr_fifo(struct zt_cwain *cwainspan, unsigned char status) {
+    unsigned char irq_foview,fi;
+
+    if (status & 0x80) {
+	/* fifo irq */
+	irq_foview = cwain_inb(cwainspan,cwain_R_IRQ_OVIEW);
+	if (irq_foview & 0x80) {
+	    fi = cwain_inb(cwainspan,cwain_R_IRQ_FIFO_BL7);
+	    if (fi & 0x80) {
+		if (debug > 2)
+		    printk(KERN_CRIT "cwain: fifo 31 RX irq for D channel\n");
+		cwainspan->drx += 1;		
+	    }
+	}
+	return 1;
+    }
+    return 0;
+}
+
+#ifdef LINUX26
+static irqreturn_t cwain_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#else
+static void cwain_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#endif
+    struct zt_cwain_card *cwaintmp = dev_id;
+    unsigned char status, status_tmp, irq_misc;
+    unsigned long flags;
+    int i = 0;
+
+    if (!cwaintmp) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    } else if (cwaintmp->dead) {
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+    }
+    
+    
+    spin_lock_irqsave(&(cwaintmp->lock),flags);
+    status = cwain_inb(cwaintmp->span[0],cwain_R_STATUS);
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	if (i == 0) {
+	    status_tmp = status;
+	} else {
+	    status_tmp = cwain_inb(cwaintmp->span[i],cwain_R_STATUS);
+	}
+	cwain_isr_fifo(cwaintmp->span[i], status_tmp);
+    }
+
+    if (!(status & 0x80) && !(status & 0x40)) {
+	// it's not us!
+	spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    // misc irq
+    if (status & 0x40) {
+	irq_misc = cwain_inb(cwaintmp->span[0],cwain_R_IRQ_MISC);
+	if (irq_misc & 0x2)  {
+	    // cwain timer
+	    cwaintmp->ticks++;
+	    for (i=0;i<cwaintmp->spans;i++) {
+		cwain_isr_run(cwaintmp->span[i]);
+	    }
+	    if (cwaintmp->ticks == 500) {
+		cwaintmp->ticks = 0;
+	    }
+	} else if (irq_misc & 0x10) {
+	    for (i=0;i<cwaintmp->spans;i++) {
+	        cwain_isr_sync(cwaintmp->span[i]);
+	    }
+	    cwain_check_timing(cwaintmp);
+	}
+    }
+
+    spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+static int ztcwain_open(struct zt_chan *chan) {
+//    printk(KERN_INFO "cwain: channel %d opened.\n",chan->channo);
+#ifndef LINUX26
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztcwain_close(struct zt_chan *chan) {
+//    printk(KERN_INFO "cwain: channel %d closed.\n",chan->channo);
+#ifndef LINUX26
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztcwain_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int ztcwain_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int ztcwain_startup(struct zt_span *span) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    struct zt_cwain *cwaintmp;
+    unsigned long flags;
+    int alreadyrunning;
+    int i=0;
+
+//    printk(KERN_INFO "cwain: startup spanno %d offset %d\n", span->spanno, span->offset);
+
+    if (cwaincard == NULL) {
+	printk(KERN_CRIT "cwain: cwaincard == NULL!\n");
+	return 0;
+    }
+
+    cwaintmp = cwaincard->span[span->offset];
+    if (cwaintmp == NULL) {
+	printk(KERN_CRIT "cwain: cwaintmp == NULL!\n");
+	return 0;
+    }
+
+    
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+//    printk(KERN_CRIT "already running %d flags %d\n", alreadyrunning, span->flags);
+
+    if (!alreadyrunning) {
+	span->chans[15].flags &= ~ZT_FLAG_HDLC;
+	span->chans[15].flags |= ZT_FLAG_BRIDCHAN; /* yes! */
+    
+	/* setup B channel buffers (8 bytes each) */
+	for (i=0; i<15 ; i++) {
+	    memset(cwaintmp->rxbuf[i],0x0,sizeof(cwaintmp->rxbuf[i]));
+    	    memset(cwaintmp->txbuf[i],0x0,sizeof(cwaintmp->txbuf[i]));
+
+    	    span->chans[i].readchunk = cwaintmp->rxbuf[i];
+	    span->chans[i].writechunk = cwaintmp->txbuf[i];
+	}
+	for (i=16; i<31 ; i++) {
+	    memset(cwaintmp->rxbuf[i-1],0x0,sizeof(cwaintmp->rxbuf[i-1]));
+    	    memset(cwaintmp->txbuf[i-1],0x0,sizeof(cwaintmp->txbuf[i-1]));
+    	    span->chans[i].readchunk = cwaintmp->rxbuf[i-1];
+	    span->chans[i].writechunk = cwaintmp->txbuf[i-1];
+	}
+	/* setup D channel buffer */
+    	memset(cwaintmp->dtxbuf,0x0,sizeof(cwaintmp->dtxbuf));
+	span->chans[15].writechunk = cwaintmp->dtxbuf;
+	cwaintmp->chans[15].maxbytes2transmit = sizeof(cwaintmp->dtxbuf);
+
+	memset(cwaintmp->drxbuf,0x0,sizeof(cwaintmp->drxbuf));
+    	span->chans[15].readchunk = cwaintmp->drxbuf;
+
+	span->flags |= ZT_FLAG_RUNNING;
+    } else {
+	printk(KERN_CRIT "already running\n");
+	return 0;
+    }
+
+    spin_lock_irqsave(&cwaintmp->lock,flags);
+    // irqs off
+    cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0); 
+
+    /* setup D-FIFO TX */
+    cwain_outb(cwaintmp,cwain_R_FIFO,0x1F << 1);
+    cwain_waitbusy(cwaintmp);
+    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    cwain_waitbusy(cwaintmp);
+    cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x1);
+    cwain_outb(cwaintmp,cwain_A_SUBCH_CFG,0x0);
+    cwain_outb(cwaintmp,cwain_A_CHANNEL,0x10 << 1);
+    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+
+    /* setup D-FIFO RX */
+    cwain_outb(cwaintmp,cwain_R_FIFO,(0x1F << 1) | 1);
+    cwain_waitbusy(cwaintmp);
+    cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    cwain_waitbusy(cwaintmp);
+    cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x1);
+    cwain_outb(cwaintmp,cwain_A_SUBCH_CFG,0x0);
+    cwain_outb(cwaintmp,cwain_A_CHANNEL,(0x10 << 1) | 1);
+    cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+
+    /* setup B-FIFOs TX */
+    /* map ts 1 to 15 to fifos 0 to 14 */
+    for (i=1; i<16 ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,(i - 1) << 1);
+	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+	cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+    }
+    /* map ts 17 to 31 to fifos 15 to 29 */
+    for (i=17; i<32 ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,(i - 2) << 1);
+	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+	cwain_outb(cwaintmp,cwain_A_CHANNEL,i << 1);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+    }
+
+    /* setup B-FIFOs RX */
+    /* map ts 1 to 15 to fifos 0 to 14 */
+    for (i=1; i<16 ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,((i-1) << 1) | 1);
+    	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+    	cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+    	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+    }
+    /* map ts 17 to 31 to fifos 15 to 29 */
+    for (i=17; i<32 ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,((i-2) << 1) | 1);
+    	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_R_INC_RES_FIFO,0x2);
+    	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_A_CON_HDLC,0x2);
+    	cwain_outb(cwaintmp,cwain_A_CHANNEL,(i << 1) | 1);
+    	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x1);
+    }
+
+    if (debug)
+        printk(KERN_INFO "cwain: starting card %d span %d/%d.\n",cwaintmp->cardno,span->spanno,span->offset);
+
+    /* setup E1 amplitude */
+    cwain_outb(cwaintmp,cwain_R_PWM_MD,0x20);
+    cwain_outb(cwaintmp,cwain_R_PWM0,0x50);
+    cwain_outb(cwaintmp,cwain_R_PWM1,0xff);
+
+    /* setup E1 transceiver */
+    cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG0,0xf8); // R_TX_FR1
+    cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG0,0x06);
+
+    if (cwaintmp->span.lineconfig & ZT_CONFIG_AMI) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x82);
+	cwain_outb(cwaintmp,cwain_R_RX0,0x82);
+    } else if (cwaintmp->span.lineconfig & ZT_CONFIG_HDB3) {
+	cwain_outb(cwaintmp,cwain_R_TX0,0x81);
+	cwain_outb(cwaintmp,cwain_R_RX0,0x81);
+    }
+
+    /* transmitter mode */
+    cwain_outb(cwaintmp,cwain_R_TX1,0x60); 
+
+    cwain_outb(cwaintmp,cwain_R_LOS0,0x10);
+    cwain_outb(cwaintmp,cwain_R_LOS1,0x10);
+
+    if (cwaintmp->span.lineconfig & ZT_CONFIG_CRC4) {
+	/* crc4 multiframe */
+	cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG1,0x31);
+	cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG1,0x03);
+    } else {
+	/* doubleframe */
+	cwain_outb(cwaintmp,cwain_R_TX_SL0_CFG1,0x0);
+	cwain_outb(cwaintmp,cwain_R_RX_SL0_CFG1,0x40);
+    }
+
+    /* automagical jitter attenuator */
+    cwain_outb(cwaintmp,cwain_R_JATT_CFG,0x9c);
+    
+    /* setup sync mode */    
+    if (cwaintmp->span.syncsrc > 0) {
+	cwain_outb(cwaintmp,cwain_R_SYNC_CTRL,0x7);
+	/* layer 1, here we go! */
+	cwain_outb(cwaintmp,cwain_R_E1_WR_STA,0x0);
+    } else {
+	cwain_outb(cwaintmp,cwain_R_SYNC_CTRL,0x2);
+	/* layer 1, up! */
+	cwain_outb(cwaintmp,cwain_R_E1_WR_STA,0x11);
+    }
+    cwain_outb(cwaintmp,cwain_R_SYNC_OUT,0x0);    
+    
+    cwaintmp->sync = 0;
+    cwaintmp->sync_sta = 0;
+    
+    /* enable irqs */
+    spin_unlock_irqrestore(&cwaintmp->lock,flags);
+    cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 8 | 1); 
+
+    return 0;
+}
+
+static int ztcwain_shutdown(struct zt_span *span) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    struct zt_cwain *cwaintmp;
+    int alreadyrunning;
+    int i=0;
+    
+    if (cwaincard == NULL) {
+	printk(KERN_CRIT "cwain: cwaincard == NULL!\n");
+	return 0;
+    }
+
+    cwaintmp = cwaincard->span[span->offset];
+    if (cwaintmp == NULL) {
+	printk(KERN_CRIT "cwain: cwaintmp == NULL!\n");
+	return 0;
+    }
+
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	return 0;
+    }
+
+//    printk(KERN_CRIT "cwain: stopping card %d span %d/%d.\n",cwaintmp->cardno,span->spanno,span->offset);
+
+    // turn off irqs for all fifos
+
+    /* disable FIFO TX */
+    for (i=1; i<=0x1F ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,(i - 1) << 1);
+	cwain_waitbusy(cwaintmp);
+	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    }
+
+    /* disable FIFO RX */
+    for (i=1; i<=0x1F ; i++) {
+	cwain_outb(cwaintmp,cwain_R_FIFO,((i-1) << 1) | 1);
+    	cwain_waitbusy(cwaintmp);
+    	cwain_outb(cwaintmp,cwain_A_IRQ_MSK,0x0);
+    }
+
+    span->flags &= ~ZT_FLAG_RUNNING;
+
+    /* Deactivate Layer 1 */
+
+// XXX
+
+//    printk(KERN_CRIT "cwain: card %d span %d/%d down.\n",cwaintmp->cardno,span->spanno,span->offset);
+    return 0;
+}
+
+static int ztcwain_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int ztcwain_chanconfig(struct zt_chan *chan,int sigtype) {
+//    printk(KERN_INFO "chan_config sigtype=%d\n", sigtype);
+    return 0;
+}
+
+static int ztcwain_spanconfig(struct zt_span *span,struct zt_lineconfig *lc) {
+    struct zt_cwain_card *cwaincard = span->pvt;
+    span->lineconfig = lc->lineconfig;
+    span->syncsrc = lc->sync;
+
+    cwaincard->syncs[span->spanno - 1] = lc->sync;
+//    printk(KERN_INFO "span_config %d lineconfig=%d syncsrc=%d\n", span->spanno, lc->lineconfig, lc->sync);
+    cwain_check_timing(cwaincard);
+    return 0;
+}
+
+static int ztcwain_initialize(struct zt_cwain *cwaintmp, struct zt_cwain_card *cwaincard, int offset) {
+    int i=0;
+    
+	memset(&cwaintmp->span,0,sizeof(struct zt_span)); // you never can tell...
+	sprintf(cwaintmp->span.name,"cwain/%d",cwaintmp->cardno);
+	switch (cwaintmp->type) {
+	    case 0xb553:
+		sprintf(cwaintmp->span.desc,"Junghanns.NET singleE1 PCI ISDN Card %d (cardID %d)",cwaintmp->cardno,cwaintmp->cardID);
+		break;
+	    case 0xb554:
+		sprintf(cwaintmp->span.desc,"Junghanns.NET doubleE1 PCI ISDN Card %d (cardID %d) (1 E1 port)",cwaintmp->cardno,cwaintmp->cardID);
+		break;
+	    default:
+		return -1;
+	}
+        cwaintmp->span.spanconfig = ztcwain_spanconfig;
+        cwaintmp->span.chanconfig = ztcwain_chanconfig;
+        cwaintmp->span.startup = ztcwain_startup;
+        cwaintmp->span.shutdown = ztcwain_shutdown;
+        cwaintmp->span.maint = ztcwain_maint;
+        cwaintmp->span.rbsbits = ztcwain_rbsbits;
+        cwaintmp->span.open = ztcwain_open;
+        cwaintmp->span.close = ztcwain_close;
+        cwaintmp->span.ioctl = ztcwain_ioctl;
+
+        cwaintmp->span.chans = cwaintmp->chans;
+        cwaintmp->span.channels = 31;
+        cwaintmp->span.deflaw = ZT_LAW_ALAW;
+        cwaintmp->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_HDB3 | ZT_CONFIG_CCS; 
+        init_waitqueue_head(&cwaintmp->span.maintq);
+        cwaintmp->span.pvt = cwaincard;
+        cwaintmp->span.offset = offset;
+
+	for (i=0; i < cwaintmp->span.channels; i++) {
+	    memset(&(cwaintmp->chans[i]),0x0,sizeof(struct zt_chan));
+	    sprintf(cwaintmp->chans[i].name,"cwain%d/%d",cwain_span_count + 1,i + 1);
+	    cwaintmp->chans[i].pvt = cwaintmp;
+	    cwaintmp->chans[i].sigcap =  ZT_SIG_CLEAR;
+	    cwaintmp->chans[i].chanpos = i + 1; 
+	}
+
+	if (zt_register(&cwaintmp->span,0)) {
+	    printk(KERN_INFO "cwain: unable to register zaptel span!\n");
+	    return -1;
+	}
+//	 printk(KERN_INFO "cwain: registered zaptel span %d.\n",s+1);
+
+    return 0;
+}
+
+int cwain_reset_card(struct zt_cwain_card *cwaintmp) {
+    unsigned long flags;
+    int i = 0;
+
+    cwaintmp->irq = cwaintmp->span[0]->irq;
+    
+    if (cwaintmp->spans == 2) {
+	if (request_irq(cwaintmp->irq, cwain_interrupt, SA_INTERRUPT | SA_SHIRQ, "cwain2", cwaintmp)) {
+    	    printk(KERN_WARNING "cwain: unable to register irq\n");
+	    return -1;
+	}
+    } else {
+	if (request_irq(cwaintmp->irq, cwain_interrupt, SA_INTERRUPT | SA_SHIRQ, "cwain", cwaintmp)) {
+    	    printk(KERN_WARNING "cwain: unable to register irq\n");
+	    return -1;
+	}
+    }
+
+    for (i=0;i<cwaintmp->spans;i++) {
+	cwain_reset_span(cwaintmp->span[i]);
+    }
+
+    spin_lock_irqsave(&(cwaintmp->lock),flags);
+
+    /* set up the timer 1 khz, zaptel timing */
+    cwain_outb(cwaintmp->span[0],cwain_R_TI_WD, 0x2);
+    /* enable timer interrupts */
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQMSK_MISC, 0x12); 
+
+    /* Finally enable IRQ output */
+    cwain_outb(cwaintmp->span[0],cwain_R_IRQ_CTRL, 0x8 | 0x1); 
+
+    spin_unlock_irqrestore(&(cwaintmp->lock),flags);
+    return 0;
+}
+
+int cwain_find_spans(unsigned int pcidid) {
+    struct pci_dev *tmp;
+    struct zt_cwain *cwaintmp = NULL;
+    int i=0;
+    unsigned char dips=0;
+    int cid=0;
+    int modes=0;
+    tmp = pci_find_device(PCI_VENDOR_ID_CCD,pcidid,multi_cwain);
+    while (tmp != NULL) {
+	multi_cwain = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_cwain = NULL;
+	    return -1;
+	}
+
+	cwaintmp = kmalloc(sizeof(struct zt_cwain),GFP_KERNEL);
+	if (!cwaintmp) {
+	    printk(KERN_WARNING "cwain: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -ENOMEM;
+	}
+	memset(cwaintmp, 0x0, sizeof(struct zt_cwain));
+	
+	spin_lock_init(&cwaintmp->lock);
+	cwaintmp->pcidev = tmp;
+	cwaintmp->pcibus = tmp->bus->number;
+	cwaintmp->pcidevfn = tmp->devfn; 
+
+
+	cwaintmp->pci_io = (char *) tmp->resource[1].start;
+	if (!cwaintmp->pci_io) {
+	    printk(KERN_WARNING "cwain: no iomem!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "cwain: PCI device has no irq!\n");
+	    pci_disable_device(tmp);
+	    multi_cwain = NULL;
+	    return -EIO;
+	}
+
+        cwaintmp->irq = tmp->irq;
+
+	cwaintmp->pci_io = ioremap((ulong) cwaintmp->pci_io, 256);
+			       
+	/* enable memio */
+	pci_write_config_word(cwaintmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	
+
+	/* disable interrupts */
+	cwain_outb(cwaintmp,cwain_R_IRQ_CTRL, 0); 
+
+        if (((tmp->subsystem_device==0xb553) || (tmp->subsystem_device==0xb554))&& (pcidid == PCI_DEVICE_ID_CCD_E)) {
+	    dips = (cwain_inb(cwaintmp,cwain_R_GPI_IN0) >> 5);
+	    cid = 7;
+	    for (i=0;i<3;i++) {
+	        if ((dips & (1 << i)) != 0) {
+	    	cid -= (1 << (2-i));
+	        }
+	    }
+//		printk(KERN_INFO "DIPS = %#x CID= %#x\n",dips,cid);
+        } else {
+	    cid = 0xff;
+        }
+
+	if (ports == -1) {
+    	    if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_E)) {
+		modes = (cwain_inb(cwaintmp,cwain_R_GPI_IN0) >> 4) & 0x01;
+	    } else {
+		modes = 0; // assume TE mode
+	    }
+	} else {
+	    modes = ports >> cwain_span_count;
+	}
+
+
+	cwaintmp->cardID = cid;
+	cwaintmp->type = tmp->subsystem_device;
+
+	if ((modes & 1) != 0) {
+	    cwaintmp->nt_mode = 1;
+	} else {
+	    cwaintmp->nt_mode = 0;
+	}
+
+	cwain_register_span(cwaintmp);
+
+	tmp = pci_find_device(PCI_VENDOR_ID_CCD,pcidid,multi_cwain);
+    }
+    return 0;
+}
+
+
+int cwain_sort_cards(void) {
+    int changed=0,tmpcardno;
+    struct zt_cwain_card *tmpcard,*tmpcard2;
+    spin_lock(&cwain_card_registerlock);
+    do {
+	changed = 0;
+	tmpcard = cwain_card_list;
+	while (tmpcard != NULL) {
+	    if (tmpcard->prev) {
+		if (tmpcard->prev->cardID > tmpcard->cardID) {
+		    tmpcardno = tmpcard->prev->cardno;
+		    tmpcard->prev->cardno = tmpcard->cardno; 
+		    tmpcard->cardno = tmpcardno;
+		
+		    tmpcard2 = tmpcard->prev;
+		    if (tmpcard2->prev) {
+			tmpcard2->prev->next = tmpcard;
+		    } else {
+			cwain_card_list = tmpcard;
+		    }
+		    if (tmpcard->next) {
+			tmpcard->next->prev = tmpcard2;
+		    } 
+		    tmpcard2->next = tmpcard->next;
+		    tmpcard->prev = tmpcard2->prev;
+		    tmpcard->next = tmpcard2;
+		    tmpcard2->prev = tmpcard;
+		    changed = 1;
+		    tmpcard = tmpcard2;
+		}
+	    }
+	    tmpcard = tmpcard->next;
+	}
+    } while (changed == 1);
+    spin_unlock(&cwain_card_registerlock);
+    return 0;
+}
+
+int cwain_zap_cards(void) {
+    struct zt_cwain_card *tmpcard = cwain_card_list;
+    int i=0;
+    while (tmpcard != NULL) {
+	for (i=0; i<tmpcard->spans; i++) {
+	    ztcwain_initialize(tmpcard->span[i], tmpcard, i);
+	}
+	cwain_reset_card(tmpcard);
+	tmpcard = tmpcard->next;
+    }
+    return 0;
+}
+
+
+int init_module(void) {
+    multi_cwain = NULL;
+    cwain_find_spans(PCI_DEVICE_ID_CCD_E);
+    cwain_sort_cards();
+    cwain_zap_cards();
+    if (cwain_card_count == 0) {
+	printk(KERN_INFO "cwain: no cwain cards found.\n");
+    } else {
+	printk(KERN_INFO "cwain: %d cwain card(s) in this box, %d E1 ports total.\n", cwain_card_count, cwain_span_count);
+    }
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct zt_cwain_card *tmpcard,*tmplist;
+    struct zt_cwain *tmpspan,*spanlist;
+    int i=0;
+    int j=0;
+    
+    tmplist = cwain_card_list;
+    tmpcard = NULL;
+    while (tmplist) {
+	tmpcard = tmplist;
+	tmplist = tmplist->next;
+
+	cwain_shutdown_card(tmpcard);
+	kfree(tmpcard);
+	i++;
+    }
+
+    spanlist = cwain_span_list;
+    tmpspan = NULL;
+    while (spanlist) {
+	tmpspan = spanlist;
+	spanlist = spanlist->next;
+	kfree(tmpspan);
+	j++;
+    }
+    printk(KERN_INFO "cwain: shutdown %d spans, %d cwain cards.\n", j, i);
+}
+#endif
+
+MODULE_PARM(ports,"i");
+MODULE_PARM(debug,"i");
+MODULE_DESCRIPTION("cwain zaptel driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urNad --exclude=CVS --exclude=.svn ./cwain/cwain.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/cwain.h
--- ./cwain/cwain.h	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/cwain.h	2005-07-14 07:01:26.951442440 +0100
@@ -0,0 +1,237 @@
+#define cwain_FIFO_SIZE	128
+#define cwain_DFIFO_SIZE	4096
+
+typedef struct zt_cwain {
+    /* pci resources */
+    unsigned int irq;
+    unsigned int iomem;
+    unsigned char *pci_io;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    unsigned int type;
+
+    /* lock to protect the structure */
+    spinlock_t lock;
+    int cardID;
+    unsigned char cardno;
+    
+    /* ticks and clicks, fish and chips */
+    unsigned int ticks;
+    unsigned int clicks;
+    unsigned char nt_mode;
+    unsigned char sync_sta;
+    unsigned char sync;
+    int syncmode;
+    
+    /* blinky blink */
+    unsigned char leds[4];
+
+    /* B chan buffers */
+    unsigned char rxbuf[30][ZT_CHUNKSIZE];
+    unsigned char txbuf[30][ZT_CHUNKSIZE];
+    
+    /* number of RXed dchan frames */
+    unsigned char drx;
+    /* D chan buffer */
+    unsigned char drxbuf[cwain_DFIFO_SIZE];
+    unsigned char dtxbuf[cwain_DFIFO_SIZE];
+
+
+    /* zaptel resources */
+    struct zt_span span;
+    struct zt_chan chans[31];
+
+    /* more zaptel stuff */
+    unsigned int usecount;
+    int spantype;
+    int spanflags;
+
+    /* linked list */
+    struct zt_cwain *next;
+    struct zt_cwain *prev;
+
+} zt_cwain;
+
+typedef struct zt_cwain_card {
+    /* lock to protect the structure */
+    spinlock_t lock;
+
+    unsigned int spans;
+    unsigned int dead;
+    int cardID;
+    unsigned char cardno;
+    unsigned int ticks;
+
+    struct zt_cwain *span[2];
+    int syncsrc;
+    int syncs[2];
+    int master[2];
+    
+    unsigned int irq;   
+    unsigned int pcibus;
+
+    /* linked list */
+    struct zt_cwain_card *next;
+    struct zt_cwain_card *prev;
+} zt_cwain_card;
+
+#define cwain_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define cwain_inb(a,b) (readb((a)->pci_io+(b)))
+
+#define cwain_outw(a,b,c) (writew((c),(a)->pci_io+(b)))
+#define cwain_inw(a,b) (readw((a)->pci_io+(b)))
+
+#define cwain_outdw(a,b,c) (writel((c),(a)->pci_io+(b)))
+#define cwain_indw(a,b) (readl((a)->pci_io+(b)))
+
+
+/* Write only registers */
+#define cwain_A_CH_MSK		0xF4
+#define cwain_A_CHANNEL 	0xFC
+#define cwain_A_CON_HDLC	0xFA
+#define cwain_A_CONF		0xD1
+#define cwain_A_FIFO_SEQ	0xFD
+#define cwain_R_INC_RES_FIFO	0x0E
+#define cwain_A_IRQ_MSK		0xFF
+#define cwain_A_SL_CFG		0xD0
+#define cwain_A_SUBCH_CFG	0xFB
+#define cwain_R_BERT_WD_MD	0x1B
+#define cwain_R_BRG_PCM_CFG	0x02
+#define cwain_R_CIRM		0x00
+#define cwain_R_CONF_EN		0x18
+#define cwain_R_CTRL		0x01
+#define cwain_R_DTMF		0x1C
+#define cwain_R_DTMF_N		0x1D
+#define cwain_R_E1_WR_STA	0x20
+#define cwain_R_FIFO_MD		0x0D
+#define cwain_R_FIFO		0x0F
+#define cwain_R_FIRST_FIFO	0x0B
+#define cwain_R_FSM_IDX		0x0F
+#define cwain_R_GPIO_EN0	0x42
+#define cwain_R_GPIO_EN1	0x43
+#define cwain_R_GPIO_OUT0	0x40
+#define cwain_R_GPIO_OUT1	0x41
+#define cwain_R_GPIO_SEL	0x44
+#define cwain_R_IRQ_CTRL	0x13
+#define cwain_R_IRQMSK_MISC	0x11
+#define cwain_R_JATT_CFG	0x2F
+#define cwain_R_LOS0		0x22
+#define cwain_R_LOS1		0x23
+#define cwain_R_PCM_MD0		0x14
+#define cwain_R_PCM_MD1		0x15
+#define cwain_R_PCM_MD2		0x15
+#define cwain_R_PWM_MD		0x46
+#define cwain_R_PWM0		0x38
+#define cwain_R_PWM1		0x39
+#define cwain_R_RAM_ADDR0	0x08
+#define cwain_R_RAM_ADDR1	0x09
+#define cwain_R_RAM_ADDR2	0x0A
+#define cwain_R_RAM_MISC	0x0C
+#define cwain_R_RX_OFFS		0x30
+#define cwain_R_RX_SL0_CFG0	0x25
+#define cwain_R_RX_SL0_CFG1	0x26
+#define cwain_R_RX0		0x24
+#define cwain_R_SH0H		0x15
+#define cwain_R_SH0L		0x15
+#define cwain_R_SH1H		0x15
+#define cwain_R_SH1L		0x15
+#define cwain_R_SL_SEL0		0x15
+#define cwain_R_SL_SEL1		0x15
+#define cwain_R_SL_SEL2		0x15
+#define cwain_R_SL_SEL3		0x15
+#define cwain_R_SL_SEL4		0x15
+#define cwain_R_SL_SEL5		0x15
+#define cwain_R_SL_SEL6		0x15
+#define cwain_R_SL_SEL7		0x15
+#define cwain_R_SLOT		0x10
+#define cwain_R_SYNC_CTRL	0x35
+#define cwain_R_SYNC_OUT	0x31
+#define cwain_R_TI_WD		0x1A
+#define cwain_R_TX_OFFS		0x34
+#define cwain_R_TX_SL0_CFG0	0x2C
+#define cwain_R_TX_SL0_CFG1	0x2E
+#define cwain_R_TX_SL0		0x2D
+#define cwain_R_TX0		0x28
+#define cwain_R_TX1		0x29
+
+#define cwain_R_TX_FR0		0x2C
+#define cwain_R_TX_FR1		0x2D
+#define cwain_R_TX_FR2		0x2E
+
+#define cwain_R_RX_FR0		0x25
+#define cwain_R_RX_FR1		0x26
+
+/* Read only registers */
+#define cwain_A_F1		0x0C
+#define cwain_A_F12		0x0C
+#define cwain_A_F2		0x0D
+#define cwain_A_Z1		0x04
+#define cwain_A_Z12		0x04
+#define cwain_A_Z1H		0x05
+#define cwain_A_Z1L		0x04
+#define cwain_A_Z2		0x06
+#define cwain_A_Z2H		0x07
+#define cwain_A_Z2L		0x06
+#define cwain_R_BERT_ECH	0x1B
+#define cwain_R_BERT_ECL	0x1A
+#define cwain_R_BERT_STA	0x17
+#define cwain_R_CHIP_ID		0x16
+#define cwain_R_CHIP_RV		0x1F
+#define cwain_R_CONF_OFLOW	0x14
+#define cwain_R_CRC_ECH		0x35
+#define cwain_R_CRC_ECL		0x34
+#define cwain_R_E_ECH		0x37
+#define cwain_R_E_ECL		0x36
+#define cwain_R_E1_RD_STA	0x20
+#define cwain_R_F0_CNTH		0x19
+#define cwain_R_F0_CNTL		0x18
+#define cwain_R_FAS_ECH		0x31
+#define cwain_R_FAS_ECL		0x30
+#define cwain_R_GPI_IN0		0x44
+#define cwain_R_GPI_IN1		0x45
+#define cwain_R_GPI_IN2		0x46
+#define cwain_R_GPI_IN3		0x47
+#define cwain_R_GPIO_IN0	0x40
+#define cwain_R_GPIO_IN1	0x41
+#define cwain_R_INT_DATA	0x88
+#define cwain_R_IRQ_FIFO_BL0	0xC8
+#define cwain_R_IRQ_FIFO_BL1	0xC9
+#define cwain_R_IRQ_FIFO_BL2	0xCA
+#define cwain_R_IRQ_FIFO_BL3	0xCB
+#define cwain_R_IRQ_FIFO_BL4	0xCC
+#define cwain_R_IRQ_FIFO_BL5	0xCD
+#define cwain_R_IRQ_FIFO_BL6	0xCE
+#define cwain_R_IRQ_FIFO_BL7	0xCF
+#define cwain_R_IRQ_MISC	0x11
+#define cwain_R_IRQ_OVIEW	0x10
+#define cwain_R_JATT_STA	0x2B
+#define cwain_R_RAM_USE		0x15
+#define cwain_R_RX_SL0_0	0x25
+#define cwain_R_RX_SL0_1	0x26
+#define cwain_R_RX_SL0_2	0x27
+#define cwain_R_SA6_VAL13_ECH	0x39
+#define cwain_R_SA6_VAL13_ECL	0x38
+#define cwain_R_SA6_VAL23_ECH	0x3B
+#define cwain_R_SA6_VAL23_ECL	0x3A
+#define cwain_R_SLIP		0x2C
+#define cwain_R_STATUS		0x1C
+#define cwain_R_SYNC_STA	0x24
+#define cwain_R_VIO_ECH		0x33
+#define cwain_R_VIO_ECL		0x32
+
+
+/* Read/Write registers */
+#define cwain_A_FIFO_DATA0_NOINC	0x84
+#define cwain_A_FIFO_DATA0	0x80
+#define cwain_A_FIFO_DATA1_NOINC	0x84
+#define cwain_A_FIFO_DATA1	0x80
+#define cwain_A_FIFO_DATA2_NOINC	0x84
+#define cwain_A_FIFO_DATA2	0x80
+#define cwain_R_RAM_DATA	0xC0
+
+#define PCI_DEVICE_ID_CCD_E	0x30b1
+
+#define CLKDEL_TE	0xe	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0xc	/* CLKDEL in NT mode */
+
diff -urNad --exclude=CVS --exclude=.svn ./cwain/Makefile /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/Makefile
--- ./cwain/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/Makefile	2005-07-14 07:01:26.950442592 +0100
@@ -0,0 +1,90 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel-1.0.9/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel-1.0.9")
+
+HOSTCC=gcc
+
+CFLAGS+=-I. $(ZAP) -O4 -g -Wall #-DBLINKYBLINK
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP)
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+OBJS=cwain.o
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+MODULES=cwain
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+linux26:
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+obj-m := $(OBJS)
+
+cwain.o: cwain.c cwain.h 
+	$(CC) -c cwain.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	
+testlinux24: all
+	modprobe zaptel
+	insmod ./cwain.o
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod cwain zaptel
+
+testlinux26: all
+	modprobe zaptel
+	insmod ./cwain.ko
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 5
+	cat /proc/interrupts
+	rmmod cwain zaptel
+
+reload:	unload load
+load:	load$(BUILDVER)
+
+test:	test$(BUILDVER)
+
+
+loadlinux24: linux24
+	modprobe zaptel
+	insmod ./cwain.o
+	ztcfg -v
+
+loadlinux26: linux26
+	sync
+	modprobe zaptel
+	insmod ./cwain.ko debug=1
+	ztcfg -v
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 cwain.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/cwain.ko
+
+installlinux24:
+	install -D -m 644 cwain.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/cwain.o
+
+unload: 
+	rmmod cwain zaptel
diff -urNad --exclude=CVS --exclude=.svn ./cwain/TODO /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/TODO
--- ./cwain/TODO	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/cwain/TODO	2005-07-14 07:01:26.949442744 +0100
@@ -0,0 +1 @@
+
diff -urNad --exclude=CVS --exclude=.svn ./HARDWARE /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/HARDWARE
--- ./HARDWARE	2004-08-03 07:31:20.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/HARDWARE	2005-07-14 06:58:23.964260720 +0100
@@ -37,6 +37,13 @@
    * Wildcard TE410P - Quad T1/E1 switchable interface.  Supports PRI and 
      RBS signalling, as well as PPP, FR, and HDLC data modes.
 
+-- Junghanns.NET
+	http://www.junghanns.net
+	
+    * quadBRI PCI ISDN - 4port BRI ISDN interface, supports NT and TE mode
+    
+    * octoBRI PCI ISDN - 8port BRI ISDN interface, supports NT and TE mode
+
 Non-zaptel compatible hardware
 ==============================
 
diff -urNad --exclude=CVS --exclude=.svn ./include/asterisk/channel.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/channel.h
--- ./include/asterisk/channel.h	2005-06-14 19:41:48.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/channel.h	2005-07-14 07:00:16.302182760 +0100
@@ -34,6 +34,9 @@
 //! Max length of an extension
 #define AST_MAX_EXTENSION 80
 
+//! Max length of the uniqueid
+#define AST_MAX_UNIQUEID 64
+
 #include <asterisk/cdr.h>
 #include <asterisk/monitor.h>
 
@@ -52,6 +55,8 @@
 	int (*generate)(struct ast_channel *chan, void *data, int len, int samples);
 };
 
+extern ast_mutex_t uniquelock;			
+
 //! Main Channel structure associated with a channel.
 /*! 
  * This is the side of it mostly used by the pbx and call management.
@@ -186,6 +191,8 @@
 	/*! Private channel implementation details */
 	struct ast_channel_pvt *pvt;
 
+	/* isdn transfer capability */
+	unsigned short transfercapability;
 						
 	/*! Jump buffer used for returning from applications */
 	jmp_buf jmp[AST_CHANNEL_MAX_STACK];	
@@ -217,7 +224,7 @@
 	unsigned int fout;
 
 	/* Unique Channel Identifier */
-	char uniqueid[32];
+	char uniqueid[AST_MAX_UNIQUEID];
 
 	/* Why is the channel hanged up */
 	int hangupcause;
@@ -361,6 +368,8 @@
 #define AST_DEVICE_INVALID	4
 /*! Device is unavailable */
 #define AST_DEVICE_UNAVAILABLE	5
+/*! Device is ringing */
+#define AST_DEVICE_RINGING 	6
 
 //! Requests a channel
 /*! 
@@ -371,7 +380,7 @@
  * by the low level module
  * Returns an ast_channel on success, NULL on failure.
  */
-struct ast_channel *ast_request(char *type, int format, void *data);
+struct ast_channel *ast_request(char *type, int format, void *data, char *uniqueid);
 
 //! Search the Channels by Name
 /*!
@@ -405,9 +414,9 @@
  * Returns an ast_channel on success or no answer, NULL on failure.  Check the value of chan->_state
  * to know if the call was answered or not.
  */
-struct ast_channel *ast_request_and_dial(char *type, int format, void *data, int timeout, int *reason, char *callerid);
+struct ast_channel *ast_request_and_dial(char *type, int format, void *data, int timeout, int *reason, int callingpres, char *callerid, char *uniqueid);
 
-struct ast_channel *__ast_request_and_dial(char *type, int format, void *data, int timeout, int *reason, char *callerid, struct outgoing_helper *oh);
+struct ast_channel *__ast_request_and_dial(char *type, int format, void *data, int timeout, int *reason, int callingpres, char *callerid, struct outgoing_helper *oh, char *uniqueid);
 
 //! Registers a channel
 /*! 
@@ -638,6 +647,9 @@
 //! Get channel by name (locks channel)
 struct ast_channel *ast_get_channel_by_name_locked(char *channame);
 
+//! Get channel by uniqueid (locks channel)
+struct ast_channel *ast_get_channel_by_uniqueid_locked(char *uniqueid);
+
 //! Waits for a digit
 /*! 
  * \param c channel to wait for a digit on
@@ -709,6 +721,11 @@
    channel is hung up.  */
 int ast_channel_masquerade(struct ast_channel *original, struct ast_channel *clone);
 
+int ast_channel_masquerade_locked(struct ast_channel *original, struct ast_channel *clone);
+
+
+char *ast_alloc_uniqueid(void);
+
 //! Gives the string form of a given state
 /*! 
  * \param state state to get the name of
@@ -718,6 +735,15 @@
  */
 char *ast_state2str(int state);
 
+/*! Gives the string form of a given transfer capability */
+/*!
+ * \param transercapability transfercapabilty to get the name of
+ * Give a name to a transfercapbility
+ * See above
+ * Returns the text form of the binary transfer capbility
+ */
+char *ast_transfercapability2str(int transfercapability);
+
 /* Options: Some low-level drivers may implement "options" allowing fine tuning of the
    low level channel.  See frame.h for options.  Note that many channel drivers may support
    none or a subset of those features, and you should not count on this if you want your
diff -urNad --exclude=CVS --exclude=.svn ./include/asterisk/features.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/features.h
--- ./include/asterisk/features.h	2004-07-18 00:56:12.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/features.h	2005-07-14 07:00:22.330266352 +0100
@@ -38,10 +38,17 @@
 */
 extern int ast_masq_park_call(struct ast_channel *rchan, struct ast_channel *host, int timeout, int *extout);
 
+extern int ast_hold_call(struct ast_channel *chan, struct ast_channel *host);
+extern int ast_masq_hold_call(struct ast_channel *rchan, struct ast_channel *host);
+extern int ast_retrieve_call(struct ast_channel *chan, char *uniqueid);
+extern int ast_retrieve_call_to_death(char *uniqueid);
+extern struct ast_channel *ast_get_holded_call(char *uniqueid);
+
 //! Determine system parking extension
 /*! Returns the call parking extension for drivers that provide special
     call parking help */
 extern char *ast_parking_ext(void);
+extern char *ast_parking_con(void);
 extern char *ast_pickup_ext(void);
 
 //! Bridge a call, optionally allowing redirection
@@ -50,5 +57,7 @@
 
 extern int ast_pickup_call(struct ast_channel *chan);
 
+extern int ast_autoanswer_login(struct ast_channel *chan, void *data);
+extern int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data);
 
 #endif /* _AST_FEATURES_H */
diff -urNad --exclude=CVS --exclude=.svn ./include/asterisk/pbx.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/pbx.h
--- ./include/asterisk/pbx.h	2004-08-21 19:55:39.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/include/asterisk/pbx.h	2005-07-14 07:00:28.636307688 +0100
@@ -42,6 +42,8 @@
 #define AST_EXTENSION_BUSY		2
 //! All devices UNAVAILABLE/UNREGISTERED
 #define AST_EXTENSION_UNAVAILABLE 	3
+//! One ore more devices RINGING
+#define AST_EXTENSION_RINGING		4
 
 struct ast_context;
 struct ast_exten;     
@@ -103,6 +105,8 @@
  */
 extern struct ast_app *pbx_findapp(char *app);
 
+void *ast_pbx_run_app(void *data);
+
 //! executes an application
 /*!
  * \param c channel to execute on
@@ -487,11 +491,11 @@
 
 /* Synchronously or asynchronously make an outbound call and send it to a
    particular extension */
-int ast_pbx_outgoing_exten(char *type, int format, void *data, int timeout, char *context, char *exten, int priority, int *reason, int sync, char *callerid, char *variable, char *account );
+int ast_pbx_outgoing_exten(char *type, int format, void *data, int timeout, char *context, char *exten, int priority, int *reason, int sync, int callingpres, char *callerid, char *variable, char *account, char *uniqueid);
 
 /* Synchronously or asynchronously make an outbound call and send it to a
    particular application with given extension */
-int ast_pbx_outgoing_app(char *type, int format, void *data, int timeout, char *app, char *appdata, int *reason, int sync, char *callerid, char *variable, char *account);
+int ast_pbx_outgoing_app(char *type, int format, void *data, int timeout, char *app, char *appdata, int *reason, int sync, char *callerid, char *variable, char *account, char *uniqueid);
 
 /* Functions for returning values from structures */
 char *ast_get_context_name(struct ast_context *con);
diff -urNad --exclude=CVS --exclude=.svn ./ISDNguard/guard.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/ISDNguard/guard.c
--- ./ISDNguard/guard.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/ISDNguard/guard.c	2005-07-14 07:01:37.160890368 +0100
@@ -0,0 +1,205 @@
+/**
+ *
+ * ISDNguard Service Daemon
+ * 
+ * Copyright (C) 2005, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * large parts taken from pbx_wilcalu.c (Asterisk)
+ *
+ * Copyright (C) 1999, Mark Spencer
+ * Mark Spencer <markster@digium.com>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ *
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/poll.h>
+#include <sys/time.h>
+#include <errno.h>
+#include <pthread.h>
+
+#define AST_RUN_DIR "/var/run/"
+#define	PTHREAD_ATTR_STACKSIZE		2097152
+#define SLEEPTIME 400000
+#define MAX_DELAY SLEEPTIME * 2
+
+static  pthread_t heartbeat_thread;
+static  char buf[257];
+static  char lastbuf[257]; /* contains last partial buffer */
+static  char sendbuf[257];
+static	char fifoname[256];
+static	char devicename[256];
+static	pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
+static	struct timeval lastping;
+static	int isarmed = 1;
+
+static void *listen()
+{
+	char * sendbufptr=sendbuf;
+	int fd=open(fifoname,O_RDONLY|O_NONBLOCK);
+	struct pollfd fds[1];
+	int s;
+	
+	if(fd<0) {
+		printf("guard: unable to open fifo\n");
+		pthread_exit(NULL);
+	}
+	memset(buf,0,257);
+	memset(lastbuf,0,257);
+	memset(sendbuf,0,257);
+	while(1){
+		ssize_t bytes;
+		void *pass;
+
+		memset(buf,0,257);
+		fds[0].fd = fd;
+		fds[0].events = POLLIN;
+	        fds[0].revents = 0;
+		s = poll(fds, 1, -1);
+		if (!(fds[0].revents & POLLIN)) {
+		    close(fd);
+		    fd=open(fifoname,O_RDONLY|O_NONBLOCK);
+		    continue;
+		} 
+		
+		bytes=read(fd,buf,256);
+		buf[(int)bytes]=0;
+
+		if(bytes>0){
+			int x;
+			sendbufptr=sendbuf;
+			for(x=0; lastbuf[x]!=0 && x<257; x++);
+			if(x) {
+				memcpy(sendbuf, lastbuf, x);
+				sendbufptr+=x;
+				memset(lastbuf, 0, 257);
+			}
+			/* Process bytes read */
+			for(x=0; x<bytes; x++){
+				/* if \n then string is complete */
+				if(buf[x]=='\n'){
+					if(NULL!=(pass=(void *)strdup(sendbuf))){
+						if (!strncmp(sendbuf, "PING", sizeof(sendbuf))) {
+						    pthread_mutex_lock(&lock);
+						    gettimeofday(&lastping, NULL);
+						    pthread_mutex_unlock(&lock);						    
+						} else if (!strncmp(sendbuf, "AUTO", sizeof(sendbuf))) {
+						    pthread_mutex_lock(&lock);
+						    isarmed = 0;
+						    pthread_mutex_unlock(&lock);						    
+						} else if (!strncmp(sendbuf, "STOP", sizeof(sendbuf))) {
+						    pthread_mutex_lock(&lock);
+						    isarmed = 2;
+						    pthread_mutex_unlock(&lock);						    
+						} else if (!strncmp(sendbuf, "START", sizeof(sendbuf))) {
+						    pthread_mutex_lock(&lock);
+						    isarmed = 1;
+						    pthread_mutex_unlock(&lock);
+						}
+						sendbufptr=sendbuf;
+						memset(sendbuf, 0, 257);
+					} else {
+						perror("guard: Strdup failed");
+						close(fd);
+						pthread_exit(NULL);
+					}
+				} else {
+					if(buf[x]=='\n')
+						continue;
+					*sendbufptr=buf[x];
+					sendbufptr++;
+					*sendbufptr=0;
+				}
+			}
+			if(sendbufptr!=sendbuf)
+				memcpy(lastbuf, sendbuf, sendbufptr-sendbuf+1);
+		}
+	}
+	close(fd);
+	pthread_exit(NULL);
+	return NULL;
+}
+
+static void *heartbeat(void *ignore)
+{
+	char command[10];
+	int fd = -1;
+	unsigned long dusec = 0;
+	fd = open(devicename, O_WRONLY | O_SYNC);
+	struct timeval nowtime;
+	while(1){
+	    gettimeofday(&nowtime, NULL);
+	    pthread_mutex_lock(&lock);
+	    dusec = (nowtime.tv_sec - lastping.tv_sec) * 1000000;
+	    dusec += (nowtime.tv_usec - lastping.tv_usec); 
+	    snprintf((char *)command, sizeof(command), "_%d", (int) nowtime.tv_sec + (int) dusec);
+	    switch (isarmed) {
+		case 0:
+		    write(fd, command, sizeof(command));
+		    break;
+		case 1:
+		    if (dusec <= MAX_DELAY) {
+			write(fd, command, sizeof(command));
+		    }
+		    break;
+	    }
+	    pthread_mutex_unlock(&lock);
+	    usleep(SLEEPTIME);
+	}
+	close(fd);
+	pthread_exit(NULL);
+}
+
+
+int main(int argc, char *argv[])
+{
+	int res;
+	pthread_attr_t *attr;
+	pthread_attr_t lattr;
+	
+	if (argc < 2) {
+	    printf("\nUsage: guard <device> [AUTO|STOP]\n\n");
+	    return(0);
+	} 
+	
+	snprintf((char *)fifoname, sizeof(fifoname), "%s/%s", AST_RUN_DIR, "guard.ctl");
+	res = mkfifo(fifoname, 0700);
+	if (res) {
+	    if(errno != EEXIST){
+		printf("Error creating fifo!\n");
+		return 0;
+	    }
+	}
+
+	lastping.tv_sec = 0;
+	lastping.tv_usec = 0;
+	
+	if (argc > 2) {
+	    if (!strncmp("AUTO", argv[2], sizeof(argv[2]))) {
+		isarmed = 0;
+	    } else if (!strncmp("STOP", argv[2], sizeof(argv[2]))) {
+		isarmed = 2;
+	    }
+	}
+	pthread_attr_init(&lattr);
+	attr = &lattr;
+	errno = pthread_attr_setstacksize(attr, PTHREAD_ATTR_STACKSIZE);
+	if (errno) {
+	    printf("pthread_attr_setstacksize returned non-zero: %s\n", strerror(errno));
+	}
+	snprintf((char *)devicename, sizeof(devicename), "%s", argv[1]);
+	pthread_create(&heartbeat_thread, attr, heartbeat, NULL); 
+	listen();
+	return 0;
+}
+
diff -urNad --exclude=CVS --exclude=.svn ./ISDNguard/Makefile /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/ISDNguard/Makefile
--- ./ISDNguard/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/ISDNguard/Makefile	2005-07-14 07:01:37.159890520 +0100
@@ -0,0 +1,12 @@
+CFLAGS+=-O2 -Wall -pthread -I.
+
+all: guard
+
+guard: guard.c 
+	$(CC) guard.c $(CFLAGS) -o ISDNguard
+
+clean:	
+	rm -f ISDNguard *.o *~
+
+install: guard
+	install -m 755 ISDNguard /usr/sbin
diff -urNad --exclude=CVS --exclude=.svn ./Makefile /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/Makefile
--- ./Makefile	2005-04-26 15:30:23.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/Makefile	2005-07-14 07:00:41.347375312 +0100
@@ -473,6 +473,8 @@
 	echo "astspooldir => $(ASTSPOOLDIR)" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
 	echo "astrundir => $(ASTVARRUNDIR)" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
 	echo "astlogdir => $(ASTLOGDIR)" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
+	echo "[options]" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
+	echo "uniquename = asterisk" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
 	for x in sounds/demo-*; do \
 		if grep -q "^%`basename $$x`%" sounds.txt; then \
 			install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/sounds ; \
diff -urNad --exclude=CVS --exclude=.svn ./Makefile.rej /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/Makefile.rej
--- ./Makefile.rej	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/Makefile.rej	2005-07-14 07:00:41.347375312 +0100
@@ -0,0 +1,17 @@
+***************
+*** 12,18 ****
+  #
+  
+  MODS=res_adsi.so res_features.so res_crypto.so res_musiconhold.so res_indications.so res_monitor.so \
+-      res_agi.so
+  MODS+=$(shell if [ -f "/usr/include/odbcinst.h" ]; then echo "res_odbc.so res_config_odbc.so"; fi)
+  MODS+=$(shell if [ -f "/usr/local/include/odbcinst.h" ]; then echo "res_odbc.so res_config_odbc.so"; fi)
+  MODS+=$(shell if [ -f "/usr/include/osp/osp.h" ]; then echo "res_osp.so"; fi)
+--- 12,18 ----
+  #
+  
+  MODS=res_adsi.so res_features.so res_crypto.so res_musiconhold.so res_indications.so res_monitor.so \
++      res_agi.so res_watchdog.so
+  MODS+=$(shell if [ -f "/usr/include/odbcinst.h" ]; then echo "res_odbc.so res_config_odbc.so"; fi)
+  MODS+=$(shell if [ -f "/usr/local/include/odbcinst.h" ]; then echo "res_odbc.so res_config_odbc.so"; fi)
+  MODS+=$(shell if [ -f "/usr/include/osp/osp.h" ]; then echo "res_osp.so"; fi)
diff -urNad --exclude=CVS --exclude=.svn ./manager.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/manager.c
--- ./manager.c	2005-04-15 08:15:39.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/manager.c	2005-07-14 07:00:28.726294008 +0100
@@ -9,6 +9,9 @@
  *
  * Mark Spencer <markster@digium.com>
  *
+ * Copyright (C) 2003-2004, Junghanns.NET Gmbh
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  */
@@ -40,6 +43,7 @@
 #include <asterisk/md5.h>
 #include <asterisk/acl.h>
 #include <asterisk/utils.h>
+#include <asterisk/astdb.h>
 
 struct fast_originate_helper
 {
@@ -55,6 +59,8 @@
 	char exten[256];
 	char idtext[256];
 	int priority;
+	int callingpres;
+	char uniqueid[64];
 };
 
 static int enabled = 0;
@@ -553,18 +559,17 @@
 {
 	struct ast_channel *c = NULL;
 	char *name = astman_get_header(m, "Channel");
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "No channel specified");
+	char *uniqueid = astman_get_header(m, "Uniqueid");
+	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+		astman_send_error(s, m, "No channel or uniqueid specified");
 		return 0;
 	}
-	c = ast_channel_walk_locked(NULL);
-	while(c) {
-		if (!strcasecmp(c->name, name)) {
-			break;
-		}
-		ast_mutex_unlock(&c->lock);
-		c = ast_channel_walk_locked(c);
-	}
+	if (!ast_strlen_zero(uniqueid)) {
+		c = ast_get_channel_by_uniqueid_locked(uniqueid);
+	} else {
+	    if (!ast_strlen_zero(name))
+		c = ast_get_channel_by_name_locked(name);
+	}	
 	if (!c) {
 		astman_send_error(s, m, "No such channel");
 		return 0;
@@ -669,6 +674,120 @@
 	return 0;
 }
 
+static char mandescr_dbget[] = 
+"Description: Get a value from astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n";
+
+static int action_dbget(struct mansession *s, struct message *m)
+{
+        char *family = astman_get_header(m, "Family");
+        char *key = astman_get_header(m, "Key");
+	char *id = astman_get_header(m,"ActionID");
+	char dbresult[256];
+
+	if (!strlen(family)) {
+		astman_send_error(s, m, "No family specified");
+		return 0;
+	}
+	if (!strlen(key)) {
+		astman_send_error(s, m, "No key specified");
+		return 0;
+	}
+
+	ast_mutex_lock(&s->lock);
+	if (ast_db_get(family, key, dbresult, sizeof(dbresult) - 1)) {
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	} else {
+	    ast_cli(s->fd, "Response: Success\r\n"
+		"Value: %s\r\n" ,dbresult);
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+	ast_mutex_unlock(&s->lock);
+
+	return 0;
+}
+
+static char mandescr_dbput[] = 
+"Description: Put a value into astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n"
+"	Value: ...\n";
+
+static int action_dbput(struct mansession *s, struct message *m)
+{
+        char *family = astman_get_header(m, "Family");
+        char *key = astman_get_header(m, "Key");
+        char *value = astman_get_header(m, "Value");
+	char *id = astman_get_header(m,"ActionID");
+
+	if (!strlen(family)) {
+		astman_send_error(s, m, "No family specified");
+		return 0;
+	}
+	if (!strlen(key)) {
+		astman_send_error(s, m, "No key specified");
+		return 0;
+	}
+	if (!strlen(value)) {
+		astman_send_error(s, m, "No value specified");
+		return 0;
+	}
+
+	ast_mutex_lock(&s->lock);
+	if (ast_db_put(family, key, value)) {
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	} else {
+	    ast_cli(s->fd, "Response: Success\r\n");
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+	ast_mutex_unlock(&s->lock);
+
+	return 0;
+}
+
+
+static char mandescr_dbdel[] = 
+"Description: remove value from astdb\n"
+"Variables: \n"
+"	Family: ...\n"
+"	Key: ...\n";
+
+static int action_dbdel(struct mansession *s, struct message *m)
+{
+        char *family = astman_get_header(m, "Family");
+        char *key = astman_get_header(m, "Key");
+	char *id = astman_get_header(m,"ActionID");
+
+	if (!strlen(family)) {
+		astman_send_error(s, m, "No family specified");
+		return 0;
+	}
+	if (!strlen(key)) {
+		astman_send_error(s, m, "No key specified");
+		return 0;
+	}
+
+	ast_mutex_lock(&s->lock);
+	if (ast_db_del(family, key)) {
+	    ast_cli(s->fd, "Response: Failed\r\n");
+	} else {
+	    ast_cli(s->fd, "Response: Success\r\n");
+	}
+	if (id && !ast_strlen_zero(id))
+		ast_cli(s->fd, "ActionID: %s\r\n",id);
+	ast_cli(s->fd, "\r\n");
+	ast_mutex_unlock(&s->lock);
+
+	return 0;
+}
+
 
 static int action_status(struct mansession *s, struct message *m)
 {
@@ -761,32 +880,50 @@
 {
 	char *name = astman_get_header(m, "Channel");
 	char *name2 = astman_get_header(m, "ExtraChannel");
+	char *uniqueid = astman_get_header(m, "Uniqueid");
+	char *uniqueid2 = astman_get_header(m, "ExtraUniqueid");
 	char *exten = astman_get_header(m, "Exten");
 	char *context = astman_get_header(m, "Context");
 	char *priority = astman_get_header(m, "Priority");
+	char *exten2 = astman_get_header(m, "ExtraExten");
+	char *context2 = astman_get_header(m, "ExtraContext");
+	char *priority2 = astman_get_header(m, "ExtraPriority");
 	struct ast_channel *chan, *chan2 = NULL;
 	int pi = 0;
+	int pi2 = 0;
 	int res;
-	if (!name || ast_strlen_zero(name)) {
-		astman_send_error(s, m, "Channel not specified");
+	if ((!name || ast_strlen_zero(name)) && (!uniqueid || ast_strlen_zero(uniqueid))) {
+		astman_send_error(s, m, "Channel or Uniqueid not specified");
 		return 0;
 	}
 	if (!ast_strlen_zero(priority) && (sscanf(priority, "%d", &pi) != 1)) {
 		astman_send_error(s, m, "Invalid priority\n");
 		return 0;
 	}
-	chan = ast_get_channel_by_name_locked(name);
+	if (uniqueid && (!ast_strlen_zero(uniqueid))) {
+	    chan = ast_get_channel_by_uniqueid_locked(uniqueid);
+	} else {
+	    chan = ast_get_channel_by_name_locked(name);
+	}
 	if (!chan) {
-		astman_send_error(s, m, "Channel not existent");
+		astman_send_error(s, m, "Channel not existant");
 		return 0;
 	}
+	if (!ast_strlen_zero(uniqueid2)) {
+		chan2 = ast_get_channel_by_uniqueid_locked(uniqueid2);
+		if (!ast_strlen_zero(priority2) && (sscanf(priority, "%d", &pi2) != 1)) {
+		    astman_send_error(s, m, "Invalid priority2\n");
+		    return 0;
+		}
+	} else {
 	if (!ast_strlen_zero(name2))
 		chan2 = ast_get_channel_by_name_locked(name2);
+	}
 	res = ast_async_goto(chan, context, exten, pi);
 	if (!res) {
-		if (!ast_strlen_zero(name2)) {
+		if ((!ast_strlen_zero(name2)) || (!ast_strlen_zero(uniqueid2))){
 			if (chan2)
-				res = ast_async_goto(chan2, context, exten, pi);
+				res = ast_async_goto(chan2, context2, exten2, pi2);
 			else
 				res = -1;
 			if (!res)
@@ -834,26 +971,28 @@
 	int res;
 	int reason = 0;
 	if (!ast_strlen_zero(in->app)) {
-		res = ast_pbx_outgoing_app(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, !ast_strlen_zero(in->callerid) ? in->callerid : NULL, in->variable, in->account);
+		res = ast_pbx_outgoing_app(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, !ast_strlen_zero(in->callerid) ? in->callerid : NULL, in->variable, in->account, in->uniqueid);
 	} else {
-		res = ast_pbx_outgoing_exten(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, !ast_strlen_zero(in->callerid) ? in->callerid : NULL, in->variable, in->account);
+		res = ast_pbx_outgoing_exten(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, in->callingpres, !ast_strlen_zero(in->callerid) ? in->callerid : NULL, in->variable, in->account, in->uniqueid);
 	}   
 	if (!res)
 		manager_event(EVENT_FLAG_CALL,
 			"OriginateSuccess",
 			"%s"
+			"Uniqueid: %s\r\n"
 			"Channel: %s/%s\r\n"
 			"Context: %s\r\n"
 			"Exten: %s\r\n",
-			in->idtext, in->tech, in->data, in->context, in->exten);
+			in->idtext, in->uniqueid, in->tech, in->data, in->context, in->exten);
 	else
 		manager_event(EVENT_FLAG_CALL,
 			"OriginateFailure",
 			"%s"
+			"Uniqueid: %s\r\n"
 			"Channel: %s/%s\r\n"
 			"Context: %s\r\n"
 			"Exten: %s\r\n",
-			in->idtext, in->tech, in->data, in->context, in->exten);
+			in->idtext, in->uniqueid, in->tech, in->data, in->context, in->exten);
 
 	free(in);
 	return NULL;
@@ -871,6 +1010,7 @@
 "	Data: Data to use (requires 'Application')\n"
 "	Timeout: How long to wait for call to be answered (in ms)\n"
 "	CallerID: Caller ID to be set on the outgoing channel\n"
+"	CallingPres: Caller ID presentation to be set on the outgoing channel\n"
 "	Variable: Channel variable to set (VAR1=value1|VAR2=value2)\n"
 "	Account: Account code\n"
 "	Async: Set to 'true' for fast origination\n";
@@ -883,6 +1023,7 @@
 	char *priority = astman_get_header(m, "Priority");
 	char *timeout = astman_get_header(m, "Timeout");
 	char *callerid = astman_get_header(m, "CallerID");
+	char *callingpres = astman_get_header(m, "CallingPres");
     	char *variable = astman_get_header(m, "Variable");
     	char *account = astman_get_header(m, "Account");
 	char *app = astman_get_header(m, "Application");
@@ -890,11 +1031,14 @@
 	char *async = astman_get_header(m, "Async");
 	char *id = astman_get_header(m, "ActionID");
 	char *tech, *data;
+	char *uniqueid;
 	int pi = 0;
+	int cpresi = 0;
 	int res;
 	int to = 30000;
 	int reason = 0;
 	char tmp[256];
+	char idText[256] = "";
 	pthread_t th;
 	pthread_attr_t attr;
 	if (!name) {
@@ -909,6 +1053,10 @@
 		astman_send_error(s, m, "Invalid timeout\n");
 		return 0;
 	}
+	if (!ast_strlen_zero(callingpres) && (sscanf(callingpres, "%d", &cpresi) != 1)) {
+		astman_send_error(s, m, "Invalid CallingPres\n");
+		return 0;
+	}
 	strncpy(tmp, name, sizeof(tmp) - 1);
 	tech = tmp;
 	data = strchr(tmp, '/');
@@ -918,6 +1066,7 @@
 	}
 	*data = '\0';
 	data++;
+	uniqueid = ast_alloc_uniqueid();
 	if (ast_true(async)) {
 		struct fast_originate_helper *fast = malloc(sizeof(struct fast_originate_helper));
 		if (!fast) {
@@ -935,8 +1084,10 @@
 			strncpy(fast->account, account, sizeof(fast->account) - 1);
 			strncpy(fast->context, context, sizeof(fast->context) - 1);
 			strncpy(fast->exten, exten, sizeof(fast->exten) - 1);
+			strncpy(fast->uniqueid, uniqueid, sizeof(fast->uniqueid) - 1);
 			fast->timeout = to;
 			fast->priority = pi;
+			fast->callingpres = cpresi;
 			pthread_attr_init(&attr);
 			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 			if (ast_pthread_create(&th, &attr, fast_originate, fast)) {
@@ -946,19 +1097,30 @@
 			}
 		}
 	} else if (!ast_strlen_zero(app)) {
-        	res = ast_pbx_outgoing_app(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 1, !ast_strlen_zero(callerid) ? callerid : NULL, variable, account);
+		res = ast_pbx_outgoing_app(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 0, !ast_strlen_zero(callerid) ? callerid : NULL, variable, account, uniqueid);
     	} else {
 		if (exten && context && pi)
-	        	res = ast_pbx_outgoing_exten(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 1, !ast_strlen_zero(callerid) ? callerid : NULL, variable, account);
+	        	res = ast_pbx_outgoing_exten(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 0, cpresi, !ast_strlen_zero(callerid) ? callerid : NULL, variable, account, uniqueid);
 		else {
 			astman_send_error(s, m, "Originate with 'Exten' requires 'Context' and 'Priority'");
 			return 0;
 		}
 	}   
-	if (!res)
-		astman_send_ack(s, m, "Originate successfully queued");
-	else
-		astman_send_error(s, m, "Originate failed");
+	if (!res) {
+	        if (id && !ast_strlen_zero(id)) {
+         	    snprintf(idText,256,"ActionID: %s\r\n",id);
+ 		}
+		ast_mutex_lock(&s->lock);
+		ast_cli(s->fd, "Response: Success\r\n"
+				    "%s"
+				   "Message: Originate successfully queued\r\n"
+				   "Uniqueid: %s\r\n"
+				   "\r\n",
+				    idText, uniqueid);
+		ast_mutex_unlock(&s->lock);
+	} else {
+ 		astman_send_error(s, m, "Originate failed");
+	}
 	return 0;
 }
 
@@ -1464,6 +1626,9 @@
 		ast_manager_register2( "AbsoluteTimeout", EVENT_FLAG_CALL, action_timeout, "Set Absolute Timeout", mandescr_timeout );
 		ast_manager_register2( "MailboxStatus", EVENT_FLAG_CALL, action_mailboxstatus, "Check Mailbox", mandescr_mailboxstatus );
 		ast_manager_register2( "MailboxCount", EVENT_FLAG_CALL, action_mailboxcount, "Check Mailbox Message Count", mandescr_mailboxcount );
+ 		ast_manager_register2( "DBget", EVENT_FLAG_CALL, action_dbget, "Retrieve a value from astdb", mandescr_dbget );
+ 		ast_manager_register2( "DBput", EVENT_FLAG_CALL, action_dbput, "Store a value in astdb", mandescr_dbput );
+ 		ast_manager_register2( "DBdel", EVENT_FLAG_CALL, action_dbdel, "Delete a key from astdb", mandescr_dbdel );
 		ast_manager_register2("ListCommands", 0, action_listcommands, "List available manager commands", mandescr_listcommands);
 
 		ast_cli_register(&show_mancmd_cli);
diff -urNad --exclude=CVS --exclude=.svn ./pbx/pbx_spool.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx/pbx_spool.c
--- ./pbx/pbx_spool.c	2005-04-02 18:41:19.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx/pbx_spool.c	2005-07-14 07:00:34.600401008 +0100
@@ -219,11 +219,11 @@
 	if (!ast_strlen_zero(o->app)) {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for application %s(%s) (Retry %d)\n", o->tech, o->dest, o->app, o->data, o->retries);
-		res = ast_pbx_outgoing_app(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->app, o->data, &reason, 2 /* wait to finish */, o->callerid, o->variable, o->account);
+		res = ast_pbx_outgoing_app(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->app, o->data, &reason, 2 /* wait to finish */, o->callerid, o->variable, o->account, NULL);
 	} else {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Attempting call on %s/%s for %s@%s:%d (Retry %d)\n", o->tech, o->dest, o->exten, o->context,o->priority, o->retries);
-		res = ast_pbx_outgoing_exten(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->context, o->exten, o->priority, &reason, 2 /* wait to finish */, o->callerid, o->variable, o->account);
+		res = ast_pbx_outgoing_exten(o->tech, AST_FORMAT_SLINEAR, o->dest, o->waittime * 1000, o->context, o->exten, o->priority, &reason, 2 /* wait to finish */, 0, o->callerid, o->variable, o->account, NULL);
 	}
 	if (res) {
 		ast_log(LOG_NOTICE, "Call failed to go through, reason %d\n", reason);
diff -urNad --exclude=CVS --exclude=.svn ./pbx/pbx_wilcalu.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx/pbx_wilcalu.c
--- ./pbx/pbx_wilcalu.c	2004-08-08 18:15:02.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx/pbx_wilcalu.c	2005-07-14 07:00:41.343375920 +0100
@@ -192,7 +192,7 @@
 	}
 	ast_log(LOG_DEBUG, "Autodial Tech %s(%d) Tele %s(%d) Filename %s(%d)\n",tech, (int)strlen(tech), tele, (int)strlen(tele), filename, (int)strlen(filename));
 
-	channel=ast_request(tech,AST_FORMAT_SLINEAR,tele);
+	channel=ast_request(tech,AST_FORMAT_SLINEAR,tele,NULL);
 	if(channel!=NULL){
 		ast_call(channel,tele,10000);
 	} else {
diff -urNad --exclude=CVS --exclude=.svn ./pbx.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx.c
--- ./pbx.c	2005-06-14 19:41:48.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/pbx.c	2005-07-14 07:00:41.346375464 +0100
@@ -267,7 +267,8 @@
 	
 	{ "Hangup", pbx_builtin_hangup,
 	"Unconditional hangup",
-	"  Hangup(): Unconditionally hangs up a given channel by returning -1 always.\n" 
+	"  Hangup(Cause): Unconditionally hangs up a given channel by returning -1 always.\n" 
+	"                 If cause is given, it will set the hangup cause accordingly.\n" 
 	},
 
 	{ "NoOp", pbx_builtin_noop,
@@ -1388,12 +1389,15 @@
 	
 		res = ast_device_state(cur);
 		switch (res) {
+		case AST_DEVICE_RINGING:
+ 			return AST_EXTENSION_RINGING;
     		case AST_DEVICE_NOT_INUSE:
 			allunavailable = 0;
 			allbusy = 0;
 			break;
     		case AST_DEVICE_INUSE:
-			return AST_EXTENSION_INUSE;
+			allbusy = 0;
+	//		return AST_EXTENSION_INUSE;
     		case AST_DEVICE_BUSY:
 			allunavailable = 0;
 			allfree = 0;
@@ -4063,7 +4067,7 @@
 	return NULL;
 }
 
-int ast_pbx_outgoing_exten(char *type, int format, void *data, int timeout, char *context, char *exten, int priority, int *reason, int sync, char *callerid, char *variable, char *account)
+int ast_pbx_outgoing_exten(char *type, int format, void *data, int timeout, char *context, char *exten, int priority, int *reason, int sync, int callingpres, char *callerid, char *variable, char *account, char *uniqueid)
 {
 	struct ast_channel *chan;
 	struct async_stat *as;
@@ -4074,7 +4078,7 @@
 		
 	if (sync) {
 		LOAD_OH(oh);
-		chan = __ast_request_and_dial(type, format, data, timeout, reason, callerid, &oh);
+		chan = __ast_request_and_dial(type, format, data, timeout, reason, callingpres, callerid, &oh, uniqueid);
 		if (chan) {
 			pbx_builtin_setaccount(chan, account);
 			if (chan->_state == AST_STATE_UP) {
@@ -4129,7 +4133,7 @@
 		if (!as)
 			return -1;
 		memset(as, 0, sizeof(struct async_stat));
-		chan = ast_request_and_dial(type, format, data, timeout, reason, callerid);
+		chan = ast_request_and_dial(type, format, data, timeout, reason, callingpres, callerid, uniqueid);
 		if (!chan) {
 			free(as);
 			return -1;
@@ -4165,7 +4169,7 @@
 	pthread_t t;
 };
 
-static void *ast_pbx_run_app(void *data)
+void *ast_pbx_run_app(void *data)
 {
 	struct app_tmp *tmp = data;
 	struct ast_app *app;
@@ -4181,7 +4185,7 @@
 	return NULL;
 }
 
-int ast_pbx_outgoing_app(char *type, int format, void *data, int timeout, char *app, char *appdata, int *reason, int sync, char *callerid, char *variable, char *account)
+int ast_pbx_outgoing_app(char *type, int format, void *data, int timeout, char *app, char *appdata, int *reason, int sync, char *callerid, char *variable, char *account, char *uniqueid)
 {
 	struct ast_channel *chan;
 	struct async_stat *as;
@@ -4193,7 +4197,7 @@
 	if (!app || ast_strlen_zero(app))
 		return -1;
 	if (sync) {
-		chan = ast_request_and_dial(type, format, data, timeout, reason, callerid);
+		chan = ast_request_and_dial(type, format, data, timeout, reason, 0, callerid, uniqueid);
 		if (chan) {
 			pbx_builtin_setaccount(chan, account);
 			if (variable) {
@@ -4239,7 +4243,7 @@
 		if (!as)
 			return -1;
 		memset(as, 0, sizeof(struct async_stat));
-		chan = ast_request_and_dial(type, format, data, timeout, reason, callerid);
+		chan = ast_request_and_dial(type, format, data, timeout, reason, 0, callerid, uniqueid);
 		if (!chan) {
 			free(as);
 			return -1;
@@ -4453,6 +4457,9 @@
 
 static int pbx_builtin_hangup(struct ast_channel *chan, void *data)
 {
+        /* Copy the hangup cause as specified */
+        if (data)
+	       chan->hangupcause = atoi(data);
 	/* Just return non-zero and it will hang up */
 	return -1;
 }
@@ -4854,6 +4861,9 @@
                    return -1;
 		}
 	}
+	if (chan->_state != AST_STATE_UP) {
+	    ast_answer(chan);
+	}
 	return res = ast_say_number(chan, atoi((char *) tmp), "", chan->language, options);
 }
 
@@ -4861,8 +4871,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_digit_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
@@ -4870,8 +4884,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_character_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
@@ -4879,8 +4897,12 @@
 {
 	int res = 0;
 
-	if (data)
+	if (data) {
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
 		res = ast_say_phonetic_str(chan, (char *)data, "", chan->language);
+	}
 	return res;
 }
 	
diff -urNad --exclude=CVS --exclude=.svn ./qozap/Makefile /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/Makefile
--- ./qozap/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/Makefile	2005-07-14 07:01:09.223137552 +0100
@@ -0,0 +1,91 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel-1.0.9/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel-1.0.9")
+
+HOSTCC=gcc
+
+CFLAGS+=-I. $(ZAP) -O4 -g -Wall -DBUILDING_TONEZONE  #-DTONEZONE_DRIVER
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP)
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+OBJS=qozap.o
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+MODULES=qozap
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+linux26:
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+obj-m := $(OBJS)
+
+qozap.o: qozap.c qozap.h 
+	$(CC) -c qozap.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	rm -rf .tmp_versions
+
+testlinux24: all
+	modprobe zaptel
+	insmod ./qozap.o
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod qozap zaptel
+
+testlinux26: all
+	modprobe zaptel
+	insmod ./qozap.ko
+	ztcfg -v
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod qozap zaptel
+
+reload:	unload load
+load:	load$(BUILDVER)
+
+test:	test$(BUILDVER)
+
+
+loadlinux24: linux24
+	modprobe zaptel
+	insmod ./qozap.o
+	ztcfg -v
+
+loadlinux26: linux26
+	sync
+	modprobe zaptel
+	insmod ./qozap.ko
+	ztcfg -v
+
+unload: 
+	rmmod qozap zaptel
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 qozap.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/qozap.ko
+
+installlinux24:
+	install -D -m 644 qozap.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/qozap.o
diff -urNad --exclude=CVS --exclude=.svn ./qozap/qozap.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/qozap.c
--- ./qozap/qozap.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/qozap.c	2005-07-14 07:01:09.222137704 +0100
@@ -0,0 +1,1248 @@
+/*
+ * qozap.c - Zaptel driver for the quadBRI PCI ISDN card
+ * and the octoBRI PCI ISDN card!
+ *
+ * Copyright (C) 2003, 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <zaptel.h>
+#include "qozap.h"
+
+#if CONFIG_PCI
+
+static int doubleclock=0;
+static int ports=-1; /* autodetect */
+static int debug=0;
+static struct qoz_card *qoz_dev_list = NULL;
+static int qoz_dev_count = 0;
+static int totalBRIs = 0;
+static struct pci_dev *multi_qoz = NULL;
+static spinlock_t registerlock = SPIN_LOCK_UNLOCKED;
+
+static int ztqoz_shutdown(struct zt_span *span);
+
+int qoz_waitbusy(struct qoz_card *qoztmp) {
+    int x=1000;
+    while (x-- && (qoz_inb(qoztmp,qoz_R_STATUS) & 1));
+    if (x < 0) {
+	return -1;
+    } else {
+	return 0;
+    }
+}
+
+void qoz_shutdownCard(struct qoz_card *qoztmp) {
+    int s=0;
+    unsigned long flags;
+    int stports=0;
+    if (qoztmp == NULL) {
+	printk(KERN_INFO "qozap: shutting down NULL card!\n");
+	return;
+    }
+
+    if (qoztmp->pci_io == NULL) {
+	return;
+    }
+
+    if (debug)
+	printk(KERN_INFO "qozap: shutting down card %d (cardID %d) at %p.\n",qoztmp->cardno,qoztmp->cardID,qoztmp->pci_io);
+    if (qoztmp->ztdev != NULL) {
+	stports = qoztmp->stports;
+	for (s=0; s < stports; s++) {
+	    if(qoztmp->ztdev->spans[s].flags & ZT_FLAG_RUNNING) {
+		ztqoz_shutdown(&qoztmp->ztdev->spans[s]);
+		if (debug)
+		    printk(KERN_INFO "qozap: shutdown card %d span %d.\n",qoztmp->cardno,s+1);
+	    }
+	    if(qoztmp->ztdev->spans[s].flags & ZT_FLAG_REGISTERED) {
+		zt_unregister(&qoztmp->ztdev->spans[s]);
+		if (debug)
+		    printk(KERN_INFO "qozap: unregistered card %d span %d.\n",qoztmp->cardno,s+1);
+	    }
+	}
+	kfree(qoztmp->ztdev);
+	qoztmp->ztdev = NULL;
+    }
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+
+    // turn off irqs
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+    qoz_outb(qoztmp,qoz_R_IRQMSK_MISC, 0); 
+    qoz_outb(qoztmp,qoz_R_SCI_MSK, 0); 
+
+    free_irq(qoztmp->irq,qoztmp);
+
+    // softreset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x8);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    qoz_outb(qoztmp,qoz_R_IRQMSK_MISC, 0); 
+    qoz_outb(qoztmp,qoz_R_SCI_MSK, 0); 
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+    iounmap((void *) qoztmp->pci_io);
+    qoztmp->pci_io = NULL;
+
+    if (qoztmp->pcidev != NULL) {
+        pci_disable_device(qoztmp->pcidev);
+    }
+    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, 0);	// disable memio
+    
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+}
+
+void qoz_doLEDs(struct qoz_card *qoztmp) {
+    if ((qoztmp->type == 0xb520) && (qoztmp->stports == 4)){
+//	if ((qoztmp->ticks > 0) && (qoztmp->ticks <= 300)) {
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x20 | 0x10);
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0xf);
+	    qoz_outb(qoztmp,qoz_R_GPIO_OUT1,(qoztmp->leds[0] | (qoztmp->leds[1] << 1) | (qoztmp->leds[2] << 2) | (qoztmp->leds[3] << 3)));
+/*	}
+	if ((qoztmp->ticks > 300) && (qoztmp->ticks <= 600)) {
+    	    qoz_outb(qoztmp,qoz_R_GPIO_EN1,0x0);
+	} */
+    }
+}
+
+void qoz_resetCard(struct qoz_card *qoztmp) {
+    unsigned long flags;
+    unsigned char i=0;
+    spin_lock_irqsave(&(qoztmp->lock),flags);
+    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+    
+    // soft reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x8);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    // fifo reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x10);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    // s/t reset
+    qoz_outb(qoztmp,qoz_R_CIRM,0x40);
+    qoz_outb(qoztmp,qoz_R_CIRM,0x0); 
+    qoz_waitbusy(qoztmp);
+
+    // set S0 amplitude
+    qoz_outb(qoztmp,qoz_R_PWM_MD,0xa0);
+    qoz_outb(qoztmp,qoz_R_PWM1,0x19);
+
+    // set up the timer
+    qoz_outb(qoztmp,qoz_R_TI_WD, 0x2); // 1 ms 
+    qoz_outb(qoztmp,qoz_R_IRQMSK_MISC, 0x2); 
+    qoz_outb(qoztmp,qoz_R_PCM_MD0, 0x1);
+
+    // all state changes
+    qoz_outb(qoztmp,qoz_R_SCI_MSK, 0xff); 
+
+    if (qoztmp->type == 0xb552) {
+        qoz_outb(qoztmp,qoz_R_FIFO_MD,0x16);
+    } else {
+        qoz_outb(qoztmp,qoz_R_FIFO_MD,0x26);
+    }
+
+    // double clock
+    if (doubleclock == 1) {
+	// hopefully you have set CLK_MODE correctly!
+	qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+    } else {
+	if (qoztmp->type == 0x08b4) {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x0); 
+	} else {
+	    qoz_outb(qoztmp,qoz_R_BRG_PCM_CFG,0x20); 
+	}
+    }
+    qoz_outb(qoztmp,qoz_R_CTRL,0x0); 
+
+    // LEDs RED
+    qoztmp->leds[0] = 0x0;
+    qoztmp->leds[1] = 0x0;
+    qoztmp->leds[2] = 0x0;
+    qoztmp->leds[3] = 0x0;
+    qoztmp->leds[4] = 0x0;
+    qoztmp->leds[5] = 0x0;
+    qoztmp->leds[6] = 0x0;
+    qoztmp->leds[7] = 0x0;
+
+    /* Finally enable IRQ output */
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0x8 | 0x1); 
+    if (qoztmp->type == 0xb552) {
+	qoztmp->stports = 8;
+    } else {
+	qoztmp->stports = 4;
+    }
+    qoztmp->ticks = 0;
+    qoztmp->clicks = 0;
+
+    for (i=0;i<qoztmp->stports;i++) {
+	if (qoztmp->st[i].nt_mode) {
+	    qoz_outb(qoztmp,qoz_R_ST_SYNC,0x8 | i);
+	    break;
+	}
+    }
+    if (i != qoztmp->stports) {
+	qoz_outb(qoztmp,qoz_R_ST_SYNC,0x0);
+    }
+    spin_unlock_irqrestore(&(qoztmp->lock),flags);
+}
+
+void qoz_registerCard(struct qoz_card *qozcard) {
+    spin_lock(&registerlock);
+    if (qozcard != NULL) {
+	qozcard->prev = NULL;
+	qozcard->next = qoz_dev_list;
+	if (qoz_dev_list) {
+	    qoz_dev_list->prev = qozcard;
+	}
+	qoz_dev_list = qozcard;
+	qozcard->cardno = ++qoz_dev_count;
+    } else {
+	printk(KERN_INFO "qozap: trying to register NULL card.\n");
+    }
+    spin_unlock(&registerlock);
+}
+
+static int qoz_dfifo_tx(struct qoz_card *qoztmp, int stport) {
+    int chan = 2;
+    int x=0;
+    char fifo = 0;
+    char offset = 0;
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    fifo = stport + offset;
+
+    if (qoztmp->ztdev->chans[stport][chan].bytes2transmit < 1) {
+	return 0;
+    } else {
+	/* select fifo */
+	qoz_outb(qoztmp,qoz_R_FIFO,fifo << 1);    
+	qoz_waitbusy(qoztmp);
+    
+	if (debug > 1)
+	    printk(KERN_INFO "qozap: card %d stport %d TX [ ", qoztmp->cardno, stport + 1);
+	/* copy frame to fifo */
+    	for (x=0;x<qoztmp->ztdev->chans[stport][chan].bytes2transmit;x++) {
+	    if (debug > 1)
+	        printk("%#x ",qoztmp->dtxbuf[stport][x]);
+    	    qoz_outb(qoztmp,qoz_A_FIFO_DATA0,qoztmp->dtxbuf[stport][x]);
+	}
+	if (debug > 1)
+	    printk("] %d bytes\n",qoztmp->ztdev->chans[stport][chan].bytes2transmit);
+
+	if (qoztmp->ztdev->chans[stport][chan].eoftx == 1) {
+	    /* transmit HDLC frame */
+    	    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x1);    
+    	    qoz_waitbusy(qoztmp);
+	}
+    }
+    return 0;
+}
+
+static int qoz_fifo_tx(struct qoz_card *qoztmp, char fifo) {
+    int stport = fifo / 2;
+    int chan = fifo % 2;
+
+    /* select fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,0x80 | (fifo << 1));    
+    qoz_waitbusy(qoztmp);
+    /* transmit 8 bytes of transparent data */
+    qoz_outdw(qoztmp,qoz_A_FIFO_DATA0,*((unsigned int *) &qoztmp->txbuf[stport][chan][0]));
+    qoz_outdw(qoztmp,qoz_A_FIFO_DATA0,*((unsigned int *) &qoztmp->txbuf[stport][chan][4]));
+	    
+    return 0;
+}
+
+static int qoz_dfifo_rx(struct qoz_card *qoztmp, int stport) {
+    unsigned char f1=1,f2=1,data,stat;
+    unsigned char of1=0,of2=0;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    char fifo = 0;
+    char offset = 0;
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    fifo = stport + offset;
+    // select rx fifo
+    
+    qoz_outb(qoztmp,qoz_R_FIFO,(fifo << 1) | 1);    
+    qoz_waitbusy(qoztmp);
+
+    while ((of1 != f1) && (of2 != f2)) {
+        of1 = f1;
+        of2 = f2;
+        f1 = qoz_inb(qoztmp,qoz_A_F1) & 0xf;
+        f2 = qoz_inb(qoztmp,qoz_A_F2) & 0xf;
+    }
+    
+    if (f1 == f2) {
+	/* no frame */
+	qoztmp->st[stport].drx--;
+	qoztmp->ztdev->chans[stport][2].bytes2receive = 0;
+	return 0;
+    }
+    
+    while ((oz1 != z1) && (oz2 != z2)) {
+        oz1 = z1;
+        oz2 = z2;
+	if (qoztmp->type != 0xb552) {
+    	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x7ff;
+	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x7ff;
+	} else {
+    	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x3ff;
+	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x3ff;
+	}
+    }
+    
+    if (qoztmp->type == 0xb552) {
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_DFIFO_SIZE8;
+	}
+    } else {
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_DFIFO_SIZE4;
+	}
+    }
+
+    if (len > qoz_DFIFO_SIZE4) {
+	printk(KERN_INFO "\nqozap: buffer overflow in D channel RX!\n");
+	qoztmp->ztdev->chans[stport][2].bytes2receive = 0;
+	qoztmp->ztdev->chans[stport][2].eofrx = 0;
+    } else {
+	if (debug > 1) printk(KERN_INFO "qozap: card %d span %d RX [ ", qoztmp->cardno, stport + 1);
+	for (i=0; i<len; i++) {
+    	    data = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+	    qoztmp->drxbuf[stport][i] = data;
+	    if (debug > 1) printk("%#x ",data);
+	}
+	if (debug > 1) printk("] %d bytes\n", len);
+	qoztmp->ztdev->chans[stport][2].bytes2receive = i;
+	qoztmp->ztdev->chans[stport][2].eofrx = 1;
+    }
+
+    stat = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+    if (stat != 0x0) {
+	// bad CRC, skip it
+	printk(KERN_INFO "qozap: CRC error for HDLC frame on card %d (cardID %d) S/T port %d\n",qoztmp->cardno, qoztmp->cardID, stport+1);
+	qoztmp->ztdev->chans[stport][2].bytes2receive = 0;
+	qoztmp->ztdev->chans[stport][2].eofrx = 0;
+//        zt_qevent_nolock(&qoztmp->ztdev->chans[stport][2], ZT_EVENT_BADFCS);
+    }
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x1);    
+    qoz_waitbusy(qoztmp);
+
+    /* frame recevived */
+    if (qoztmp->st[stport].drx > 0) { 
+	qoztmp->st[stport].drx--;
+    } else {
+	printk(KERN_INFO "qozap: trying to receive too much (card %d span %d drx %d)\n", qoztmp->cardno, stport+1, qoztmp->st[stport].drx);
+	qoztmp->st[stport].drx = 0;
+    }
+    return 0;
+}
+
+
+static int qoz_fifo_rx(struct qoz_card *qoztmp, char fifo) {
+    int stport = fifo / 2;
+    int chan = fifo % 2;
+    unsigned char data;
+    int len,i;
+    unsigned short z1=1,z2=1;
+    unsigned short oz1=0,oz2=0;
+    int mumbojumbo=0;
+
+        /* select rx fifo */
+	qoz_outb(qoztmp,qoz_R_FIFO,0x80 | (fifo << 1) | 1);    
+        qoz_waitbusy(qoztmp);
+    
+	while ((oz1 != z1) && (oz2 != z2)) {
+	    oz1 = z1;
+	    oz2 = z2;
+	    z1 = qoz_inw(qoztmp,qoz_A_Z1) & 0x7f;
+    	    z2 = qoz_inw(qoztmp,qoz_A_Z2) & 0x7f;
+	}
+	len = z1 - z2;
+	if (len < 0) {
+	    len += qoz_FIFO_SIZE;
+	}
+	if (len > 2 * ZT_CHUNKSIZE) {
+	    mumbojumbo = len - (2 * ZT_CHUNKSIZE);
+	    len = ZT_CHUNKSIZE;
+	    for (i=0;i<mumbojumbo;i++) {
+    		data = qoz_inb(qoztmp,qoz_A_FIFO_DATA0);
+	    }
+	    qoztmp->clicks++;
+	    if ((qoztmp->clicks > 100) || (debug == 4)) {
+		printk(KERN_CRIT "qozap: dropped audio card %d cardid %d bytes %d z1 %d z2 %d\n", qoztmp->cardno, qoztmp->cardID, mumbojumbo, z1, z2);
+		qoztmp->clicks = 0;
+	    }
+	}
+	if (len < ZT_CHUNKSIZE) {
+//	    printk(KERN_INFO "qozap: not enough to receive (%d bytes)\n",len);
+	    return 0;
+	} else {
+	    *((unsigned int *) &qoztmp->rxbuf[stport][chan][0]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	    *((unsigned int *) &qoztmp->rxbuf[stport][chan][4]) = qoz_indw(qoztmp,qoz_A_FIFO_DATA0);
+	}
+
+	zt_ec_chunk(&qoztmp->ztdev->spans[stport].chans[chan], qoztmp->ztdev->spans[stport].chans[chan].readchunk, qoztmp->ztdev->spans[stport].chans[chan].writechunk);
+
+//    printk(KERN_INFO "s/t port %d, channel %d, dbufi=%d, f1=%d, f2=%d, z1=%d, z2=%d  => len = %d stat=%#x, hdlc=%d\n",stport,chan,qoztmp->st[stport].dbufi,f1,f2,z1,z2,len,stat,hdlc);    
+    return 0;
+}
+
+
+static inline void qoz_run(struct qoz_card *qoztmp) {
+    int s=0;
+    if (qoztmp->ztdev != NULL) {
+	for (s=0;s<qoztmp->stports;s++) {
+	    if (qoztmp->ztdev->spans[s].flags & ZT_FLAG_RUNNING) {
+		/* oh zaptel! tell us what to transmit... */
+    		zt_transmit(&qoztmp->ztdev->spans[s]);
+	        /* B1 xmit */
+		qoz_fifo_tx(qoztmp, s * 2);
+		/* B2 xmit */
+		qoz_fifo_tx(qoztmp, (s * 2) + 1);
+		/* D xmit */
+		qoz_dfifo_tx(qoztmp, s);
+
+		qoztmp->ztdev->chans[s][2].bytes2receive = 0;
+		qoztmp->ztdev->chans[s][2].bytes2transmit = 0;
+		qoztmp->ztdev->chans[s][2].eofrx = 0;
+		qoztmp->ztdev->chans[s][2].eoftx = 0;
+
+	    }
+	    /* B1 receive */
+	    qoz_fifo_rx(qoztmp,(s*2));
+	    /* B2 receive */
+	    qoz_fifo_rx(qoztmp,(s*2)+1);
+	    /* d-chan data */
+	    if (qoztmp->st[s].drx > 0) {
+	        if (debug > 2)
+		    printk(KERN_CRIT "qozap: card %d st[%d].drx = %d\n", qoztmp->cardno, s, qoztmp->st[s].drx);
+		qoz_dfifo_rx(qoztmp, s);
+	    }
+	    if (qoztmp->ztdev->spans[s].flags & ZT_FLAG_RUNNING) {
+	        /* oh zaptel! thou shall receive! */
+		zt_receive(&(qoztmp->ztdev->spans[s]));
+	    }
+	} 
+    }
+}
+
+#ifdef LINUX26
+static irqreturn_t qoz_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#else
+static void qoz_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#endif
+    struct qoz_card *qoztmp = dev_id;
+    struct zt_qoz *ztqoz = qoztmp->ztdev;
+    unsigned long flags;
+    unsigned char irq_misc,irq_sci,status,l1state,irq_foview,fi;
+    int st=0,i=0,offset=0;
+
+    if (!qoztmp) {
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    if (!qoztmp->pci_io) {
+	    printk(KERN_CRIT "qozap: no pci mem\n");
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+    
+    spin_lock_irqsave(&(qoztmp->lock),flags);
+    status = qoz_inb(qoztmp,qoz_R_STATUS);
+    irq_sci = qoz_inb(qoztmp,qoz_R_SCI);
+
+    if (!(status & 0x80) && !(status & 0x40) && (irq_sci == 0)) {
+//	printk(KERN_CRIT "qozap: status %#x\n", status);
+	// it's not us!
+	spin_unlock_irqrestore(&(qoztmp->lock),flags);
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+    }
+
+    // misc irq
+    if (status & 0x40) {
+	irq_misc = qoz_inb(qoztmp,qoz_R_IRQ_MISC);
+	if (irq_misc & 0x2)  {
+	    // qozap timer
+	    qoztmp->ticks++;
+	    qoz_run(qoztmp);
+	    if (qoztmp->ticks % 100) {
+		qoz_doLEDs(qoztmp);
+	    }
+	    if (qoztmp->ticks > 600) {
+		qoztmp->ticks = 0;
+	    }
+	}
+	if (irq_misc & 0x4) {
+	//    printk(KERN_INFO "qozap proc/nonproc irq\n");
+	}
+    }
+    if (status & 0x80) {
+	/* fifo irq */
+	irq_foview = qoz_inb(qoztmp,qoz_R_IRQ_OVIEW);
+        if (qoztmp->type == 0xb552) {
+	    if (irq_foview & 0x60) {
+		offset = 0;
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL6);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = offset + (i / 2);
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	    if (irq_foview & 0x80) {
+		offset = 4;
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL7);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = offset + (i / 2);
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	} else {
+	    if (irq_foview & 0x80) {
+		fi = qoz_inb(qoztmp,qoz_R_IRQ_FIFO_BL7);
+		for (i=0; i < 8; i++) {
+		    if (fi & (1 << i)) {
+			st = i / 2;
+			if (i % 2) {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC RX irq fifo %d span %d\n", i, st+1);
+				qoztmp->st[st].drx += 1;			
+			} else {
+			    if (debug > 2) 
+		    		printk(KERN_CRIT "qozap: HDLC TX irq fifo %d span %d\n", i, st+1);
+			}
+		    }
+		}
+	    }
+	}
+    }
+    
+    /* state machine irq */
+    if (irq_sci != 0) {
+	if (debug > 1) {
+	    printk(KERN_INFO "R_BERT_STA = %#x\n", qoz_inb(qoztmp, qoz_R_BERT_STA) & 7);
+	}
+	for (st=0;st<qoztmp->stports;st++) {
+	    if (irq_sci & (1 << st)) {
+		qoz_outb(qoztmp,qoz_R_ST_SEL,st);
+		l1state = qoz_inb(qoztmp,qoz_A_ST_RD_STA) & 0xf;
+		if (debug > 1) {
+		    printk(KERN_INFO "A_ST_RD_STA = %#x\n", qoz_inb(qoztmp, qoz_A_ST_RD_STA));
+		}
+		if (qoztmp->st[st].nt_mode == 1) {
+		    if (debug)
+			printk(KERN_INFO "card %d span %d state G%d (A_ST_RD_STA = %#x)\n",qoztmp->cardno,st+1,l1state,qoz_inb(qoztmp,qoz_A_ST_RD_STA));
+		    // NT state machine
+		    if (l1state == 3) {
+			// keep layer1 up!
+			if (qoztmp->stports == 8) {
+			    sprintf(ztqoz->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [NT] Layer 1 ACTIVATED (G%d)",qoztmp->cardno ,st + 1, l1state);
+			} else {
+			    sprintf(ztqoz->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 ACTIVATED (G%d)",qoztmp->cardno ,st + 1,ztqoz->card->cardID, l1state);
+			}
+			qoz_outb(qoztmp,qoz_A_ST_WR_STA,3 | 0x10 );
+			qoztmp->leds[st] = 1;
+		    } else {
+			if (qoztmp->stports == 8) {
+			    sprintf(ztqoz->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [NT] Layer 1 DEACTIVATED (G%d)",qoztmp->cardno ,st + 1, l1state);
+			} else {
+			    sprintf(ztqoz->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d) Layer 1 DEACTIVATED (G%d)",qoztmp->cardno ,st + 1,ztqoz->card->cardID, l1state);
+			}
+			qoztmp->leds[st] = 0;
+		    }
+		} else {
+		    if (debug)
+			printk(KERN_INFO "card %d span %d state F%d (A_ST_RD_STA = %#x)\n",qoztmp->cardno,st+1,l1state,qoz_inb(qoztmp,qoz_A_ST_RD_STA));
+		    // TE state machine
+		    if (l1state == 3) {
+			/* keep layer1 up, if the span is started. */
+			if (qoztmp->ztdev->spans[st].flags & ZT_FLAG_RUNNING) {
+    			    qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60);
+			}
+			qoztmp->leds[st] = 0;
+			if (qoztmp->stports == 8) {
+			    sprintf(ztqoz->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else {
+			    sprintf(ztqoz->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,ztqoz->card->cardID, l1state);
+			}
+		    } else if (l1state == 7) {
+			qoztmp->leds[st] = 1;
+			if (qoztmp->stports == 8) {
+			    sprintf(ztqoz->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 ACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else {
+			    sprintf(ztqoz->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 ACTIVATED (F%d)",qoztmp->cardno ,st + 1,ztqoz->card->cardID, l1state);
+			}
+		    } else {
+			if (qoztmp->stports == 8) {
+			    sprintf(ztqoz->spans[st].desc,"octoBRI PCI ISDN Card %d Span %d [TE] Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1, l1state);
+			} else {
+			    sprintf(ztqoz->spans[st].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d) Layer 1 DEACTIVATED (F%d)",qoztmp->cardno ,st + 1,ztqoz->card->cardID, l1state);
+			}    
+		    }
+		}
+		
+	    }
+	}
+    }
+    spin_unlock_irqrestore(&(qoztmp->lock),flags);
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+}
+
+static int ztqoz_open(struct zt_chan *chan) {
+//    printk(KERN_INFO "qozap: channel %d opened.\n",chan->channo);
+#ifndef LINUX26
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztqoz_close(struct zt_chan *chan) {
+//    printk(KERN_INFO "qozap: channel %d closed.\n",chan->channo);
+#ifndef LINUX26
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int ztqoz_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int ztqoz_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int ztqoz_startup(struct zt_span *span) {
+    struct zt_qoz *qozt = span->pvt;
+    struct qoz_card *qoztmp = qozt->card;
+    unsigned long flags;
+    int alreadyrunning;
+    int i=0;
+    int offset = 0;
+    
+    if (qoztmp == NULL) {
+	printk(KERN_INFO "qozap: no card for span at startup!\n");
+    }
+    
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+//    printk(KERN_CRIT "already running %d flags %d\n", alreadyrunning, span->flags);
+
+    if (!alreadyrunning) {
+	span->chans[2].flags &= ~ZT_FLAG_HDLC;
+	span->chans[2].flags |= ZT_FLAG_BRIDCHAN;
+    
+	/* setup B channel buffers (8 bytes each) */
+	for (i=0; i<2 ; i++) {
+	    memset(qoztmp->rxbuf[span->offset][i],0x0,sizeof(qoztmp->rxbuf[span->offset][i]));
+    	    span->chans[i].readchunk = qoztmp->rxbuf[span->offset][i];
+    	    memset(qoztmp->txbuf[span->offset][i],0x0,sizeof(qoztmp->txbuf[span->offset][i]));
+	    span->chans[i].writechunk = qoztmp->txbuf[span->offset][i];
+	}
+	/* setup D channel buffer */
+    	memset(qoztmp->dtxbuf[span->offset],0x0,sizeof(qoztmp->dtxbuf[span->offset]));
+	span->chans[2].writechunk = qoztmp->dtxbuf[span->offset];
+	qoztmp->ztdev->chans[span->offset][2].maxbytes2transmit = sizeof(qoztmp->dtxbuf[span->offset]);
+
+	memset(qoztmp->drxbuf[span->offset],0x0,sizeof(qoztmp->drxbuf[span->offset]));
+    	span->chans[2].readchunk = qoztmp->drxbuf[span->offset];
+
+	span->flags |= ZT_FLAG_RUNNING;
+    } else {
+//	printk(KERN_CRIT "already running\n");
+	return 0;
+    }
+
+    spin_lock_irqsave(&qoztmp->lock,flags);
+    // irqs off
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    /* setup D-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset + offset) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xD);
+    qoz_outb(qoztmp,qoz_A_SUBCH_CFG,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) + 2) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup D-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset + offset) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0xD);
+    qoz_outb(qoztmp,qoz_A_SUBCH_CFG,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(((span->offset * 4) + 2) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B1-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset * 2) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,(span->offset * 4) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B1-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B2-FIFO TX */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) + 1) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((span->offset * 4) + 1) << 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    /* setup B2-FIFO RX */
+    qoz_outb(qoztmp,qoz_R_FIFO,(((span->offset * 2) + 1) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_R_INC_RES_FIFO,0x2);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_CHANNEL,((((span->offset) * 4) + 1) << 1) | 1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x1);
+
+    if (debug)
+        printk(KERN_INFO "qozap: starting card %d span %d/%d.\n",qoztmp->cardno,span->spanno,span->offset);
+    
+    /* activate layer 1 */
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	// NT mode
+	qoz_outb(qoztmp,qoz_A_ST_CTRL0,0x7);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL1,0x0);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL2,0x3);
+	qoz_outb(qoztmp,qoz_A_ST_CLK_DLY,0x60 | CLKDEL_NT);
+    } else {
+	// TE mode
+	qoz_outb(qoztmp,qoz_A_ST_CTRL0,0x3);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL1,0x0);
+	qoz_outb(qoztmp,qoz_A_ST_CTRL2,0x3);
+	qoz_outb(qoztmp,qoz_A_ST_CLK_DLY,CLKDEL_TE);
+    }
+
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x80); 
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x0); 
+    }
+    /* enable irqs */
+    qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 8 | 1); 
+    spin_unlock_irqrestore(&qoztmp->lock,flags);
+
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60 | 0x80); // ACT, G2->G3 EN
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x60); // start Activation
+    }
+
+    return 0;
+}
+
+static int ztqoz_shutdown(struct zt_span *span) {
+    struct zt_qoz *ztqoz = span->pvt;
+    struct qoz_card *qoztmp = ztqoz->card;
+    int alreadyrunning;
+    int offset = 0;
+    
+    if (qoztmp == NULL) {
+	printk(KERN_CRIT "qozap: qoztmp == NULL!\n");
+	return 0;
+	
+    }
+
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	return 0;
+    }
+
+//    printk(KERN_CRIT "qozap: stopping card %d port %d.\n",qoztmp->cardno, span->offset + 1);
+
+    // turn off irqs for all fifos
+    if (qoztmp->type == 0xb552) {
+	offset = 24;
+    } else {
+	offset = 28;
+    }
+
+    /* disable D TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset + offset) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable D RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset + offset) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x1);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B1 TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(span->offset * 2) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B1 RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((span->offset * 2) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B2 TX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,(((span->offset) * 2) + 1) << 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0);
+
+    /* disable B2 RX fifo */
+    qoz_outb(qoztmp,qoz_R_FIFO,((((span->offset) * 2) + 1) << 1) | 1);
+    qoz_waitbusy(qoztmp);
+    qoz_outb(qoztmp,qoz_A_CON_HDLC,0x2);
+    qoz_outb(qoztmp,qoz_A_IRQ_MSK,0x0); 
+
+    span->flags &= ~ZT_FLAG_RUNNING;
+
+    /* Deactivate Layer 1 */
+    qoz_outb(qoztmp,qoz_R_ST_SEL,span->offset);
+    if (qoztmp->st[span->offset].nt_mode == 1) {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x40); 
+    } else {
+	qoz_outb(qoztmp,qoz_A_ST_WR_STA,0x40);
+    }
+
+
+//    printk(KERN_CRIT "qozap: card %d span %d/%d down.\n",qoztmp->cardno,span->spanno,span->offset);
+    return 0;
+}
+
+static int ztqoz_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int ztqoz_chanconfig(struct zt_chan *chan,int sigtype) {
+//    printk(KERN_INFO "chan_config sigtype=%d\n",sigtype);
+    return 0;
+}
+
+static int ztqoz_spanconfig(struct zt_span *span,struct zt_lineconfig *lc) {
+//    span->lineconfig = lc->lineconfig;
+    return 0;
+}
+
+static int ztqoz_initialize(struct zt_qoz *ztqoz) {
+    struct qoz_card *qoztmp = ztqoz->card;
+    int i=0,s=0;
+    
+    for (s=0; s < ztqoz->card->stports; s++) {
+	memset(&ztqoz->spans[s],0,sizeof(struct zt_span)); // you never can tell...
+	sprintf(ztqoz->spans[s].name,"ztqoz/%d/%d",qoz_dev_count + 1,s + 1);
+	if (ztqoz->card->stports == 8) {
+	    if (qoztmp->st[s].nt_mode == 1){
+		sprintf(ztqoz->spans[s].desc,"octoBRI PCI ISDN Card %d Span %d [NT]",qoztmp->cardno,s + 1);
+	    } else {
+		sprintf(ztqoz->spans[s].desc,"octoBRI PCI ISDN Card %d Span %d [TE]",qoztmp->cardno,s + 1);
+	    }
+	} else {
+	    if (ztqoz->card->cardID < 0xff) {
+		if (qoztmp->st[s].nt_mode == 1){
+		    sprintf(ztqoz->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [NT] (cardID %d)",qoztmp->cardno,s + 1,ztqoz->card->cardID);
+		} else {
+		    sprintf(ztqoz->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [TE] (cardID %d)",qoztmp->cardno,s + 1,ztqoz->card->cardID);
+		}
+	    } else {
+		if (qoztmp->st[s].nt_mode == 1){
+		    sprintf(ztqoz->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [NT]",qoztmp->cardno,s + 1);
+		} else {
+		    sprintf(ztqoz->spans[s].desc,"quadBRI PCI ISDN Card %d Span %d [TE]",qoztmp->cardno,s + 1);
+		}
+	    }
+	}
+
+        ztqoz->spans[s].spanconfig = ztqoz_spanconfig;
+        ztqoz->spans[s].chanconfig = ztqoz_chanconfig;
+        ztqoz->spans[s].startup = ztqoz_startup;
+        ztqoz->spans[s].shutdown = ztqoz_shutdown;
+        ztqoz->spans[s].maint = ztqoz_maint;
+        ztqoz->spans[s].rbsbits = ztqoz_rbsbits;
+        ztqoz->spans[s].open = ztqoz_open;
+        ztqoz->spans[s].close = ztqoz_close;
+        ztqoz->spans[s].ioctl = ztqoz_ioctl;
+
+        ztqoz->spans[s].chans = ztqoz->chans[s];
+        ztqoz->spans[s].channels = 3;
+        ztqoz->spans[s].deflaw = ZT_LAW_ALAW;
+        ztqoz->spans[s].linecompat = ZT_CONFIG_AMI | ZT_CONFIG_CCS; // <--- this is really BS
+        init_waitqueue_head(&ztqoz->spans[s].maintq);
+        ztqoz->spans[s].pvt = ztqoz;
+        ztqoz->spans[s].offset = s;
+
+	for (i=0; i < ztqoz->spans[s].channels; i++) {
+	    memset(&(ztqoz->chans[s][i]),0x0,sizeof(struct zt_chan));
+	    sprintf(ztqoz->chans[s][i].name,"ztqoz%d/%d/%d",qoz_dev_count + 1,s + 1,i + 1);
+	    ztqoz->chans[s][i].pvt = ztqoz;
+	    ztqoz->chans[s][i].sigcap =  ZT_SIG_EM | ZT_SIG_CLEAR | ZT_SIG_FXSLS | ZT_SIG_FXSGS | ZT_SIG_FXSKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS | ZT_SIG_FXOKS | ZT_SIG_CAS | ZT_SIG_SF;
+	    ztqoz->chans[s][i].chanpos = i + 1; 
+	}
+
+	if (zt_register(&ztqoz->spans[s],0)) {
+	    printk(KERN_INFO "qozap: unable to register zaptel span %d!\n",s+1);
+	    return -1;
+	}
+//	 printk(KERN_INFO "qozap: registered zaptel span %d.\n",s+1);
+    }
+
+    return 0;
+}
+
+int qoz_findCards(unsigned int pcidid) {
+    struct pci_dev *tmp;
+    struct qoz_card *qoztmp = NULL;
+    struct zt_qoz *ztqoz = NULL;
+    int i=0;
+    unsigned char dips=0;
+    int cid=0;
+    int modes=0;
+    tmp = pci_find_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+    while (tmp != NULL) {
+	multi_qoz = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_qoz = NULL;
+	    return -1;
+	}
+
+	qoztmp = kmalloc(sizeof(struct qoz_card),GFP_KERNEL);
+	if (!qoztmp) {
+	    printk(KERN_WARNING "qozap: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -ENOMEM;
+	}
+	memset(qoztmp, 0x0, sizeof(struct qoz_card));
+	
+	spin_lock_init(&qoztmp->lock);
+	qoztmp->pcidev = tmp;
+	qoztmp->pcibus = tmp->bus->number;
+	qoztmp->pcidevfn = tmp->devfn; 
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "qozap: no irq!\n");
+	} else {
+	    qoztmp->irq = tmp->irq;
+	}
+
+	qoztmp->pci_io = (char *) tmp->resource[1].start;
+	if (!qoztmp->pci_io) {
+	    printk(KERN_WARNING "qozap: no iomem!\n");
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+	
+	if (request_irq(qoztmp->irq, qoz_interrupt, SA_INTERRUPT | SA_SHIRQ, "qozap", qoztmp)) {
+	    printk(KERN_WARNING "qozap: unable to register irq\n");
+	    kfree(qoztmp);
+	    pci_disable_device(tmp);
+	    multi_qoz = NULL;
+	    return -EIO;
+	}
+	
+	
+	qoztmp->pci_io = ioremap((ulong) qoztmp->pci_io, 256);
+	
+		       
+	pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+
+	// disable ints
+	qoz_outb(qoztmp,qoz_R_IRQ_CTRL, 0); 
+
+	ztqoz = kmalloc(sizeof(struct zt_qoz),GFP_KERNEL);
+	if (!ztqoz) {
+	    printk(KERN_INFO "qozap: unable to kmalloc!\n");
+	    qoz_shutdownCard(qoztmp);
+	    kfree(qoztmp);
+	    multi_qoz = NULL;
+	    return -ENOMEM;
+	}
+	memset(ztqoz, 0x0, sizeof(struct zt_qoz));
+
+	if (pcidid == PCI_DEVICE_ID_CCD_M) {
+	    qoztmp->stports = 8;
+	} else {
+	    qoztmp->stports = 4;
+	}
+	
+
+        if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+	//    printk(KERN_INFO "MODES = %#x.\n",modes);
+	    qoz_outb(qoztmp,qoz_R_GPIO_SEL,0x80 | 0x40);
+	    dips = (qoz_inb(qoztmp,qoz_R_GPIO_IN1) >> 5);
+	    cid = 7;
+	    for (i=0;i<3;i++) {
+	        if ((dips & (1 << i)) != 0) {
+	    	cid -= (1 << (2-i));
+	        }
+	    }
+	//	printk(KERN_INFO "DIPS = %#x CID= %#x\n",dips,cid);
+        } else {
+	    cid = 0xff;
+        }
+
+	if (ports == -1) {
+    	    if ((tmp->subsystem_device==0xb520) && (pcidid == PCI_DEVICE_ID_CCD_M4)) {
+		modes = qoz_inb(qoztmp,qoz_R_GPI_IN3) >> 4;
+	    } else {
+		modes = 0; // assume TE mode
+	    }
+	} else {
+	    modes = ports >> totalBRIs;
+	}
+
+	if (pcidid == PCI_DEVICE_ID_CCD_M4) {
+	    switch (tmp->subsystem_device) {
+		case 0x08b4:
+			if (ports == -1) ports = 0; /* assume TE mode if no ports param */
+			printk(KERN_INFO
+		        "qozap: CologneChip HFC-4S evaluation board configured at mem %#x IRQ %d HZ %d\n",
+		          (u_int) qoztmp->pci_io,
+		        qoztmp->irq, HZ);
+		    break;
+		case 0xb520:
+			printk(KERN_INFO
+		        "qozap: Junghanns.NET quadBRI card configured at mem %#x IRQ %d HZ %d CardID %d\n",
+		          (u_int) qoztmp->pci_io,
+		        qoztmp->irq, HZ, cid);
+		    break;
+	    } 
+	    totalBRIs += 4;
+	} else {
+	    switch (tmp->subsystem_device) {
+		case 0xb552:
+		    printk(KERN_INFO
+		       "qozap: Junghanns.NET octoBRI card configured at mem %#x IRQ %d HZ %d\n",
+		       (u_int) qoztmp->pci_io,
+		       qoztmp->irq, HZ);
+	        break;
+		default:
+		    iounmap((void *) qoztmp->pci_io);
+		    if (qoztmp->pcidev != NULL) {
+    			pci_disable_device(qoztmp->pcidev);
+		    }
+		    pci_write_config_word(qoztmp->pcidev, PCI_COMMAND, 0);	// disable memio
+		    free_irq(qoztmp->irq,qoztmp);
+		    kfree(qoztmp);
+		    qoztmp = NULL;
+		    tmp = pci_find_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+		    continue;
+		break;		
+	    } 
+	    totalBRIs += 8;
+	}
+
+	qoztmp->cardID = cid;
+	qoztmp->type = tmp->subsystem_device;
+
+	printk(KERN_INFO "qozap: S/T ports: %d [",qoztmp->stports);
+	for (i=0;i<qoztmp->stports;i++) {
+	    if ((modes & (1 << i)) != 0) {
+	        qoztmp->st[i].nt_mode = 1;
+	        printk(" NT");
+	    } else {
+	        qoztmp->st[i].nt_mode = 0;
+	        printk(" TE");
+	    }
+	}
+	printk(" ]\n");
+	
+	ztqoz->card = qoztmp;
+	qoztmp->ztdev = ztqoz;
+
+	qoz_registerCard(qoztmp);
+
+	tmp = pci_find_device(PCI_VENDOR_ID_CCD,pcidid,multi_qoz);
+    }
+    return 0;
+}
+
+
+int qoz_sortCards(void) {
+    int changed=0,tmpcardno;
+    struct qoz_card *tmpcard,*tmpcard2;
+    spin_lock(&registerlock);
+    do {
+	changed = 0;
+	tmpcard = qoz_dev_list;
+	while (tmpcard != NULL) {
+	    if (tmpcard->prev) {
+		if (tmpcard->prev->cardID > tmpcard->cardID) {
+		    tmpcardno = tmpcard->prev->cardno;
+		    tmpcard->prev->cardno = tmpcard->cardno; 
+		    tmpcard->cardno = tmpcardno;
+		
+		    tmpcard2 = tmpcard->prev;
+		    if (tmpcard2->prev) {
+			tmpcard2->prev->next = tmpcard;
+		    } else {
+			qoz_dev_list = tmpcard;
+		    }
+		    if (tmpcard->next) {
+			tmpcard->next->prev = tmpcard2;
+		    } 
+		    tmpcard2->next = tmpcard->next;
+		    tmpcard->prev = tmpcard2->prev;
+		    tmpcard->next = tmpcard2;
+		    tmpcard2->prev = tmpcard;
+		    changed = 1;
+		    tmpcard = tmpcard2;
+		}
+	    }
+	    tmpcard = tmpcard->next;
+	}
+    } while (changed == 1);
+    spin_unlock(&registerlock);
+    return 0;
+}
+
+int qoz_zapCards(void) {
+    struct qoz_card *tmpcard;
+    tmpcard = qoz_dev_list;
+    while (tmpcard != NULL) {
+	ztqoz_initialize(tmpcard->ztdev);
+	qoz_resetCard(tmpcard);
+	tmpcard = tmpcard->next;
+    }
+    return 0;
+}
+
+
+int init_module(void) {
+    multi_qoz = NULL;
+    qoz_findCards(PCI_DEVICE_ID_CCD_M4);
+    qoz_findCards(PCI_DEVICE_ID_CCD_M);
+    qoz_sortCards();
+    qoz_zapCards();
+    if (qoz_dev_count == 0) {
+	printk(KERN_INFO "qozap: no multiBRI cards found.\n");
+    } else {
+	printk(KERN_INFO "qozap: %d multiBRI card(s) in this box, %d BRI ports total.\n",qoz_dev_count, totalBRIs);
+    }
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct qoz_card *tmpcard,*tmplist;
+    int i=0;
+    tmplist = qoz_dev_list;
+    while (tmplist != NULL) {
+	qoz_shutdownCard(tmplist);
+	tmplist = tmplist->next;
+    }
+    tmplist = qoz_dev_list;
+    spin_lock(&registerlock);
+    while (tmplist != NULL) {
+	tmpcard = tmplist->next;
+	kfree(tmplist);
+	i++;
+	tmplist = tmpcard;
+    }
+    spin_unlock(&registerlock);
+    printk(KERN_INFO "qozap: shutdown %d multiBRI cards.\n", i);
+}
+#endif
+
+MODULE_PARM(doubleclock,"i");
+MODULE_PARM(ports,"i");
+MODULE_PARM(debug,"i");
+MODULE_DESCRIPTION("quad/octo BRI zaptel driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
diff -urNad --exclude=CVS --exclude=.svn ./qozap/qozap.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/qozap.h
--- ./qozap/qozap.h	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/qozap.h	2005-07-14 07:01:09.223137552 +0100
@@ -0,0 +1,204 @@
+#define qoz_SPANS 8	
+#define qoz_FIFO_SIZE	128
+#define qoz_DFIFO_SIZE4	2048
+#define qoz_DFIFO_SIZE8	1024
+
+typedef struct qoz_span {
+    unsigned char nt_mode;
+    unsigned char btx;
+    unsigned char bswapped;
+    unsigned char drx;
+} qoz_span;
+
+typedef struct qoz_regs {
+    unsigned char fifo_en;
+    unsigned char ctmt;
+    unsigned char int_m1;
+    unsigned char int_m2;
+    unsigned char sctrl;
+    unsigned char sctrl_e;
+    unsigned char sctrl_r;
+    unsigned char connect;
+    unsigned char trm;
+    unsigned char mst_mode;
+} qoz_regs;
+
+typedef struct qoz_card {
+    spinlock_t lock;
+    int cardID;
+    unsigned char leds[8];
+    unsigned char cardno;
+    unsigned int irq;
+    unsigned int iomem;
+    unsigned char *pci_io;
+    struct qoz_span st[qoz_SPANS];
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    struct zt_qoz *ztdev;
+    unsigned char rxbuf[qoz_SPANS][2][ZT_CHUNKSIZE];
+    unsigned char txbuf[qoz_SPANS][2][ZT_CHUNKSIZE];
+    unsigned char drxbuf[qoz_SPANS][qoz_DFIFO_SIZE4];
+    unsigned char dtxbuf[qoz_SPANS][qoz_DFIFO_SIZE4];
+    unsigned char stports;
+    unsigned int ticks;
+    unsigned int clicks;
+    unsigned int type;
+    struct qoz_card *next;
+    struct qoz_card *prev;
+} qoz_card;
+
+
+typedef struct zt_qoz {
+    unsigned int usecount;
+    struct zt_span spans[qoz_SPANS];
+    struct zt_chan chans[qoz_SPANS][3];
+    struct qoz_card *card;
+} zt_qoz;
+
+#define qoz_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define qoz_inb(a,b) (readb((a)->pci_io+(b)))
+
+#define qoz_outw(a,b,c) (writew((c),(a)->pci_io+(b)))
+#define qoz_inw(a,b) (readw((a)->pci_io+(b)))
+
+#define qoz_outdw(a,b,c) (writel((c),(a)->pci_io+(b)))
+#define qoz_indw(a,b) (readl((a)->pci_io+(b)))
+
+/* Write only registers */
+#define qoz_A_CH_MSK	0xF4
+#define qoz_A_CHANNEL 	0xFC
+#define qoz_A_CON_HDLC	0xFA
+#define qoz_A_CONF	0xD1
+#define qoz_A_FIFO_SEQ	0xFD
+#define qoz_R_INC_RES_FIFO	0x0E
+#define qoz_A_IRQ_MSK	0xFF
+#define qoz_A_SL_CFG	0xD0
+#define qoz_A_ST_B1_TX	0x3C
+#define qoz_A_ST_B2_TX	0x3D
+#define qoz_A_ST_CLK_DLY	0x37
+#define qoz_A_ST_CTRL0	0x31
+#define qoz_A_ST_CTRL1	0x32
+#define qoz_A_ST_CTRL2	0x33
+#define qoz_A_ST_D_TX	0x3E
+#define qoz_A_ST_SQ_WR	0x34
+#define qoz_A_ST_WR_STA	0x30
+#define qoz_A_SUBCH_CFG	0xFB
+#define qoz_R_BERT_WD_MD	0x1B
+#define qoz_R_BRG_CTRL	0x45
+#define qoz_R_BRG_MD	0x47
+#define qoz_R_BRG_PCM_CFG	0x02
+#define qoz_R_BRG_TIM_SEL01	0x4C
+#define qoz_R_BRG_TIM_SEL23	0x4D
+#define qoz_R_BRG_TIM_SEL45	0x4E
+#define qoz_R_BRG_TIM_SEL67	0x4F
+#define qoz_R_BRG_TIM0	0x48
+#define qoz_R_BRG_TIM1	0x49
+#define qoz_R_BRG_TIM2	0x4A
+#define qoz_R_BRG_TIM3	0x4B
+#define qoz_R_CIRM	0x00
+#define qoz_R_CONF_EN	0x18
+#define qoz_R_CTRL	0x01
+#define qoz_R_DTMF0	0x1C
+#define qoz_R_DTMF1	0x1D
+#define qoz_R_FIFO_MD	0x0D
+#define qoz_R_FIFO	0x0F
+#define qoz_R_FIRST_FIFO	0x0B
+#define qoz_R_FSM_IDX	0x0F
+#define qoz_R_GPIO_EN0	0x42
+#define qoz_R_GPIO_EN1	0x43
+#define qoz_R_GPIO_OUT0	0x40
+#define qoz_R_GPIO_OUT1	0x41
+#define qoz_R_GPIO_SEL	0x44
+#define qoz_R_IRQ_CTRL	0x13
+#define qoz_R_IRQMSK_MISC	0x11
+#define qoz_R_PCM_MD0	0x14
+#define qoz_R_PCM_MD1	0x15
+#define qoz_R_PCM_MD2	0x15
+#define qoz_R_PWM_MD	0x46
+#define qoz_R_PWM0	0x38
+#define qoz_R_PWM1	0x39
+#define qoz_R_RAM_ADDR0	0x08
+#define qoz_R_RAM_ADDR1	0x09
+#define qoz_R_RAM_ADDR2	0x0A
+#define qoz_R_RAM_MISC	0x0C
+#define qoz_R_SCI_MSK	0x12
+#define qoz_R_SH0H	0x15
+#define qoz_R_SH0L	0x15
+#define qoz_R_SH1H	0x15
+#define qoz_R_SH1L	0x15
+#define qoz_R_SL_SEL0	0x15
+#define qoz_R_SL_SEL1	0x15
+#define qoz_R_SL_SEL2	0x15
+#define qoz_R_SL_SEL3	0x15
+#define qoz_R_SL_SEL4	0x15
+#define qoz_R_SL_SEL5	0x15
+#define qoz_R_SL_SEL6	0x15
+#define qoz_R_SL_SEL7	0x15
+#define qoz_R_SLOT	0x10
+#define qoz_R_ST_SEL	0x16
+#define qoz_R_ST_SYNC	0x17
+#define qoz_R_TI_WD	0x1A
+
+/* Read only registers */
+#define qoz_A_F1	0x0C
+#define qoz_A_F12	0x0C
+#define qoz_A_F2	0x0D
+#define qoz_A_ST_B1_RX	0x3C
+#define qoz_A_ST_B2_TX	0x3D
+#define qoz_A_ST_D_RX	0x3E
+#define qoz_A_ST_E_RX	0x3F
+#define qoz_A_ST_RD_STA	0x30
+#define qoz_A_ST_SQ_RD	0x34
+#define qoz_A_Z1	0x04
+#define qoz_A_Z12	0x04
+#define qoz_A_Z1H	0x05
+#define qoz_A_Z1L	0x04
+#define qoz_A_Z2	0x06
+#define qoz_A_Z2H	0x07
+#define qoz_A_Z2L	0x06
+#define qoz_R_BERT_ECH	0x1B
+#define qoz_R_BERT_ECL	0x1A
+#define qoz_R_BERT_STA	0x17
+#define qoz_R_CHIP_ID	0x16
+#define qoz_R_CHIP_RV	0x1F
+#define qoz_R_CONF_OFLOW	0x14
+#define qoz_R_F0_CNTH	0x19
+#define qoz_R_F0_CNTL	0x18
+#define qoz_R_GPI_IN0	0x44
+#define qoz_R_GPI_IN1	0x45
+#define qoz_R_GPI_IN2	0x46
+#define qoz_R_GPI_IN3	0x47
+#define qoz_R_GPIO_IN0	0x40
+#define qoz_R_GPIO_IN1	0x41
+#define qoz_R_INT_DATA	0x88
+#define qoz_R_IRQ_FIFO_BL0	0xC8
+#define qoz_R_IRQ_FIFO_BL1	0xC9
+#define qoz_R_IRQ_FIFO_BL2	0xCA
+#define qoz_R_IRQ_FIFO_BL3	0xCB
+#define qoz_R_IRQ_FIFO_BL4	0xCC
+#define qoz_R_IRQ_FIFO_BL5	0xCD
+#define qoz_R_IRQ_FIFO_BL6	0xCE
+#define qoz_R_IRQ_FIFO_BL7	0xCF
+#define qoz_R_IRQ_MISC	0x11
+#define qoz_R_IRQ_OVIEW	0x10
+#define qoz_R_RAM_USE	0x15
+#define qoz_R_SCI	0x12
+#define qoz_R_STATUS	0x1C
+
+/* Read/Write registers */
+#define qoz_A_FIFO_DATA0_NOINC	0x84
+#define qoz_A_FIFO_DATA0	0x80
+#define qoz_A_FIFO_DATA1_NOINC	0x84
+#define qoz_A_FIFO_DATA1	0x80
+#define qoz_A_FIFO_DATA2_NOINC	0x84
+#define qoz_A_FIFO_DATA2	0x80
+#define qoz_R_RAM_DATA	0xC0
+
+#define PCI_DEVICE_ID_CCD_M	0x16b8
+#define PCI_DEVICE_ID_CCD_M4	0x08b4
+#define CLKDEL_TE	0xe	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0xc	/* CLKDEL in NT mode */
+
+#define HFC8S_CHIP_ID	0x80
+#define HFC4S_CHIP_ID	0xC0
diff -urNad --exclude=CVS --exclude=.svn ./qozap/TODO /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/TODO
--- ./qozap/TODO	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/TODO	2005-07-14 07:01:09.222137704 +0100
@@ -0,0 +1,4 @@
+- native-native bridging
+- onchip dtmf
+- E channel support for full debug
+
diff -urNad --exclude=CVS --exclude=.svn ./qozap/zapata.conf /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zapata.conf
--- ./qozap/zapata.conf	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zapata.conf	2005-07-14 07:01:09.223137552 +0100
@@ -0,0 +1,49 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+; p2mp TE mode (for connecting ISDN lines in point-to-multipoint mode)
+signalling = bri_cpe_ptmp
+; p2p TE mode (for connecting ISDN lines in point-to-point mode)
+;signalling = bri_cpe
+; p2mp NT mode (for connecting ISDN phones in point-to-multipoint mode)
+;signalling = bri_net_ptmp
+; p2p NT mode (for connecting an ISDN pbx in point-to-point mode)
+;signalling = bri_net
+
+pridialplan = local
+prilocaldialplan = local
+nationalprefix = 0
+internationalprefix = 00
+
+echocancel = yes
+
+context=demo
+group = 1
+; S/T port 1
+channel => 1-2
+
+group = 2
+; S/T port 2
+channel => 4-5
+
+group = 3
+; S/T port 3
+channel => 7-8
+
+group = 4
+; S/T port 4
+channel => 10-11
+
diff -urNad --exclude=CVS --exclude=.svn ./qozap/zapata.conf.octoBRI /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zapata.conf.octoBRI
--- ./qozap/zapata.conf.octoBRI	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zapata.conf.octoBRI	2005-07-14 07:01:09.223137552 +0100
@@ -0,0 +1,65 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+
+; p2mp TE mode (for connecting ISDN lines in point-to-multipoint mode)
+signalling = bri_cpe_ptmp
+; p2p TE mode (for connecting ISDN lines in point-to-point mode)
+;signalling = bri_cpe
+; p2mp NT mode (for connecting ISDN phones in point-to-multipoint mode)
+;signalling = bri_net_ptmp
+; p2p NT mode (for connecting an ISDN pbx in point-to-point mode)
+;signalling = bri_net
+
+pridialplan = local
+prilocaldialplan = local
+nationalprefix = 0
+internationalprefix = 00
+
+echocancel = yes
+
+context=demo
+group = 1
+; S/T port 1
+channel => 1-2
+
+group = 2
+; S/T port 2
+channel => 4-5
+
+group = 3
+; S/T port 3
+channel => 7-8
+
+group = 4
+; S/T port 4
+channel => 10-11
+
+group = 5
+; S/T port 5
+channel => 13-14
+
+group = 6
+; S/T port 6
+channel => 16-17
+
+group = 7
+; S/T port 7
+channel => 19-20
+
+group = 8
+; S/T port 8
+channel => 22-23
+
diff -urNad --exclude=CVS --exclude=.svn ./qozap/zaptel.conf /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zaptel.conf
--- ./qozap/zaptel.conf	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zaptel.conf	2005-07-14 07:01:09.225137248 +0100
@@ -0,0 +1,18 @@
+loadzone=nl
+defaultzone=nl
+# qozap span definitions
+# most of the values should be bogus because we are not really zaptel
+span=1,1,3,ccs,ami
+span=2,0,3,ccs,ami
+span=3,0,3,ccs,ami
+span=4,0,3,ccs,ami
+
+bchan=1,2
+dchan=3
+bchan=4,5
+dchan=6
+bchan=7,8
+dchan=9
+bchan=10,11
+dchan=12
+
diff -urNad --exclude=CVS --exclude=.svn ./qozap/zaptel.conf.octoBRI /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zaptel.conf.octoBRI
--- ./qozap/zaptel.conf.octoBRI	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/qozap/zaptel.conf.octoBRI	2005-07-14 07:01:09.223137552 +0100
@@ -0,0 +1,30 @@
+loadzone=nl
+defaultzone=nl
+# qozap span definitions
+# most of the values should be bogus because we are not really zaptel
+span=1,1,3,ccs,ami
+span=2,0,3,ccs,ami
+span=3,0,3,ccs,ami
+span=4,0,3,ccs,ami
+span=5,1,3,ccs,ami
+span=6,0,3,ccs,ami
+span=7,0,3,ccs,ami
+span=8,0,3,ccs,ami
+
+bchan=1,2
+dchan=3
+bchan=4,5
+dchan=6
+bchan=7,8
+dchan=9
+bchan=10,11
+dchan=12
+bchan=13,14
+dchan=15
+bchan=16,17
+dchan=18
+bchan=19,20
+dchan=21
+bchan=22,23
+dchan=24
+
diff -urNad --exclude=CVS --exclude=.svn ./README /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/README
--- ./README	2005-05-11 04:44:07.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/README	2005-07-14 06:58:23.964260720 +0100
@@ -1,6 +1,7 @@
 The Asterisk Open Source PBX
 by Mark Spencer <markster@digium.com>
-Copyright (C) 2001-2004 Digium
+Copyright (C) 2001-2004 Digium and others....
+Copyright (C) 2002-2004 Junghanns.NET GmbH and others....
 ================================================================
 * SECURITY
   It is imperative that you read and fully understand the contents of
@@ -23,14 +24,6 @@
   Asterisk is distributed under GNU General Public License.  The GPL also
 must apply to all loadable modules as well, except as defined below.
 
-  Digium, Inc. (formerly Linux Support Services) retains copyright to all 
-of the core Asterisk system, and therefore can grant, at its sole discretion, 
-the ability for companies, individuals, or organizations to create proprietary
-or Open Source (but non-GPL'd) modules which may be dynamically linked at
-runtime with the portions of Asterisk which fall under our copyright
-umbrella, or are distributed under more flexible licenses than GPL.  
-
-
   If you wish to use our code in other GPL programs, don't worry -- there
 is no requirement that you provide the same exemption in your GPL'd
 products (although if you've written a module for Asterisk we would
@@ -39,12 +32,6 @@
   Specific permission is also granted to OpenSSL and OpenH323 to link to
 Asterisk.
 
-  If you have any questions, whatsoever, regarding our licensing policy,
-please contact us.
-
-  Modules that are GPL-licensed and not available under Digium's 
-licensing scheme are added to the Asterisk-addons CVS module.
-  
 * REQUIRED COMPONENTS
 
 == Linux ==
diff -urNad --exclude=CVS --exclude=.svn ./res/res_features.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/res/res_features.c
--- ./res/res_features.c	2005-05-15 16:55:31.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/res/res_features.c	2005-07-14 07:00:47.010514384 +0100
@@ -7,6 +7,10 @@
  *
  * Mark Spencer <markster@digium.com>
  *
+ * Copyright (C) 2004, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  */
@@ -28,6 +32,7 @@
 #include <asterisk/manager.h>
 #include <asterisk/utils.h>
 #include <asterisk/adsi.h>
+#include <asterisk/indications.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>
@@ -51,6 +56,7 @@
 #define DEFAULT_TRANSFER_DIGIT_TIMEOUT 3000
 
 static char *parkedcall = "ParkedCall";
+static char *holdedcall = "HoldedCall";
 
 /* No more than 45 seconds parked before you do something with them */
 static int parkingtime = DEFAULT_PARK_TIME;
@@ -102,6 +108,20 @@
 "into the dialplan, although you should include the 'parkedcalls'\n"
 "context.\n";
 
+static char *autoanswerlogin = "AutoanswerLogin";
+
+static char *synopsis3 = "Log in for autoanswer";
+
+static char *descrip3 = "AutoanswerLogin(exten):"
+"Used to login to the autoanswer application for an extension.\n";
+
+static char *autoanswer = "Autoanswer";
+
+static char *synopsis4 = "Autoanswer a call";
+
+static char *descrip4 = "Autoanswer(exten):"
+"Used to autoanswer a call for an extension.\n";
+
 static struct ast_app *monitor_app=NULL;
 static int monitor_ok=1;
 
@@ -120,12 +140,51 @@
 	struct parkeduser *next;
 };
 
+struct holdeduser {
+	struct ast_channel *chan;
+	struct timeval start;
+	int parkingnum;
+	int cref;
+	int tei;
+	/* Where to go if our parking time expires */
+	char context[AST_MAX_EXTENSION];
+	char exten[AST_MAX_EXTENSION];
+	int priority;
+	int parkingtime;
+	char uniqueid[AST_MAX_UNIQUEID];
+	char uniqueidpeer[AST_MAX_UNIQUEID];
+	struct holdeduser *next;
+};
+
+/* auto answer user */
+struct aauser {
+	struct ast_channel *chan;
+	struct timeval start;
+	/* waiting on this extension/context */
+	char exten[AST_MAX_EXTENSION];
+	char context[AST_MAX_EXTENSION];
+	int priority;
+	int notquiteyet;
+	struct aauser *next;
+};
+
+ 
+static struct aauser *aalot;
+AST_MUTEX_DEFINE_STATIC(autoanswer_lock);
+static pthread_t autoanswer_thread;
+
 static struct parkeduser *parkinglot;
 
+static struct holdeduser *holdlist;
+
 AST_MUTEX_DEFINE_STATIC(parking_lock);
 
+AST_MUTEX_DEFINE_STATIC(holding_lock);
+
 static pthread_t parking_thread;
 
+static pthread_t holding_thread;
+
 STANDARD_LOCAL_USER;
 
 LOCAL_USER_DECL;
@@ -135,6 +194,12 @@
 	return parking_ext;
 }
 
+char *ast_parking_con(void)
+{
+	return parking_con;
+}
+
+
 char *ast_pickup_ext(void)
 {
 	return pickup_ext;
@@ -227,9 +292,10 @@
                                 "From: %s\r\n"
                                 "Timeout: %ld\r\n"
                                 "CallerID: %s\r\n"
+                                "Uniqueid: %s\r\n"
                                 ,pu->parkingnum, pu->chan->name, peer->name
                                 ,(long)pu->start.tv_sec + (long)(pu->parkingtime/1000) - (long)time(NULL)
-                                ,(pu->chan->callerid ? pu->chan->callerid : "")
+                                ,(pu->chan->callerid ? pu->chan->callerid : ""), pu->chan->uniqueid
                                 );
 
 			if (peer) {
@@ -290,6 +356,8 @@
 		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
 		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
 		chan->priority = rchan->priority;
+		/* might be dirty but we want trackable channels */
+		strncpy(chan->uniqueid, rchan->uniqueid, sizeof(chan->uniqueid) - 1);
 		/* Make the masq execute */
 		f = ast_read(chan);
 		if (f)
@@ -306,7 +374,7 @@
 {
 	/* Copy voice back and forth between the two channels.  Give the peer
 	   the ability to transfer calls with '#<extension' syntax. */
-	int len;
+	struct tone_zone_sound *ts;
 	struct ast_frame *f;
 	struct ast_channel *who;
 	char newext[256], *ptr;
@@ -447,29 +515,23 @@
 				memset(newext, 0, sizeof(newext));
 				ptr = newext;
 
-					/* Transfer */
-				if ((res=ast_streamfile(transferer, "pbx-transfer", transferer->language))) {
-					ast_moh_stop(transferee);
-					ast_autoservice_stop(transferee);
-					break;
-				}
-				if ((res=ast_waitstream(transferer, AST_DIGIT_ANY)) < 0) {
-					ast_moh_stop(transferee);
-					ast_autoservice_stop(transferee);
-					break;
-				}
-				ast_stopstream(transferer);
-				if (res > 0) {
-					/* If they've typed a digit already, handle it */
-					newext[0] = res;
-					ptr++;
-					len --;
+				ts = ast_get_indication_tone(transferer->zone, "dial");
+				if (ts && ts->data[0])
+				    res = ast_playtones_start(transferer, 0, ts->data, 0);
+				else
+				    res = ast_playtones_start(transferer, 0, "400", 0);
+				
+				if (res) {
+				    ast_moh_stop(transferee);
+				    ast_autoservice_stop(transferee);
+				    break;
 				}
 				res = 0;
 				while (strlen(newext) < sizeof(newext) - 1) {
 					res = ast_waitfordigit(transferer, transferdigittimeout);
 					if (res < 1) 
 						break;
+					ast_playtones_stop(transferer);
 					if (res == '#')
 						break;
 					*(ptr++) = res;
@@ -514,7 +576,7 @@
 							ast_verbose(VERBOSE_PREFIX_3 "Transferring %s to '%s' (context %s) priority 1\n"
 								,transferee->name, newext, transferer_real_context);
 						if (ast_async_goto(transferee, transferer_real_context, newext, 1))
-							ast_log(LOG_WARNING, "Async goto fialed :(\n");
+							ast_log(LOG_WARNING, "Async goto failed :(\n");
 						res = -1;
 					} else {
 						/* Set the channel's new extension, since it exists, using transferer context */
@@ -743,6 +805,282 @@
 	return res;
 }
 
+int ast_hold_call(struct ast_channel *chan, struct ast_channel *peer)
+{
+	/* We put the user in the parking list, then wake up the parking thread to be sure it looks
+	   after these channels too */
+	struct holdeduser *pu;
+	pu = malloc(sizeof(struct holdeduser));
+	if (pu) {
+		memset(pu, 0, sizeof(pu));
+		ast_mutex_lock(&holding_lock);
+		chan->appl = "Holded Call";
+		chan->data = NULL; 
+
+		pu->chan = chan;
+		strncpy(pu->uniqueid, chan->uniqueid, sizeof(pu->uniqueid));
+		strncpy(pu->uniqueidpeer, peer->uniqueid, sizeof(pu->uniqueidpeer));
+		/* Start music on hold */
+		ast_moh_start(pu->chan, NULL);
+		gettimeofday(&pu->start, NULL);
+		pu->next = holdlist;
+		holdlist = pu;
+		ast_mutex_unlock(&holding_lock);
+		/* Wake up the (presumably select()ing) thread */
+		pthread_kill(holding_thread, SIGURG);
+
+		manager_event(EVENT_FLAG_CALL, "HoldedCall",
+                            "Channel1: %s\r\n"
+                            "Channel2: %s\r\n"
+                    	    "Uniqueid1: %s\r\n"
+                    	    "Uniqueid2: %s\r\n"
+                            ,pu->chan->name, peer->name, pu->chan->uniqueid, peer->uniqueid);
+
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	return 0;
+}
+
+int ast_masq_hold_call(struct ast_channel *rchan, struct ast_channel *peer)
+{
+	struct ast_channel *chan;
+	struct ast_frame *f;
+	/* Make a new, fake channel that we'll use to masquerade in the real one */
+	chan = ast_channel_alloc(0);
+	if (chan) {
+		/* Let us keep track of the channel name */
+		snprintf(chan->name, sizeof (chan->name), "Onhold/%s",rchan->name);
+		/* Make formats okay */
+		chan->readformat = rchan->readformat;
+		chan->writeformat = rchan->writeformat;
+		ast_channel_masquerade(chan, rchan);
+		/* Setup the extensions and such */
+		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
+		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
+		chan->priority = rchan->priority;
+		/* this might be dirty, but we need to preserve the uniqueid */
+		strncpy(chan->uniqueid, rchan->uniqueid, sizeof(chan->uniqueid) - 1);
+		/* Make the masq execute */
+		f = ast_read(chan);
+		if (f)
+			ast_frfree(f);
+		ast_hold_call(chan, peer);
+		return -1;
+    	} else {
+		ast_log(LOG_WARNING, "Unable to create holded channel\n");
+		return -1;
+	}
+	return 0;
+}
+
+int ast_retrieve_call(struct ast_channel *chan, char *uniqueid)
+{
+	int res=-1, dres=-1;
+	struct ast_channel *peer=NULL;
+	struct ast_bridge_config config;
+
+	peer = ast_get_holded_call(uniqueid);
+
+	/* JK02: it helps to answer the channel if not already up */
+	if (chan->_state != AST_STATE_UP) {
+		ast_answer(chan);
+	}
+
+	if (peer) {
+		ast_mutex_unlock(&peer->lock);
+		ast_moh_stop(peer);
+		res = ast_channel_make_compatible(chan, peer);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Could not make channels %s and %s compatible for bridge\n", chan->name, peer->name);
+			ast_hangup(peer);
+			return -1;
+		}
+		/* This runs sorta backwards, since we give the incoming channel control, as if it
+		   were the person called. */
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s connected to holded call %s\n", chan->name, peer->name);
+
+		memset(&config,0,sizeof(struct ast_bridge_config));
+		config.allowredirect_in = 1;
+		config.allowredirect_out = 1;
+		config.allowdisconnect_out = 0;
+		config.allowdisconnect_in = 0;
+		config.timelimit = 0;
+		config.play_warning = 0;
+		config.warning_freq = 0;
+		config.warning_sound=NULL;
+		res = ast_bridge_call(chan,peer,&config);
+
+		/* Simulate the PBX hanging up */
+		if (res != AST_PBX_NO_HANGUP_PEER)
+			ast_hangup(peer);
+		return res;
+	} else {
+		/* XXX Play a message XXX */
+	  dres = ast_streamfile(chan, "pbx-invalidpark", chan->language);
+	  if (!dres)
+	    dres = ast_waitstream(chan, "");
+	  else {
+	    ast_log(LOG_WARNING, "ast_streamfile of %s failed on %s\n", "pbx-invalidpark", chan->name);
+	    dres = 0;
+	  }
+	}
+	return res;
+}
+
+int ast_retrieve_call_to_death(char *uniqueid)
+{
+	int res=-1;
+	struct ast_channel *peer=NULL;
+
+	peer = ast_get_holded_call(uniqueid);
+
+	if (peer) {
+		res=0;
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s removed from hold.\n", peer->name);
+		ast_mutex_unlock(&peer->lock);
+		ast_hangup(peer);
+	} else {
+		ast_log(LOG_WARNING, "Could not find channel with uniqueid %s to retrieve.\n", uniqueid);
+	}
+	return res;
+}
+
+struct ast_channel *ast_get_holded_call(char *uniqueid)
+{
+	int res=-1;
+	struct ast_channel *peer=NULL;
+	struct holdeduser *pu, *pl=NULL;
+
+	ast_mutex_lock(&holding_lock);
+	pu = holdlist;
+	while(pu) {
+		if (!strncmp(uniqueid,pu->uniqueid,sizeof(pu->uniqueid))) {
+			if (pl)
+				pl->next = pu->next;
+			else
+				holdlist = pu->next; 
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&holding_lock);
+	if (pu) {
+		peer = ast_get_channel_by_uniqueid_locked(pu->uniqueid);
+		free(pu);
+		if (peer) {
+		    res=0;
+		    if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s removed from hold.\n", peer->name);
+		    ast_moh_stop(peer);
+		    return peer;
+		} else {
+		    if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Could not find channel with uniqueid %s to retrieve.\n", uniqueid);
+		    return NULL;
+		}
+	} else {
+		ast_log(LOG_WARNING, "Could not find channel with uniqueid %s to retrieve.\n", uniqueid);
+	}
+	return NULL;
+}
+
+/* this is our autmagically service thread that keeps channels onhold happy */
+static void *do_holding_thread(void *ignore)
+{
+	int ms, tms, max;
+	struct holdeduser *pu, *pl, *pt = NULL;
+	struct timeval tv;
+	struct ast_frame *f;
+	int x;
+	fd_set rfds, efds;
+	fd_set nrfds, nefds;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (;;) {
+		ms = -1;
+		max = -1;
+		ast_mutex_lock(&holding_lock);
+		pl = NULL;
+		pu = holdlist;
+		gettimeofday(&tv, NULL);
+		FD_ZERO(&nrfds);
+		FD_ZERO(&nefds);
+		while(pu) {
+			tms = (tv.tv_sec - pu->start.tv_sec) * 1000 + (tv.tv_usec - pu->start.tv_usec) / 1000;
+				for (x=0;x<AST_MAX_FDS;x++) {
+					if ((pu->chan->fds[x] > -1) && (FD_ISSET(pu->chan->fds[x], &rfds) || FD_ISSET(pu->chan->fds[x], &efds))) {
+						if (FD_ISSET(pu->chan->fds[x], &efds))
+							pu->chan->exception = 1;
+						pu->chan->fdno = x;
+						/* See if they need servicing */
+						f = ast_read(pu->chan);
+						if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass ==  AST_CONTROL_HANGUP))) {
+							/* There's a problem, hang them up*/
+							if (option_verbose > 1) 
+								ast_verbose(VERBOSE_PREFIX_2 "%s got tired of being onhold\n", pu->chan->name);
+							ast_hangup(pu->chan);
+							/* find the corresponding channel and hang them up too! */
+							/* but only if it is not bridged yet! */
+							/* And take them out of the parking lot */
+							if (pl) 
+								pl->next = pu->next;
+							else
+								holdlist = pu->next;
+							pt = pu;
+							pu = pu->next;
+							free(pt);
+							break;
+						} else {
+							/* XXX Maybe we could do something with packets, like dial "0" for operator or something XXX */
+							ast_frfree(f);
+							goto std;	/* XXX Ick: jumping into an else statement??? XXX */
+						}
+					}
+				}
+				if (x >= AST_MAX_FDS) {
+std:					for (x=0;x<AST_MAX_FDS;x++) {
+						/* Keep this one for next one */
+						if (pu->chan->fds[x] > -1) {
+							FD_SET(pu->chan->fds[x], &nrfds);
+							FD_SET(pu->chan->fds[x], &nefds);
+							if (pu->chan->fds[x] > max)
+								max = pu->chan->fds[x];
+						}
+					}
+					/* Keep track of our longest wait */
+					if ((tms < ms) || (ms < 0))
+						ms = tms;
+					pl = pu;
+					pu = pu->next;
+				}
+		}
+		ast_mutex_unlock(&holding_lock);
+		rfds = nrfds;
+		efds = nefds;
+		tv.tv_sec = ms / 1000;
+		tv.tv_usec = (ms % 1000) * 1000;
+		/* Wait for something to happen */
+		ast_select(max + 1, &rfds, NULL, &efds, (ms > -1) ? &tv : NULL);
+		pthread_testcancel();
+	}
+	return NULL;	/* Never reached */
+}
+
+static int retrieve_call_exec(struct ast_channel *chan, void *data) {
+	int res=0;
+	struct localuser *u;
+	char *uniqueid = (char *)data;
+	LOCAL_USER_ADD(u);
+	    res = ast_retrieve_call(chan, uniqueid);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
 static int park_exec(struct ast_channel *chan, void *data)
 {
 	int res=0;
@@ -898,11 +1236,12 @@
 			"Channel: %s\r\n"
 			"Timeout: %ld\r\n"
 			"CallerID: %s\r\n"
+                        "Uniqueid: %s\r\n"
 			"%s"
 			"\r\n"
                         ,cur->parkingnum, cur->chan->name
                         ,(long)cur->start.tv_sec + (long)(cur->parkingtime/1000) - (long)time(NULL)
-			,(cur->chan->callerid ? cur->chan->callerid : "")
+			,(cur->chan->callerid ? cur->chan->callerid : ""), cur->chan->uniqueid
 			,idText);
 			ast_mutex_unlock(&s->lock);
 
@@ -920,6 +1259,388 @@
 }
 
 
+static int handle_autoanswer(int fd, int argc, char *argv[])
+{
+	struct aauser *cur;
+
+	ast_cli(fd, "%25s %10s %15s \n", "Channel"
+		, "Extension", "Context");
+
+	ast_mutex_lock(&autoanswer_lock);
+
+	cur=aalot;
+	while(cur) {
+		ast_cli(fd, "%25s %10s %15s\n",cur->chan->name, cur->exten, cur->context);
+
+		cur = cur->next;
+	}
+
+	ast_mutex_unlock(&autoanswer_lock);
+
+	return RESULT_SUCCESS;
+}
+static char showautoanswer_help[] =
+"Usage: show autoanswer\n"
+"       Lists currently logged in autoanswr channels.\n";
+
+static struct ast_cli_entry showautoanswer =
+{ { "show", "autoanswer", NULL }, handle_autoanswer, "Lists autoanswer channels", showautoanswer_help };
+
+int ast_masq_autoanswer_login(struct ast_channel *rchan, void *data)
+{
+	struct ast_channel *chan;
+	struct ast_frame *f;
+	/* Make a new, fake channel that we'll use to masquerade in the real one */
+	chan = ast_channel_alloc(0);
+	if (chan) {
+		/* Let us keep track of the channel name */
+		snprintf(chan->name, sizeof (chan->name), "Autoanswer/%s",rchan->name);
+		/* Make formats okay */
+		chan->readformat = rchan->readformat;
+		chan->writeformat = rchan->writeformat;
+		ast_channel_masquerade(chan, rchan);
+		/* Setup the extensions and such */
+		strncpy(chan->context, rchan->context, sizeof(chan->context) - 1);
+		strncpy(chan->exten, rchan->exten, sizeof(chan->exten) - 1);
+		chan->priority = rchan->priority;
+		/* Make the masq execute */
+		f = ast_read(chan);
+		if (f)
+			ast_frfree(f);
+		ast_autoanswer_login(chan, data);
+	} else {
+		ast_log(LOG_WARNING, "Unable to create aa channel\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int autoanswer_login_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	LOCAL_USER_ADD(u);
+	if (!data) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires an argument (extension number)\n");
+		return -1;
+	}
+	res = ast_masq_autoanswer_login(chan, data);
+	LOCAL_USER_REMOVE(u);
+	return res; 
+}
+
+int ast_autoanswer_login(struct ast_channel *chan, void *data)
+{
+	/* We put the user in the parking list, then wake up the parking thread to be sure it looks
+	   after these channels too */
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu,*pl = NULL;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+	    ast_log(LOG_NOTICE, "Logout old Channel %s for %s@%s.\n",pu->chan->name, pu->exten, pu->context);
+	    manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                    			    "Channel: %s\r\n"
+                    			    "Uniqueid: %s\r\n"
+                    			    "Context: %s\r\n"
+                    			    "Exten: %s\r\n"
+                    			,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+	    ast_hangup(pu->chan);
+	    free(pu);
+	}
+	pu = malloc(sizeof(struct aauser));
+	if (pu) {
+		memset(pu, 0, sizeof(pu));
+		ast_mutex_lock(&autoanswer_lock);
+		chan->appl = "Autoanswer";
+		chan->data = NULL; 
+
+		pu->chan = chan;
+		if (chan->_state != AST_STATE_UP) {
+		    ast_answer(chan);
+		}
+
+		/* Start music on hold */
+		ast_moh_start(pu->chan, NULL);
+		gettimeofday(&pu->start, NULL);
+		strncpy(pu->exten, aaexten, sizeof(pu->exten)-1);
+		strncpy(pu->context, aacontext, sizeof(pu->exten)-1);
+		pu->next = aalot;
+		aalot = pu;
+		con = ast_context_find(aacontext);
+		if (!con) {
+			con = ast_context_create(NULL,aacontext, registrar);
+			if (!con) {
+				ast_log(LOG_ERROR, "Context '%s' does not exist and unable to create\n", aacontext);
+			}
+		}
+		if (con) {
+			snprintf(exten, sizeof(exten), "%s", aaexten);
+			ast_add_extension2(con, 1, exten, 1, NULL, autoanswer, strdup((char *)data), free, registrar);
+		}
+
+		ast_mutex_unlock(&autoanswer_lock);
+		/* Wake up the (presumably select()ing) thread */
+		pthread_kill(autoanswer_thread, SIGURG);
+		if (option_verbose > 1) 
+			ast_verbose(VERBOSE_PREFIX_2 "Autoanswer login from %s for %s@%s.\n", pu->chan->name, pu->exten, pu->context);
+			manager_event(EVENT_FLAG_CALL, "AutoanswerLogin",
+                                "Channel: %s\r\n"
+                                "Uniqueid: %s\r\n"
+        			"Context: %s\r\n"
+                    		"Exten: %s\r\n"
+                    		,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+
+			return 0;
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	return 0;
+}
+
+static void *do_autoanswer_thread(void *ignore)
+{
+	int ms, tms, max;
+	struct ast_context *con;
+	char exten[AST_MAX_EXTENSION];
+	struct aauser *pu, *pl, *pt = NULL;
+	struct timeval tv;
+	struct ast_frame *f;
+	int x;
+	fd_set rfds, efds;
+	fd_set nrfds, nefds;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (;;) {
+		ms = -1;
+		max = -1;
+		ast_mutex_lock(&autoanswer_lock);
+		pl = NULL;
+		pu = aalot;
+		gettimeofday(&tv, NULL);
+		FD_ZERO(&nrfds);
+		FD_ZERO(&nefds);
+		while(pu) {
+			tms = (tv.tv_sec - pu->start.tv_sec) * 1000 + (tv.tv_usec - pu->start.tv_usec) / 1000;
+			for (x=0;x<AST_MAX_FDS;x++) {
+				if ((pu->chan->fds[x] > -1) && (FD_ISSET(pu->chan->fds[x], &rfds) || FD_ISSET(pu->chan->fds[x], &efds))) {
+					if (FD_ISSET(pu->chan->fds[x], &efds))
+						pu->chan->exception = 1;
+					pu->chan->fdno = x;
+					/* See if they need servicing */
+					f = ast_read(pu->chan);
+					if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass ==  AST_CONTROL_HANGUP))) {
+						/* There's a problem, hang them up*/
+						if (option_verbose > 1) 
+							ast_verbose(VERBOSE_PREFIX_2 "%s logged out of autoanswer app\n", pu->chan->name);
+						manager_event(EVENT_FLAG_CALL, "AutoanswerLogout",
+                            			    "Channel: %s\r\n"
+                            			    "Uniqueid: %s\r\n"
+                    				    "Context: %s\r\n"
+                    				    "Exten: %s\r\n"
+                    				,pu->chan->name, pu->chan->uniqueid, pu->context, pu->exten);
+						ast_hangup(pu->chan);
+						con = ast_context_find(pu->context);
+						if (con) {
+						    snprintf(exten, sizeof(exten), "%s", pu->exten);
+						    if (ast_context_remove_extension2(con, exten, 1, registrar))
+							ast_log(LOG_WARNING, "Whoa, failed to remove the extension!\n");
+						} else {
+							ast_log(LOG_WARNING, "Whoa, no %s context?\n", pu->exten);
+						}
+						/* And take them out of the parking lot */
+						if (pl) 
+							pl->next = pu->next;
+						else
+							aalot = pu->next;
+						pt = pu;
+						pu = pu->next;
+						free(pt);
+						break;
+					} else {
+						/* XXX Maybe we could do something with packets, like dial "0" for operator or something XXX */
+						ast_frfree(f);
+						goto std;	/* XXX Ick: jumping into an else statement??? XXX */
+					}
+				}
+			}
+			if (x >= AST_MAX_FDS) {
+std:				for (x=0;x<AST_MAX_FDS;x++) {
+					/* Keep this one for next one */
+					if (pu->chan->fds[x] > -1) {
+						FD_SET(pu->chan->fds[x], &nrfds);
+						FD_SET(pu->chan->fds[x], &nefds);
+						if (pu->chan->fds[x] > max)
+							max = pu->chan->fds[x];
+					}
+				}
+				/* Keep track of our longest wait */
+				if ((tms < ms) || (ms < 0))
+					ms = tms;
+				pl = pu;
+				pu = pu->next;
+			}
+		}
+		ast_mutex_unlock(&autoanswer_lock);
+		rfds = nrfds;
+		efds = nefds;
+		tv.tv_sec = ms / 1000;
+		tv.tv_usec = (ms % 1000) * 1000;
+		/* Wait for something to happen */
+		ast_select(max + 1, &rfds, NULL, &efds, (ms > -1) ? &tv : NULL);
+		pthread_testcancel();
+	}
+	return NULL;	/* Never reached */
+}
+
+static int autoanswer_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	struct ast_channel *peer=NULL;
+	struct aauser *pu, *pl=NULL;
+	struct ast_bridge_config config;
+	char *s, *stringp, *aacontext, *aaexten = NULL;
+	char datastring[80];
+
+	if (!data) {
+		ast_log(LOG_WARNING, "Autoanswer requires an argument (extension number)\n");
+		return -1;
+	}
+	s = ast_strdupa((void *) data);
+	stringp=s;
+	aacontext = strsep(&stringp, "|");
+	aaexten = strsep(&stringp, "|");
+	if (!aaexten) {
+	    aaexten = aacontext;
+	    aacontext = NULL;
+	}
+	if (!aaexten) {
+		ast_log(LOG_WARNING, "AutoanswerLogin requires at least an extension!\n");
+		return -1;
+	} else {
+		if (!aacontext) {
+			aacontext = "default";
+		}
+	}
+
+	LOCAL_USER_ADD(u);
+	ast_mutex_lock(&autoanswer_lock);
+	pu = aalot;
+	while(pu) {
+		if ((!strncasecmp(pu->exten, aaexten, sizeof(pu->exten)-1)) && (!strncasecmp(pu->context, aacontext, sizeof(pu->context)-1))){
+			if (pl)
+				pl->next = pu->next;
+			else
+				aalot = pu->next;
+			break;
+		}
+		pl = pu;
+		pu = pu->next;
+	}
+	ast_mutex_unlock(&autoanswer_lock);
+	if (pu) {
+		peer = pu->chan;
+		free(pu);
+		pu = NULL;
+	}
+	/* JK02: it helps to answer the channel if not already up */
+	if (chan->_state != AST_STATE_UP) {
+		ast_answer(chan);
+	}
+
+	if (peer) {
+		ast_moh_stop(peer);
+		/* Play a courtesy beep in the callED channel to prefix the bridge connecting */	
+		if (!ast_strlen_zero(courtesytone)) {
+			if (!ast_streamfile(peer, courtesytone, peer->language)) {
+				if (ast_waitstream(peer, "") < 0) {
+					ast_log(LOG_WARNING, "Failed to play courtesy tone!\n");
+					ast_hangup(peer);
+					return -1;
+				}
+			}
+		}
+ 
+		res = ast_channel_make_compatible(chan, peer);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Could not make channels %s and %s compatible for bridge\n", chan->name, peer->name);
+			ast_hangup(peer);
+			return -1;
+		}
+		/* This runs sorta backwards, since we give the incoming channel control, as if it
+		   were the person called. */
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Channel %s autoanswered  %s\n", peer->name, chan->name);
+		manager_event(EVENT_FLAG_CALL, "Autoanswer",
+                    "Channel: %s\r\n"
+                    "Uniqueid: %s\r\n"
+                    "Channel2: %s\r\n"
+                    "Uniqueid2: %s\r\n"
+                    "Context: %s\r\n"
+                    "Exten: %s\r\n"
+                ,chan->name, chan->uniqueid, peer->name, peer->uniqueid, aacontext, aaexten);
+
+
+		memset(&config,0,sizeof(struct ast_bridge_config));
+		config.allowredirect_in = 1;
+		config.allowredirect_out = 0;
+		config.allowdisconnect_in = 1;
+		config.allowdisconnect_out = 0;
+		config.timelimit = 0;
+		config.play_warning = 0;
+		config.warning_freq = 0;
+		config.warning_sound=NULL;
+		res = ast_bridge_call(chan,peer,&config);
+
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "returning from bridge %s\n", peer->name);
+			/* relogin */
+		snprintf(datastring, sizeof(datastring) - 1, "%s|%s", aacontext, aaexten);
+		ast_autoanswer_login(peer, datastring);
+		return res;
+	} else {
+		if (option_verbose > 2) 
+			ast_verbose(VERBOSE_PREFIX_3 "Nobody logged in for autoanswer %s@%s\n", aaexten, aacontext);
+		res = -1;
+	}
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
 
 int load_module(void)
 {
@@ -930,6 +1651,7 @@
 	struct ast_variable *var;
 
 	ast_cli_register(&showparked);
+	ast_cli_register(&showautoanswer);
 
 	cfg = ast_load("features.conf");
 	if (!cfg) {
@@ -984,12 +1706,19 @@
 	}
 	ast_add_extension2(con, 1, ast_parking_ext(), 1, NULL, parkcall, strdup(""), FREE, registrar);
 	ast_pthread_create(&parking_thread, NULL, do_parking_thread, NULL);
+	ast_pthread_create(&holding_thread, NULL, do_holding_thread, NULL);
 	res = ast_register_application(parkedcall, park_exec, synopsis, descrip);
 	if (!res)
 		res = ast_register_application(parkcall, park_call_exec, synopsis2, descrip2);
 	if (!res) {
 		ast_manager_register( "ParkedCalls", 0, manager_parking_status, "List parked calls" );
 	}
+	res = ast_register_application(holdedcall, retrieve_call_exec, synopsis, descrip);
+	ast_pthread_create(&autoanswer_thread, NULL, do_autoanswer_thread, NULL);
+	if (!res)
+		res = ast_register_application(autoanswerlogin, autoanswer_login_exec, synopsis3, descrip3);
+	if (!res)
+		res = ast_register_application(autoanswer, autoanswer_exec, synopsis4, descrip4);
 	return res;
 }
 
@@ -1032,7 +1761,10 @@
 	STANDARD_HANGUP_LOCALUSERS;
 
 	ast_manager_unregister( "ParkedCalls" );
+	ast_cli_unregister(&showautoanswer);
 	ast_cli_unregister(&showparked);
+	ast_unregister_application(autoanswer);
+	ast_unregister_application(autoanswerlogin);
 	ast_unregister_application(parkcall);
 	return ast_unregister_application(parkedcall);
 }
diff -urNad --exclude=CVS --exclude=.svn ./res_watchdog.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/res_watchdog.c
--- ./res_watchdog.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/res_watchdog.c	2005-07-14 07:00:47.010514384 +0100
@@ -0,0 +1,151 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Resource to make watchdogs happy
+ *
+ * Copyright (C) 2005, Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/lock.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/options.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <asterisk/say.h>
+#include <asterisk/channel_pvt.h>
+#include <asterisk/features.h>
+#include <asterisk/musiconhold.h>
+#include <asterisk/config.h>
+#include <asterisk/cli.h>
+#include <asterisk/manager.h>
+#include <asterisk/utils.h>
+#include <asterisk/adsi.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/signal.h>
+#include <netinet/in.h>
+
+/* Registrar for operations */
+
+static struct watchdog_pvt *watchdogs = NULL;
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+typedef struct watchdog_pvt {
+    char device[80];
+    int fd;
+    int type;
+    int interval;
+    pthread_t watchdog_thread;
+    struct watchdog_pvt *next;
+} watchdog_pvt;
+
+static void *do_watchdog_thread(void *data) {
+    struct watchdog_pvt *woof = (struct watchdog_pvt *)data;
+    for (;;) {
+	if (woof->fd) {
+	    write(woof->fd, "PING\n", 5);
+	}
+	usleep(woof->interval * 1000);
+    }
+    return NULL;
+}
+
+
+int load_module(void)
+{
+	int res = 0;
+	char *cat, *utype, *udevice, *uinterval;
+	struct ast_config *cfg;
+	struct watchdog_pvt *woof = NULL;
+
+	cfg = ast_load("watchdog.conf");
+	if (cfg) {
+	    cat = ast_category_browse(cfg, NULL);
+	    while(cat) {
+		cat = ast_category_browse(cfg, cat);
+		utype = ast_variable_retrieve(cfg, cat, "type");
+		if (utype) {
+		    ast_log(LOG_NOTICE, "type = %s\n", utype);
+		}
+		udevice = ast_variable_retrieve(cfg, cat, "device");
+		if (udevice) {
+		    ast_log(LOG_NOTICE, "device = %s\n", udevice);
+		}
+		uinterval = ast_variable_retrieve(cfg, cat, "interval");
+		if (uinterval) {
+		    ast_log(LOG_NOTICE, "interval = %s\n", uinterval);
+		}
+		if (uinterval && udevice && utype) {
+		    woof = malloc(sizeof(struct watchdog_pvt));
+		    if (!woof) {
+			ast_log(LOG_ERROR, "unable to malloc!\n");
+			return -1;
+		    }
+		    memset(woof, 0x0, sizeof(struct watchdog_pvt));
+		    strncpy(woof->device, udevice, sizeof(woof->device) - 1);
+		    
+		    woof->interval = atoi(uinterval);;
+		    woof->next = watchdogs;
+		    watchdogs = woof;
+		    woof->fd = open(woof->device, O_WRONLY | O_SYNC);
+		    if (woof->fd) {
+			if (!strncmp(utype, "isdnguard", sizeof(utype))) {
+			    woof->type = 1;
+			    write(woof->fd, "START\n", 6);
+			}
+			ast_pthread_create(&woof->watchdog_thread, NULL, do_watchdog_thread, woof);
+		    } else {
+			ast_log(LOG_WARNING, "error opening watchdog device %s !\n", woof->device);
+		    }
+		}
+	    }
+    	    ast_destroy(cfg);
+	}
+	return res;
+}
+
+
+int unload_module(void)
+{
+	struct watchdog_pvt *dogs, *woof;
+	STANDARD_HANGUP_LOCALUSERS;
+	dogs = watchdogs;
+	while (dogs) {
+	    pthread_cancel(dogs->watchdog_thread);
+	    woof = dogs->next;
+	    free(dogs);
+	    dogs = woof;
+	}
+	return 0;
+}
+
+char *description(void)
+{
+	return "Watchdog Resource";
+}
+
+int usecount(void)
+{
+	return 1;
+}
+
+char *key()
+{
+	return ASTERISK_GPL_KEY;
+}
diff -urNad --exclude=CVS --exclude=.svn ./rtp.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/rtp.c
--- ./rtp.c	2005-05-31 13:55:43.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/rtp.c	2005-07-14 07:00:47.011514232 +0100
@@ -417,6 +417,11 @@
 	struct rtpPayloadType rtpPT;
 	
 	len = sizeof(sin);
+
+	/* XXX SYMPTON CURE, DIRTY FIX, CHECK, BEGIN */
+	if (!rtp)
+	    return &null_frame;
+	/* XXX SYMPTON CURE, DIRTY FIX, CHECK, END */
 	
 	/* Cache where the header will go */
 	res = recvfrom(rtp->s, rtp->rawdata + AST_FRIENDLY_OFFSET, sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET,
diff -urNad --exclude=CVS --exclude=.svn ./transcap.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/transcap.h
--- ./transcap.h	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/transcap.h	2005-07-14 07:00:28.680301000 +0100
@@ -0,0 +1,33 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * General Asterisk channel definitions.
+ * 
+ * Copyright (C) 1999 - 2005, Digium, Inc.
+ *
+ * Matthew Fredrickson <creslin@digium.com>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_TRANSCAP_H
+#define _ASTERISK_TRANSCAP_H
+
+/* These definitions are taken directly out of libpri.h and used here.
+ * DO NOT change them as it will cause unexpected behavior in channels
+ * that utilize these fields.
+ */
+
+#define AST_TRANS_CAP_SPEECH				0x0
+#define AST_TRANS_CAP_DIGITAL				0x08
+#define AST_TRANS_CAP_RESTRICTED_DIGITAL		0x09
+#define AST_TRANS_CAP_3_1K_AUDIO			0x10
+#define AST_TRANS_CAP_7K_AUDIO				0x11	/* Depriciated ITU Q.931 (05/1998)*/
+#define AST_TRANS_CAP_DIGITAL_W_TONES			0x11
+#define AST_TRANS_CAP_VIDEO				0x18
+
+#define IS_DIGITAL(cap)\
+	(cap) & AST_TRANS_CAP_DIGITAL ? 1 : 0
+
+#endif /* _ASTERISK_TRANSCAP_H */
diff -urNad --exclude=CVS --exclude=.svn ./watchdog.conf.sample /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/watchdog.conf.sample
--- ./watchdog.conf.sample	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/watchdog.conf.sample	2005-07-14 07:00:10.546057824 +0100
@@ -0,0 +1,22 @@
+;
+; Configuration file for res_watchdog
+;
+; type     = isdnguard | watchdog
+; device   = /dev/...
+; interval = interval to trigger the watchdog in ms
+
+;[ISDNguard-direct]
+;type = isdnguard
+;device = /dev/ttyS0
+;interval = 200
+
+;[ISDNguard-with-daemon]
+;type = isdnguard
+;device = /var/run/guard.ctl
+;interval = 200
+
+;[kernel_watchdog]
+;type = watchdog
+;device = /dev/watchdog
+;interval = 100
+
diff -urNad --exclude=CVS --exclude=.svn ./zaphfc/Makefile /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/Makefile
--- ./zaphfc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/Makefile	2005-07-14 07:01:19.171625152 +0100
@@ -0,0 +1,118 @@
+KINCLUDES = /usr/src/linux/include
+BRISTUFFBASE = $(shell dirname `pwd`)
+
+ZAP = $(shell [ -f $(BRISTUFFBASE)/zaptel-1.0.9/zaptel.h ] && echo "-I$(BRISTUFFBASE)/zaptel-1.0.9")
+RTAI = $(shell [ -f /usr/realtime/include/rtai.h ] && echo "-DRTAITIMING -I/usr/realtime/include")
+
+HOSTCC=gcc
+
+CFLAGS+=-I. $(ZAP) $(RTAI) -O2 -g -Wall -DBUILDING_TONEZONE 
+CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+
+KFLAGS=-D__KERNEL__ -DMODULE -DEXPORT_SYMTAB -fomit-frame-pointer -O2 -Wall -I$(KINCLUDES) $(ZAP) $(RTAI) -Wall
+KFLAGS+=$(shell [ -f $(KINCLUDES)/linux/modversions.h ] && echo "-DMODVERSIONS -include $(KINCLUDES)/linux/modversions.h")
+KFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-msoft-float -fsigned-char"; fi)
+
+
+BUILDVER=$(shell if uname -r | grep -q ^2.6; then echo "linux26"; else echo "linux24"; fi)
+
+MODCONF=$(shell if [ -d $(INSTALL_PREFIX)/etc/modprobe.d ]; then echo "$(INSTALL_PREFIX)/etc/modprobe.d/zaptel"; elif [ -d $(INSTALL_PREFIX)/etc/modutils ]; then echo "$(INSTALL_PREFIX)/etc/modutils/zaptel"; elif [ -f $(INSTALL_PREFIX)/etc/modprobe.conf ]; then echo "$(INSTALL_PREFIX)/modprobe.conf"; elif [ -f $(INSTALL_PREFIX)/etc/modules.conf ]; then echo "$(INSTALL_PREFIX)/etc/modules.conf"; else echo $(INSTALL_PREFIX)/etc/conf.modules ; fi)
+
+OBJS=zaphfc.o
+
+MODULES=zaphfc
+
+MODULESO=$(shell for x in $(MODULES); do echo "$$x.o "; done )
+MODULESKO=$(shell for x in $(MODULES); do echo "$$x.ko "; done )
+
+PWD=$(shell pwd)
+
+obj-m := $(MODULESO)
+
+all: $(BUILDVER)
+
+linux24: $(OBJS)
+	sync
+
+
+zaphfc.o: zaphfc.c zaphfc.h
+	$(CC) -c zaphfc.c $(KFLAGS)
+
+clean:	
+	rm -f $(OBJS) *.ko *.mod.c *.mod.o .*o.cmd *~
+	rm -rf .tmp_versions
+
+test: all
+	modprobe zaptel
+	insmod ./zaphfc.o
+	cat /proc/interrupts
+	sleep 1
+	cat /proc/interrupts
+	rmmod zaphfc
+	rmmod zaptel
+
+load:	load$(BUILDVER)
+
+loadNT:	load$(BUILDVER)NT
+
+load-debug:	load$(BUILDVER)-debug
+
+loadNT-debug:	load$(BUILDVER)NT-debug
+
+loadlinux24: all
+	modprobe zaptel
+	insmod ./zaphfc.o
+	ztcfg -v
+
+loadlinux24-debug: all
+	modprobe zaptel
+	insmod ./zaphfc.o debug=1
+	ztcfg -v
+
+loadlinux26: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko
+	ztcfg -v
+
+loadlinux26-debug: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko debug=1
+	ztcfg -v
+
+loadlinux24NT: all
+	modprobe zaptel
+	insmod ./zaphfc.o modes=1
+	ztcfg -v
+
+loadlinux24NT-debug: all
+	modprobe zaptel
+	insmod ./zaphfc.o modes=1 debug=1
+	ztcfg -v
+
+loadlinux26NT: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko modes=1
+	ztcfg -v
+
+loadlinux26NT-debug: linux26
+	modprobe zaptel
+	insmod ./zaphfc.ko modes=1 debug=1
+	ztcfg -v
+
+unload: 
+	-rmmod zaphfc zaptel
+
+zaphfc.ko: zaphfc.c zaphfc.h
+
+linux26: 
+	@if ! [ -d /usr/src/linux-2.6 ]; then echo "Link /usr/src/linux-2.6 to your kernel sources first!"; exit 1 ; fi
+	make -C /usr/src/linux-2.6 SUBDIRS=$(PWD) ZAP=$(ZAP) modules
+
+install:	install$(BUILDVER)
+
+installlinux26:
+	install -D -m 644 zaphfc.ko $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/zaphfc.ko
+
+installlinux24:
+	install -D -m 644 zaphfc.o $(INSTALL_PREFIX)/lib/modules/`uname -r`/misc/zaphfc.o
+
diff -urNad --exclude=CVS --exclude=.svn ./zaphfc/zapata.conf /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zapata.conf
--- ./zaphfc/zapata.conf	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zapata.conf	2005-07-14 07:01:19.172625000 +0100
@@ -0,0 +1,38 @@
+;
+; Zapata telephony interface
+;
+; Configuration file
+
+[channels]
+;
+; Default language
+;
+;language=en
+;
+; Default context
+;
+;
+switchtype = euroisdn
+; p2mp TE mode
+signalling = bri_cpe_ptmp
+
+; p2p TE mode
+;signalling = bri_cpe
+; p2mp NT mode
+;signalling = bri_net_ptmp
+; p2p NT mode
+;signalling = bri_net
+
+pridialplan = dynamic
+prilocaldialplan = local
+nationalprefix = 0
+internationalprefix = 00
+
+echocancel=yes
+echotraining = 100
+echocancelwhenbridged=yes
+
+immediate=yes
+group = 1
+context=demo
+channel => 1-2
diff -urNad --exclude=CVS --exclude=.svn ./zaphfc/zaphfc.c /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaphfc.c
--- ./zaphfc/zaphfc.c	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaphfc.c	2005-07-14 07:01:19.173624848 +0100
@@ -0,0 +1,1149 @@
+/*
+ * zaphfc.c - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * kernel module inspired by HFC PCI ISDN4Linux and Zaptel drivers
+ *
+ * Copyright (C) 2002, 2003, 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#ifdef RTAITIMING
+#include <asm/io.h>
+#include <rtai.h>
+#include <rtai_sched.h>
+#include <rtai_fifos.h>
+#endif
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <zaptel.h>
+#include "zaphfc.h"
+
+#if CONFIG_PCI
+
+#define CLKDEL_TE	0x0f	/* CLKDEL in TE mode */
+#define CLKDEL_NT	0x6c	/* CLKDEL in NT mode */
+
+typedef struct {
+        int vendor_id;
+        int device_id;
+        char *vendor_name;
+        char *card_name;
+} PCI_ENTRY;
+
+static const PCI_ENTRY id_list[] =
+{
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_2BD0, "CCD/Billion/Asuscom", "2BD0"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B000, "Billion", "B000"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B006, "Billion", "B006"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B007, "Billion", "B007"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B008, "Billion", "B008"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B009, "Billion", "B009"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00A, "Billion", "B00A"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00B, "Billion", "B00B"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B00C, "Billion", "B00C"},
+        {PCI_VENDOR_ID_CCD, PCI_DEVICE_ID_CCD_B100, "Seyeon", "B100"},
+        {PCI_VENDOR_ID_ABOCOM, PCI_DEVICE_ID_ABOCOM_2BD1, "Abocom/Magitek", "2BD1"},
+        {PCI_VENDOR_ID_ASUSTEK, PCI_DEVICE_ID_ASUSTEK_0675, "Asuscom/Askey", "675"},
+        {PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_T_CONCEPT, "German telekom", "T-Concept"},
+        {PCI_VENDOR_ID_BERKOM, PCI_DEVICE_ID_BERKOM_A1T, "German telekom", "A1T"},
+        {PCI_VENDOR_ID_ANIGMA, PCI_DEVICE_ID_ANIGMA_MC145575, "Motorola MC145575", "MC145575"},
+        {PCI_VENDOR_ID_ZOLTRIX, PCI_DEVICE_ID_ZOLTRIX_2BD0, "Zoltrix", "2BD0"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_E,"Digi International", "Digi DataFire Micro V IOM2 (Europe)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_E,"Digi International", "Digi DataFire Micro V (Europe)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_IOM2_A,"Digi International", "Digi DataFire Micro V IOM2 (North America)"},
+        {PCI_VENDOR_ID_DIGI, PCI_DEVICE_ID_DIGI_DF_M_A,"Digi International", "Digi DataFire Micro V (North America)"},
+	{0x182d, 0x3069,"Sitecom","Isdn 128 PCI"},
+        {0, 0, NULL, NULL},
+};
+
+static struct hfc_card *hfc_dev_list = NULL;
+static int hfc_dev_count = 0;
+static int modes = 0; // all TE
+static int debug = 0;
+static struct pci_dev *multi_hfc = NULL;
+static spinlock_t registerlock = SPIN_LOCK_UNLOCKED;
+
+void hfc_shutdownCard(struct hfc_card *hfctmp) {
+    unsigned long flags;
+
+    if (hfctmp == NULL) {
+	return;
+    }
+
+    if (hfctmp->pci_io == NULL) {
+	return;
+    }
+    
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    printk(KERN_INFO "zaphfc: shutting down card at %p.\n",hfctmp->pci_io);
+
+    /* Clear interrupt mask */
+    hfctmp->regs.int_m2 = 0;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+    /* Reset pending interrupts */
+    hfc_inb(hfctmp, hfc_INT_S1);
+
+    /* Wait for interrupts that might still be pending */
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    /* Remove interrupt handler */
+    if (hfctmp->irq) {
+	free_irq(hfctmp->irq, hfctmp);
+    }
+
+    /* Soft-reset the card */
+    hfc_outb(hfctmp, hfc_CIRM, hfc_CIRM_RESET); // softreset on
+
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    spin_lock_irqsave(&hfctmp->lock,flags);
+
+    hfc_outb(hfctmp,hfc_CIRM,0);	// softreset off
+
+    pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, 0);	// disable memio and bustmaster
+
+    if (hfctmp->fifomem != NULL) {
+        kfree(hfctmp->fifomem);
+    }
+    iounmap((void *) hfctmp->pci_io);
+    hfctmp->pci_io = NULL;
+    if (hfctmp->pcidev != NULL) {
+        pci_disable_device(hfctmp->pcidev);
+    }
+    spin_unlock_irqrestore(&hfctmp->lock,flags);
+    if (hfctmp->ztdev != NULL) {
+	zt_unregister(&hfctmp->ztdev->span);
+	kfree(hfctmp->ztdev);
+	printk(KERN_INFO "unregistered from zaptel.\n");
+    }
+}
+
+void hfc_resetCard(struct hfc_card *hfctmp) {
+    unsigned long flags;
+
+    spin_lock_irqsave(&hfctmp->lock,flags);
+    pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+    hfctmp->regs.int_m2 = 0;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+//    printk(KERN_INFO "zaphfc: resetting card.\n");
+    pci_set_master(hfctmp->pcidev);
+    hfc_outb(hfctmp, hfc_CIRM, hfc_CIRM_RESET);	// softreset on
+    spin_unlock_irqrestore(&hfctmp->lock, flags);
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((30 * HZ) / 1000);	// wait 30 ms
+    hfc_outb(hfctmp, hfc_CIRM, 0);	// softreset off
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    schedule_timeout((20 * HZ) / 1000);	// wait 20 ms
+    if (hfc_inb(hfctmp,hfc_STATUS) & hfc_STATUS_PCI_PROC) {
+	printk(KERN_WARNING "zaphfc: hfc busy.\n");
+    }
+
+//    hfctmp->regs.fifo_en = hfc_FIFOEN_D | hfc_FIFOEN_B1 | hfc_FIFOEN_B2;
+//    hfctmp->regs.fifo_en = hfc_FIFOEN_D;	/* only D fifos enabled */
+    hfctmp->regs.fifo_en = 0;	/* no fifos enabled */
+    hfc_outb(hfctmp, hfc_FIFO_EN, hfctmp->regs.fifo_en);
+
+    hfctmp->regs.trm = 2;
+    hfc_outb(hfctmp, hfc_TRM, hfctmp->regs.trm);
+
+    if (hfctmp->regs.nt_mode == 1) {
+	hfc_outb(hfctmp, hfc_CLKDEL, CLKDEL_NT); /* ST-Bit delay for NT-Mode */
+    } else {
+	hfc_outb(hfctmp, hfc_CLKDEL, CLKDEL_TE); /* ST-Bit delay for TE-Mode */
+    }
+    hfctmp->regs.sctrl_e = hfc_SCTRL_E_AUTO_AWAKE;
+    hfc_outb(hfctmp, hfc_SCTRL_E, hfctmp->regs.sctrl_e);	/* S/T Auto awake */
+    hfctmp->regs.bswapped = 0;	/* no exchange */
+
+    hfctmp->regs.ctmt = hfc_CTMT_TRANSB1 | hfc_CTMT_TRANSB2; // all bchans are transparent , no freaking hdlc
+    hfc_outb(hfctmp, hfc_CTMT, hfctmp->regs.ctmt);
+
+    hfctmp->regs.int_m1 = 0;
+    hfc_outb(hfctmp, hfc_INT_M1, hfctmp->regs.int_m1);
+
+#ifdef RTAITIMING
+    hfctmp->regs.int_m2 = 0;
+#else
+    hfctmp->regs.int_m2 = hfc_M2_PROC_TRANS;
+#endif
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+
+    /* Clear already pending ints */
+    hfc_inb(hfctmp, hfc_INT_S1);
+
+    if (hfctmp->regs.nt_mode == 1) {
+	hfctmp->regs.sctrl = 3 | hfc_SCTRL_NONE_CAP | hfc_SCTRL_MODE_NT;	/* set tx_lo mode, error in datasheet ! */
+    } else {
+	hfctmp->regs.sctrl = 3 | hfc_SCTRL_NONE_CAP | hfc_SCTRL_MODE_TE;	/* set tx_lo mode, error in datasheet ! */
+    }
+
+    hfctmp->regs.mst_mode = hfc_MST_MODE_MASTER;	/* HFC Master Mode */
+    hfc_outb(hfctmp, hfc_MST_MODE, hfctmp->regs.mst_mode);
+
+    hfc_outb(hfctmp, hfc_SCTRL, hfctmp->regs.sctrl);
+    hfctmp->regs.sctrl_r = 3;
+    hfc_outb(hfctmp, hfc_SCTRL_R, hfctmp->regs.sctrl_r);
+
+    hfctmp->regs.connect = 0;
+    hfc_outb(hfctmp, hfc_CONNECT, hfctmp->regs.connect);
+
+    hfc_outb(hfctmp, hfc_CIRM, 0x80 | 0x40);	// bit order
+
+    /* Finally enable IRQ output */
+#ifndef RTAITIMING
+    hfctmp->regs.int_m2 |= hfc_M2_IRQ_ENABLE;
+    hfc_outb(hfctmp, hfc_INT_M2, hfctmp->regs.int_m2);
+#endif
+
+    /* clear pending ints */
+    hfc_inb(hfctmp, hfc_INT_S1); 
+    hfc_inb(hfctmp, hfc_INT_S2);
+}
+
+void hfc_registerCard(struct hfc_card *hfccard) {
+    spin_lock(&registerlock);
+    if (hfccard != NULL) {
+	hfccard->cardno = hfc_dev_count++;
+	hfccard->next = hfc_dev_list;
+	hfc_dev_list = hfccard;
+    }
+    spin_unlock(&registerlock);
+}
+
+static void hfc_btrans(struct hfc_card *hfctmp, char whichB) {
+    // we are called with irqs disabled from the irq handler
+    int count, maxlen, total;
+    unsigned char *f1, *f2;
+    unsigned short *z1, *z2, newz1;
+    int freebytes;
+
+    if (whichB == 1) {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B1TX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B1TX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1TX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1TX_Z2 + (*f1 * 4));
+    } else {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B2TX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B2TX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2TX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2TX_Z2 + (*f1 * 4));
+    }
+
+    freebytes = *z2 - *z1;
+    if (freebytes <= 0) {
+	freebytes += hfc_B_FIFO_SIZE;
+    }
+    count = ZT_CHUNKSIZE;
+
+    total = count;
+    if (freebytes < count) {
+	hfctmp->clicks++;
+	/* only spit out this warning once per second to not make things worse! */
+	if (hfctmp->clicks > 100) {
+	    printk(KERN_CRIT "zaphfc: bchan tx fifo full, dropping audio! (z1=%d, z2=%d)\n",*z1,*z2);
+	    hfctmp->clicks = 0;
+	}
+	return;
+    }
+    
+    maxlen = (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL) - *z1;
+    if (maxlen > count) {
+        maxlen = count;
+    }
+    newz1 = *z1 + total;
+    if (newz1 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { newz1 -= hfc_B_FIFO_SIZE; }
+
+	if (whichB == 1) {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_B1TX_ZOFF + *z1),hfctmp->ztdev->chans[0].writechunk, maxlen);
+	} else {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_B2TX_ZOFF + *z1),hfctmp->ztdev->chans[1].writechunk, maxlen);
+	}
+	
+	count -= maxlen;
+	if (count > 0) {
+	// Buffer wrap
+	    if (whichB == 1) {
+	        memcpy((char *)(hfctmp->fifos + hfc_FIFO_B1TX_ZOFF + hfc_B_SUB_VAL),hfctmp->ztdev->chans[0].writechunk+maxlen, count);
+	    } else {
+	        memcpy((char *)(hfctmp->fifos + hfc_FIFO_B2TX_ZOFF + hfc_B_SUB_VAL),hfctmp->ztdev->chans[1].writechunk+maxlen, count);
+	    }
+	}
+
+    *z1 = newz1;	/* send it now */
+
+//    if (count > 0) printk(KERN_CRIT "zaphfc: bchan tx fifo (f1=%d, f2=%d, z1=%d, z2=%d)\n",(*f1) & hfc_FMASK,(*f2) & hfc_FMASK, *z1, *z2);
+    return;    
+}
+
+static void hfc_brec(struct hfc_card *hfctmp, char whichB) {
+    // we are called with irqs disabled from the irq handler
+    int count, maxlen, drop;
+    volatile unsigned char *f1, *f2;
+    volatile unsigned short *z1, *z2, newz2;
+    int bytes = 0;
+
+    if (whichB == 1) {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B1RX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B1RX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z2 + (*f1 * 4));
+    } else {
+	f1 = (char *)(hfctmp->fifos + hfc_FIFO_B2RX_F1);
+        f2 = (char *)(hfctmp->fifos + hfc_FIFO_B2RX_F2);
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z1 + (*f1 * 4));
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z2 + (*f1 * 4));
+    }
+
+    bytes = *z1 - *z2;
+    if (bytes < 0) {
+	bytes += hfc_B_FIFO_SIZE;
+    }
+    count = ZT_CHUNKSIZE;
+    
+    if (bytes < ZT_CHUNKSIZE) {
+#ifndef RTAITIMING
+	printk(KERN_CRIT "zaphfc: bchan rx fifo not enough bytes to receive! (z1=%d, z2=%d, wanted %d got %d), probably a buffer overrun.\n",*z1,*z2,ZT_CHUNKSIZE,bytes);
+#endif
+	return;
+    }
+
+    /* allowing the buffering of hfc_BCHAN_BUFFER bytes of audio data works around irq jitter */
+    if (bytes > hfc_BCHAN_BUFFER + ZT_CHUNKSIZE) {
+	/* if the system is too slow to handle it, we will have to drop it all (except 1 zaptel chunk) */
+	drop = bytes - ZT_CHUNKSIZE;
+	hfctmp->clicks++;
+	/* only spit out this warning once per second to not make things worse! */
+	if (hfctmp->clicks > 100) {
+	    printk(KERN_CRIT "zaphfc: dropped audio (z1=%d, z2=%d, wanted %d got %d, dropped %d).\n",*z1,*z2,count,bytes,drop);
+	    hfctmp->clicks = 0;
+	}
+	/* hm, we are processing the b chan data tooooo slowly... let's drop the lost audio */
+	newz2 = *z2 + drop;
+	if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+	    newz2 -= hfc_B_FIFO_SIZE; 
+	}
+	*z2 = newz2;
+    }
+
+    
+    maxlen = (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL) - *z2;
+    if (maxlen > count) {
+        maxlen = count;
+    }
+    if (whichB == 1) {
+        memcpy(hfctmp->ztdev->chans[0].readchunk,(char *)(hfctmp->fifos + hfc_FIFO_B1RX_ZOFF + *z2), maxlen);
+    } else {
+        memcpy(hfctmp->ztdev->chans[1].readchunk,(char *)(hfctmp->fifos + hfc_FIFO_B2RX_ZOFF + *z2), maxlen);
+    }
+    newz2 = *z2 + count;
+    if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+        newz2 -= hfc_B_FIFO_SIZE; 
+    }
+    *z2 = newz2;
+	
+    count -= maxlen;
+    if (count > 0) {
+    // Buffer wrap
+        if (whichB == 1) {
+	    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B1RX_Z2 + (*f1 * 4));
+    	    memcpy(hfctmp->ztdev->chans[0].readchunk + maxlen,(char *)(hfctmp->fifos + hfc_FIFO_B1RX_ZOFF + hfc_B_SUB_VAL), count);
+	} else {
+	    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_B2RX_Z2 + (*f1 * 4));
+	    memcpy(hfctmp->ztdev->chans[1].readchunk + maxlen,(char *)(hfctmp->fifos + hfc_FIFO_B2RX_ZOFF + hfc_B_SUB_VAL), count);
+	}
+	newz2 = *z2 + count;
+	if (newz2 >= (hfc_B_FIFO_SIZE + hfc_B_SUB_VAL)) { 
+	    newz2 -= hfc_B_FIFO_SIZE; 
+	}
+    }
+
+
+    if (whichB == 1) {
+	zt_ec_chunk(&hfctmp->ztdev->chans[0], hfctmp->ztdev->chans[0].readchunk, hfctmp->ztdev->chans[0].writechunk);
+    } else {
+	zt_ec_chunk(&hfctmp->ztdev->chans[1], hfctmp->ztdev->chans[1].readchunk, hfctmp->ztdev->chans[1].writechunk);
+    }
+    return;    
+}
+
+
+static void hfc_dtrans(struct hfc_card *hfctmp) {
+    // we are called with irqs disabled from the irq handler
+    int x;
+    int count, maxlen, total;
+    unsigned char *f1, *f2, newf1;
+    unsigned short *z1, *z2, newz1;
+    int frames, freebytes;
+
+    if (hfctmp->ztdev->chans[2].bytes2transmit == 0) {
+	return;
+    }
+
+    f1 = (char *)(hfctmp->fifos + hfc_FIFO_DTX_F1);
+    f2 = (char *)(hfctmp->fifos + hfc_FIFO_DTX_F2);
+    z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z1 + (*f1 * 4));
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z2 + (*f1 * 4));
+
+    frames = (*f1 - *f2) & hfc_FMASK;
+    if (frames < 0) {
+	frames += hfc_MAX_DFRAMES + 1;
+    }
+
+    if (frames >= hfc_MAX_DFRAMES) {
+	printk(KERN_CRIT "zaphfc: dchan tx fifo total number of frames exceeded!\n");
+	return;
+    }
+
+    freebytes = *z2 - *z1;
+    if (freebytes <= 0) {
+	freebytes += hfc_D_FIFO_SIZE;
+    }
+    count = hfctmp->ztdev->chans[2].bytes2transmit;
+
+    total = count;
+    if (freebytes < count) {
+	printk(KERN_CRIT "zaphfc: dchan tx fifo not enough free bytes! (z1=%d, z2=%d)\n",*z1,*z2);
+	return;
+    }
+    
+    newz1 = (*z1 + count) & hfc_ZMASK;
+    newf1 = ((*f1 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	// next frame
+    
+    if (count > 0) {
+	if (debug) {
+    	    printk(KERN_CRIT "zaphfc: card %d TX [ ", hfctmp->cardno);
+	    for (x=0; x<count; x++) {
+		printk("%#2x ",hfctmp->dtransbuf[x]);
+	    }
+	    if (hfctmp->ztdev->chans[2].eoftx == 1) {
+		printk("] %d bytes\n", count);
+	    } else {
+		printk("..] %d bytes\n", count);
+	    }
+	}
+	maxlen = hfc_D_FIFO_SIZE - *z1;
+	if (maxlen > count) {
+	    maxlen = count;
+	}
+	memcpy((char *)(hfctmp->fifos + hfc_FIFO_DTX_ZOFF + *z1),hfctmp->ztdev->chans[2].writechunk, maxlen);
+	count -= maxlen;
+	if (count > 0) {
+	    memcpy((char *)(hfctmp->fifos + hfc_FIFO_DTX_ZOFF),(char *)(hfctmp->ztdev->chans[2].writechunk + maxlen), count);
+	}
+    }
+
+    *z1 = newz1;
+
+    if (hfctmp->ztdev->chans[2].eoftx == 1) {
+	*f1 = newf1;
+	z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DTX_Z1 + (*f1 * 4));
+	*z1 = newz1;
+	hfctmp->ztdev->chans[2].eoftx = 0;
+    }
+//    printk(KERN_CRIT "zaphfc: dchan tx fifo (f1=%d, f2=%d, z1=%d, z2=%d)\n",(*f1) & hfc_FMASK,(*f2) & hfc_FMASK, *z1, *z2);
+    return;    
+}
+
+/* receive a complete hdlc frame, skip broken or short frames */
+static void hfc_drec(struct hfc_card *hfctmp) {
+    int count=0, maxlen=0, framelen=0;
+    unsigned char *f1, *f2, *crcstat;
+    unsigned short *z1, *z2, oldz2, newz2;
+
+    hfctmp->ztdev->chans[2].bytes2receive=0;
+    hfctmp->ztdev->chans[2].eofrx = 0;
+
+    /* put the received data into the zaptel buffer
+       we'll call zt_receive() later when the timer fires. */
+    f1 = (char *)(hfctmp->fifos + hfc_FIFO_DRX_F1);
+    f2 = (char *)(hfctmp->fifos + hfc_FIFO_DRX_F2);
+
+    if (*f1 == *f2) return; /* nothing received, strange eh? */
+
+    z1 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z1 + (*f2 * 4));
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+    
+    /* calculate length of frame, including 2 bytes CRC and 1 byte STAT */
+    count = *z1 - *z2;
+    
+    if (count < 0) { 
+	count += hfc_D_FIFO_SIZE; /* ring buffer wrapped */
+    }
+    count++;
+    framelen = count;
+
+    crcstat = (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF + *z1);
+
+    if ((framelen < 4) || (*crcstat != 0x0)) {
+	/* the frame is too short for a valid HDLC frame or the CRC is borked */
+	printk(KERN_CRIT "zaphfc: empty HDLC frame or bad CRC received (framelen = %d, stat = %#x, card = %d).\n", framelen, *crcstat, hfctmp->cardno);
+	oldz2 = *z2;
+	*f2 = ((*f2 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	/* NEXT!!! */
+        // recalculate z2, because Z2 is a function of F2 Z2(F2) and we INCed F2!!!
+	z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+	*z2 = (oldz2 + framelen) & hfc_ZMASK;
+	hfctmp->drecinframe = 0;
+	hfctmp->regs.int_drec--;
+	/* skip short or broken frames */
+        hfctmp->ztdev->chans[2].bytes2receive = 0; 
+	return;
+    }
+
+    count -= 1;	/* strip STAT */
+    hfctmp->ztdev->chans[2].eofrx = 1;
+
+    if (count + *z2 <= hfc_D_FIFO_SIZE) {
+	maxlen = count;
+    } else {
+	maxlen = hfc_D_FIFO_SIZE - *z2;
+    }
+
+    /* copy first part */
+    memcpy(hfctmp->drecbuf, (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF + *z2), maxlen);
+    hfctmp->ztdev->chans[2].bytes2receive += maxlen; 
+    
+    count -= maxlen;
+    if (count > 0) {
+	/* ring buffer wrapped, copy rest from start of d fifo */
+	memcpy(hfctmp->drecbuf + maxlen, (char *)(hfctmp->fifos + hfc_FIFO_DRX_ZOFF), count);
+	hfctmp->ztdev->chans[2].bytes2receive += count; 
+    }
+
+    /* frame read */
+    oldz2 = *z2;
+    newz2 = (oldz2 + framelen) & hfc_ZMASK;
+    *f2 = ((*f2 + 1) & hfc_MAX_DFRAMES) | (hfc_MAX_DFRAMES + 1);	/* NEXT!!! */
+    /* recalculate z2, because Z2 is a function of F2 Z2(F2) and we INCed F2!!! */
+    z2 = (unsigned short *)(hfctmp->fifos + hfc_FIFO_DRX_Z2 + (*f2 * 4));
+    *z2 = newz2;
+    hfctmp->drecinframe = 0;
+    hfctmp->regs.int_drec--; 
+}
+
+#ifndef RTAITIMING
+#ifdef LINUX26
+static irqreturn_t hfc_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#else
+static void hfc_interrupt(int irq, void *dev_id, struct pt_regs *regs) {
+#endif
+    struct hfc_card *hfctmp = dev_id;
+    unsigned long flags = 0;
+    unsigned char stat;
+#else
+static void hfc_service(struct hfc_card *hfctmp) {
+#endif
+    struct zt_hfc *zthfc;
+    unsigned char s1, s2, l1state;
+    int x;
+
+    if (!hfctmp) {
+#ifndef RTAITIMING
+#ifdef LINUX26
+		return IRQ_NONE;
+#else
+		return;
+#endif		
+#else
+	/* rtai */
+	return;
+#endif
+    }
+
+    if (!hfctmp->pci_io) {
+	    printk(KERN_WARNING "%s: IO-mem disabled, cannot handle interrupt\n",
+		   __FUNCTION__);
+#ifndef RTAITIMING
+#ifdef LINUX26
+	    return IRQ_NONE;
+#else
+	    return;
+#endif		
+#else
+	/* rtai */
+	return;
+#endif
+    }
+    
+    /*	we assume a few things in this irq handler:
+	- the hfc-pci will only generate "timer" irqs (proc/non-proc)
+	- we need to use every 8th IRQ (to generate 1khz timing)
+	OR
+	- if we use rtai for timing the hfc-pci will not generate ANY irq,
+	  instead rtai will call this "fake" irq with a 1khz realtime timer. :)
+	- rtai will directly service the card, not like it used to by triggering
+	  the linux irq
+    */
+
+#ifndef RTAITIMING
+    spin_lock_irqsave(&hfctmp->lock, flags);
+    stat = hfc_inb(hfctmp, hfc_STATUS);
+
+    if ((stat & hfc_STATUS_ANYINT) == 0) {
+        // maybe we are sharing the irq
+	spin_unlock_irqrestore(&hfctmp->lock,flags);
+#ifdef LINUX26
+	return IRQ_NONE;
+#else
+	return;
+#endif		
+    }
+#endif
+
+    s1 = hfc_inb(hfctmp, hfc_INT_S1);
+    s2 = hfc_inb(hfctmp, hfc_INT_S2); 
+    if (s1 != 0) {
+	if (s1 & hfc_INTS_TIMER) {
+	    // timer (bit 7)
+	    // printk(KERN_CRIT "timer %d %d %d.\n", stat, s1, s2);
+	}
+	if (s1 & hfc_INTS_L1STATE) {
+	    // state machine (bit 6)
+	    // printk(KERN_CRIT "zaphfc: layer 1 state machine interrupt\n");
+	    zthfc = hfctmp->ztdev;
+	    l1state = hfc_inb(hfctmp,hfc_STATES)  & hfc_STATES_STATE_MASK;
+	    if (hfctmp->regs.nt_mode == 1) {
+		if (debug) {
+	    	    printk(KERN_CRIT "zaphfc: card %d layer 1 state = G%d\n", hfctmp->cardno, l1state);
+		}
+		switch (l1state) {
+		    case 3:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 ACTIVATED (G%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 ACTIVATED (G%d)", hfctmp->cardno, l1state);
+#endif
+			break;
+		    default:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 DEACTIVATED (G%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] layer 1 DEACTIVATED (G%d)", hfctmp->cardno, l1state);
+#endif
+		}
+		if (l1state == 2) {
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_ACTIVATE | hfc_STATES_DO_ACTION | hfc_STATES_NT_G2_G3);
+		} else if (l1state == 3) {
+		    // fix to G3 state (see specs)
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_LOAD_STATE | 3);
+		}
+	    } else {
+		if (debug) {
+	    	    printk(KERN_CRIT "zaphfc: card %d layer 1 state = F%d\n", hfctmp->cardno, l1state);
+		}
+		switch (l1state) {
+		    case 7:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 ACTIVATED (F%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 ACTIVATED (F%d)", hfctmp->cardno, l1state);
+#endif
+			break;
+		    default:
+#ifdef RTAITIMING
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 DEACTIVATED (F%d) [realtime]", hfctmp->cardno, l1state);
+#else
+			sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] layer 1 DEACTIVATED (F%d)", hfctmp->cardno, l1state);
+#endif
+		}
+		if (l1state == 3) {
+		    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_DO_ACTION | hfc_STATES_ACTIVATE);
+		}
+	    }
+	    
+	}
+	if (s1 & hfc_INTS_DREC) {
+	    // D chan RX (bit 5)
+	    hfctmp->regs.int_drec++;
+	    // mr. zapata there is something for you!
+	//    printk(KERN_CRIT "d chan rx\n");		    
+	}
+	if (s1 & hfc_INTS_B2REC) {
+	    // B2 chan RX (bit 4)
+	}
+	if (s1 & hfc_INTS_B1REC) {
+	    // B1 chan RX (bit 3)
+	}
+	if (s1 & hfc_INTS_DTRANS) {
+	    // D chan TX (bit 2)
+//	    printk(KERN_CRIT "zaphfc: dchan frame transmitted.\n");
+	}
+	if (s1 & hfc_INTS_B2TRANS) {
+	    // B2 chan TX (bit 1)
+	}
+	if (s1 & hfc_INTS_B1TRANS) {
+	    // B1 chan TX (bit 0)
+	}
+    }
+#ifdef RTAITIMING
+    /* fake an irq */
+    s2 |= hfc_M2_PROC_TRANS;
+#endif
+    if (s2 != 0) {
+	if (s2 & hfc_M2_PMESEL) {
+	    // kaboom irq (bit 7)
+	    printk(KERN_CRIT "zaphfc: sync lost, pci performance too low. you might have some cpu throtteling enabled.\n");
+	}
+	if (s2 & hfc_M2_GCI_MON_REC) {
+	    // RxR monitor channel (bit 2)
+	}
+	if (s2 & hfc_M2_GCI_I_CHG) {
+	    // GCI I-change  (bit 1)
+	}
+	if (s2 & hfc_M2_PROC_TRANS) {
+	    // processing/non-processing transition  (bit 0)
+	    hfctmp->ticks++;
+#ifndef RTAITIMING
+	    if (hfctmp->ticks > 7) {
+		// welcome to zaptel timing :)
+#endif
+	    	hfctmp->ticks = 0;
+
+		if (hfctmp->ztdev->span.flags & ZT_FLAG_RUNNING) {
+		    // clear dchan buffer
+		    hfctmp->ztdev->chans[2].bytes2transmit = 0;
+		    hfctmp->ztdev->chans[2].maxbytes2transmit = hfc_D_FIFO_SIZE;
+
+		    zt_transmit(&(hfctmp->ztdev->span));
+
+		    hfc_btrans(hfctmp,1);
+		    hfc_btrans(hfctmp,2);
+		    hfc_dtrans(hfctmp);
+		}
+
+		hfc_brec(hfctmp,1);
+		hfc_brec(hfctmp,2);
+		if (hfctmp->regs.int_drec > 0) {
+		    // dchan data to read
+		    hfc_drec(hfctmp);
+		    if (hfctmp->ztdev->chans[2].bytes2receive > 0) {
+			    if (debug) {
+    				printk(KERN_CRIT "zaphfc: card %d RX [ ", hfctmp->cardno);
+				if (hfctmp->ztdev->chans[2].eofrx) {
+				    /* dont output CRC == less user confusion */
+				    for (x=0; x < hfctmp->ztdev->chans[2].bytes2receive - 2; x++) {
+					printk("%#2x ", hfctmp->drecbuf[x]);
+				    }
+				    printk("] %d bytes\n", hfctmp->ztdev->chans[2].bytes2receive - 2);
+				} else {
+				    for (x=0; x < hfctmp->ztdev->chans[2].bytes2receive; x++) {
+					printk("%#2x ", hfctmp->drecbuf[x]);
+				    }
+				    printk("..] %d bytes\n", hfctmp->ztdev->chans[2].bytes2receive);
+				}
+			    }
+		    }
+		} else {
+			// hmm....ok, let zaptel receive nothing
+		    hfctmp->ztdev->chans[2].bytes2receive = 0;
+		}
+		if (hfctmp->ztdev->span.flags & ZT_FLAG_RUNNING) {
+		    zt_receive(&(hfctmp->ztdev->span));
+		}
+		
+#ifndef RTAITIMING
+	    }
+#endif
+	}
+
+    }
+#ifndef RTAITIMING
+    spin_unlock_irqrestore(&hfctmp->lock,flags);
+#ifdef LINUX26
+	return IRQ_RETVAL(1);
+#endif		
+#endif
+}
+
+
+static int zthfc_open(struct zt_chan *chan) {
+    struct zt_hfc *zthfc = chan->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+    
+    if (!hfctmp) {
+    return 0;
+    }
+#ifndef LINUX26  
+    MOD_INC_USE_COUNT;
+#else
+    try_module_get(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int zthfc_close(struct zt_chan *chan) {
+    struct zt_hfc *zthfc = chan->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+
+    if (!hfctmp) {
+	return 0;
+    }
+
+#ifndef LINUX26  
+    MOD_DEC_USE_COUNT;
+#else
+    module_put(THIS_MODULE);
+#endif
+    return 0;
+}
+
+static int zthfc_rbsbits(struct zt_chan *chan, int bits) {
+    return 0;
+}
+
+static int zthfc_ioctl(struct zt_chan *chan, unsigned int cmd, unsigned long data) {
+        switch(cmd) {
+        default:
+                return -ENOTTY;
+        }
+        return 0;
+}
+
+static int zthfc_startup(struct zt_span *span) {
+    struct zt_hfc *zthfc = span->pvt;
+    struct hfc_card *hfctmp = zthfc->card;
+    int alreadyrunning;
+    
+    if (hfctmp == NULL) {
+	printk(KERN_INFO "zaphfc: no card for span at startup!\n");
+    }
+    alreadyrunning = span->flags & ZT_FLAG_RUNNING;
+    
+    if (!alreadyrunning) {
+	span->chans[2].flags &= ~ZT_FLAG_HDLC;
+	span->chans[2].flags |= ZT_FLAG_BRIDCHAN;
+	
+	span->flags |= ZT_FLAG_RUNNING;
+
+	hfctmp->ticks = -2;
+	hfctmp->clicks = 0;
+	hfctmp->regs.fifo_en = hfc_FIFOEN_D | hfc_FIFOEN_B1 | hfc_FIFOEN_B2;
+        hfc_outb(hfctmp, hfc_FIFO_EN, hfctmp->regs.fifo_en);
+    } else {
+	return 0;
+    }
+
+    // drivers, start engines!
+    hfc_outb(hfctmp, hfc_STATES, hfc_STATES_DO_ACTION | hfc_STATES_ACTIVATE);
+    return 0;
+}
+
+static int zthfc_shutdown(struct zt_span *span) {
+    return 0;
+}
+
+static int zthfc_maint(struct zt_span *span, int cmd) {
+    return 0;
+}
+
+static int zthfc_chanconfig(struct zt_chan *chan, int sigtype) {
+//    printk(KERN_CRIT "chan_config sigtype=%d\n", sigtype);
+    return 0;
+}
+
+static int zthfc_spanconfig(struct zt_span *span, struct zt_lineconfig *lc) {
+    span->lineconfig = lc->lineconfig;
+    return 0;
+}
+
+static int zthfc_initialize(struct zt_hfc *zthfc) {
+    struct hfc_card *hfctmp = zthfc->card;
+    int i;
+
+    memset(&zthfc->span, 0x0, sizeof(struct zt_span)); // you never can tell...
+
+    sprintf(zthfc->span.name, "ZTHFC%d", hfc_dev_count + 1);
+    if (hfctmp->regs.nt_mode == 1) {
+#ifdef RTAITIMING
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT] [realtime]", hfc_dev_count + 1);
+#else
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [NT]", hfc_dev_count + 1);
+#endif
+    } else {
+#ifdef RTAITIMING
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE] [realtime]", hfc_dev_count + 1);
+#else
+	sprintf(zthfc->span.desc, "HFC-S PCI A ISDN card %d [TE]", hfc_dev_count + 1);
+#endif
+    }
+
+    zthfc->span.spanconfig = zthfc_spanconfig;
+    zthfc->span.chanconfig = zthfc_chanconfig;
+    zthfc->span.startup = zthfc_startup;
+    zthfc->span.shutdown = zthfc_shutdown;
+    zthfc->span.maint = zthfc_maint;
+    zthfc->span.rbsbits = zthfc_rbsbits;
+    zthfc->span.open = zthfc_open;
+    zthfc->span.close = zthfc_close;
+    zthfc->span.ioctl = zthfc_ioctl;
+
+    zthfc->span.chans = zthfc->chans;
+    zthfc->span.channels = 3;
+    zthfc->span.deflaw = ZT_LAW_ALAW;
+    zthfc->span.linecompat = ZT_CONFIG_AMI | ZT_CONFIG_CCS; // <--- this is really BS
+    zthfc->span.offset = 0;
+    init_waitqueue_head(&zthfc->span.maintq);
+    zthfc->span.pvt = zthfc;
+
+    for (i = 0; i < zthfc->span.channels; i++) {
+	memset(&(zthfc->chans[i]), 0x0, sizeof(struct zt_chan));
+	sprintf(zthfc->chans[i].name, "ZTHFC%d/%d/%d", hfc_dev_count + 1,0,i + 1);
+	zthfc->chans[i].pvt = zthfc;
+	zthfc->chans[i].sigcap =  ZT_SIG_EM | ZT_SIG_CLEAR | ZT_SIG_FXSLS | ZT_SIG_FXSGS | ZT_SIG_FXSKS | ZT_SIG_FXOLS | ZT_SIG_FXOGS | ZT_SIG_FXOKS | ZT_SIG_CAS | ZT_SIG_SF;
+	zthfc->chans[i].chanpos = i + 1; 
+    }
+
+    if (zt_register(&zthfc->span,0)) {
+	printk(KERN_CRIT "unable to register zaptel device!\n");
+	return -1;
+    }
+//    printk(KERN_CRIT "zaphfc: registered zaptel device!\n");
+    return 0;
+}
+
+#ifdef RTAITIMING
+#define TICK_PERIOD  1000000
+#define TICK_PERIOD2 1000000000
+#define TASK_PRIORITY 1
+#define STACK_SIZE 10000
+
+static RT_TASK rt_task;
+static struct hfc_card *rtai_hfc_list[hfc_MAX_CARDS];
+static unsigned char rtai_hfc_counter = 0;
+
+static void rtai_register_hfc(struct hfc_card *hfctmp) {
+    rtai_hfc_list[rtai_hfc_counter++] = hfctmp;
+}
+
+static void rtai_loop(int t) {
+    int i=0;
+    for (;;) {
+	for (i=0; i < rtai_hfc_counter; i++) {
+	    if (rtai_hfc_list[i] != NULL)
+		hfc_service(rtai_hfc_list[i]);
+	}
+        rt_task_wait_period();
+    }
+}
+#endif
+
+int hfc_findCards(int pcivendor, int pcidevice, char *vendor_name, char *card_name) {
+    struct pci_dev *tmp;
+    struct hfc_card *hfctmp = NULL;
+    struct zt_hfc *zthfc = NULL;
+
+    tmp = pci_find_device(pcivendor, pcidevice, multi_hfc);
+    while (tmp != NULL) {
+	multi_hfc = tmp;	// skip this next time.
+
+	if (pci_enable_device(tmp)) {
+	    multi_hfc = NULL;
+	    return -1;
+	}
+	pci_set_master(tmp);
+
+	hfctmp = kmalloc(sizeof(struct hfc_card), GFP_KERNEL);
+	if (!hfctmp) {
+	    printk(KERN_WARNING "zaphfc: unable to kmalloc!\n");
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	}
+	memset(hfctmp, 0x0, sizeof(struct hfc_card));
+	spin_lock_init(&hfctmp->lock);
+	
+	hfctmp->pcidev = tmp;
+	hfctmp->pcibus = tmp->bus->number;
+	hfctmp->pcidevfn = tmp->devfn; 
+
+	if (!tmp->irq) {
+	    printk(KERN_WARNING "zaphfc: no irq!\n");
+	} else {
+	    hfctmp->irq = tmp->irq;
+	}
+
+	hfctmp->pci_io = (char *) tmp->resource[1].start;
+	if (!hfctmp->pci_io) {
+	    printk(KERN_WARNING "zaphfc: no iomem!\n");
+	    kfree(hfctmp);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -1;
+	}
+	
+	hfctmp->fifomem = kmalloc(65536, GFP_KERNEL);
+	if (!hfctmp->fifomem) {
+	    printk(KERN_WARNING "zaphfc: unable to kmalloc fifomem!\n");
+	    kfree(hfctmp);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	} else {
+	    memset(hfctmp->fifomem, 0x0, 65536);
+	    (ulong) hfctmp->fifos = (((ulong) hfctmp->fifomem) & ~0x7FFF) + 0x8000;
+	    pci_write_config_dword(hfctmp->pcidev, 0x80, (u_int) virt_to_bus(hfctmp->fifos));
+	    hfctmp->pci_io = ioremap((ulong) hfctmp->pci_io, 256);
+	}
+
+#ifdef RTAITIMING
+	/* we need no stinking irq */
+	hfctmp->irq = 0;
+#else
+	if (request_irq(hfctmp->irq, &hfc_interrupt, SA_INTERRUPT | SA_SHIRQ, "zaphfc", hfctmp)) {
+	    printk(KERN_WARNING "zaphfc: unable to register irq\n");
+	    kfree(hfctmp->fifomem);
+	    kfree(hfctmp);
+	    iounmap((void *) hfctmp->pci_io);
+	    pci_disable_device(tmp);
+	    multi_hfc = NULL;
+	    return -EIO;
+	}
+#endif
+
+#ifdef RTAITIMING
+	rtai_register_hfc(hfctmp);
+#endif
+	printk(KERN_INFO
+		       "zaphfc: %s %s configured at mem %#x fifo %#x(%#x) IRQ %d HZ %d\n",
+			vendor_name, card_name,
+		       (u_int) hfctmp->pci_io,
+		       (u_int) hfctmp->fifos,
+		       (u_int) virt_to_bus(hfctmp->fifos),
+		       hfctmp->irq, HZ); 
+	pci_write_config_word(hfctmp->pcidev, PCI_COMMAND, PCI_COMMAND_MEMORY);	// enable memio
+	hfctmp->regs.int_m1 = 0;	// no ints
+	hfctmp->regs.int_m2 = 0;	// not at all
+	hfc_outb(hfctmp,hfc_INT_M1,hfctmp->regs.int_m1);
+	hfc_outb(hfctmp,hfc_INT_M2,hfctmp->regs.int_m2);
+
+	if ((modes & (1 << hfc_dev_count)) != 0) {
+	    printk(KERN_INFO "zaphfc: Card %d configured for NT mode\n",hfc_dev_count);
+	    hfctmp->regs.nt_mode = 1;
+	} else {
+	    printk(KERN_INFO "zaphfc: Card %d configured for TE mode\n",hfc_dev_count);
+	    hfctmp->regs.nt_mode = 0;
+	}
+
+	zthfc = kmalloc(sizeof(struct zt_hfc),GFP_KERNEL);
+	if (!zthfc) {
+	    printk(KERN_CRIT "zaphfc: unable to kmalloc!\n");
+	    hfc_shutdownCard(hfctmp);
+	    kfree(hfctmp);
+	    multi_hfc = NULL;
+	    return -ENOMEM;
+	}
+	memset(zthfc, 0x0, sizeof(struct zt_hfc));
+
+	zthfc->card = hfctmp;
+	zthfc_initialize(zthfc);
+	hfctmp->ztdev = zthfc;
+
+	memset(hfctmp->drecbuf, 0x0, sizeof(hfctmp->drecbuf));
+	hfctmp->ztdev->chans[2].readchunk = hfctmp->drecbuf;
+
+	memset(hfctmp->dtransbuf, 0x0, sizeof(hfctmp->dtransbuf));
+	hfctmp->ztdev->chans[2].writechunk = hfctmp->dtransbuf;
+
+	memset(hfctmp->brecbuf[0], 0x0, sizeof(hfctmp->brecbuf[0]));
+	hfctmp->ztdev->chans[0].readchunk = hfctmp->brecbuf[0];
+	memset(hfctmp->btransbuf[0], 0x0, sizeof(hfctmp->btransbuf[0]));
+	hfctmp->ztdev->chans[0].writechunk = hfctmp->btransbuf[0];
+
+	memset(hfctmp->brecbuf[1], 0x0, sizeof(hfctmp->brecbuf[1]));
+	hfctmp->ztdev->chans[1].readchunk = hfctmp->brecbuf[1];
+	memset(hfctmp->btransbuf[1], 0x0, sizeof(hfctmp->btransbuf[1]));
+	hfctmp->ztdev->chans[1].writechunk = hfctmp->btransbuf[1];
+
+
+	hfc_registerCard(hfctmp);
+	hfc_resetCard(hfctmp);
+	tmp = pci_find_device(pcivendor, pcidevice, multi_hfc);
+    }
+    return 0;
+}
+
+
+
+int init_module(void) {
+    int i = 0;
+#ifdef RTAITIMING
+    RTIME tick_period;
+    for (i=0; i < hfc_MAX_CARDS; i++) {
+	rtai_hfc_list[i] = NULL;
+    }
+    rt_set_periodic_mode();
+#endif
+    i = 0;
+    while (id_list[i].vendor_id) {
+	multi_hfc = NULL;
+	hfc_findCards(id_list[i].vendor_id, id_list[i].device_id, id_list[i].vendor_name, id_list[i].card_name);
+	i++;
+    }
+#ifdef RTAITIMING
+    for (i=0; i < hfc_MAX_CARDS; i++) {
+        if (rtai_hfc_list[i]) {
+	    printk(KERN_INFO
+		       "zaphfc: configured %d at mem %#x fifo %#x(%#x) for realtime servicing\n",
+			rtai_hfc_list[i]->cardno,
+		       (u_int) rtai_hfc_list[i]->pci_io,
+		       (u_int) rtai_hfc_list[i]->fifos,
+		       (u_int) virt_to_bus(rtai_hfc_list[i]->fifos));
+
+	}
+    }
+    rt_task_init(&rt_task, rtai_loop, 1, STACK_SIZE, TASK_PRIORITY, 0, 0);
+    tick_period = start_rt_timer(nano2count(TICK_PERIOD));
+    rt_task_make_periodic(&rt_task, rt_get_time() + tick_period, tick_period);
+#endif
+    printk(KERN_INFO "zaphfc: %d hfc-pci card(s) in this box.\n", hfc_dev_count);
+    return 0;
+}
+
+void cleanup_module(void) {
+    struct hfc_card *tmpcard;
+#ifdef RTAITIMING
+    stop_rt_timer();
+    rt_task_delete(&rt_task);
+#endif
+    printk(KERN_INFO "zaphfc: stop\n");
+//    spin_lock(&registerlock);
+    while (hfc_dev_list != NULL) {
+	if (hfc_dev_list == NULL) break;
+	hfc_shutdownCard(hfc_dev_list);
+	tmpcard = hfc_dev_list;
+	hfc_dev_list = hfc_dev_list->next;
+	if (tmpcard != NULL) {
+	    kfree(tmpcard);
+	    tmpcard = NULL;
+	    printk(KERN_INFO "zaphfc: freed one card.\n");
+	}
+    }
+//    spin_unlock(&registerlock);
+}
+#endif
+
+
+MODULE_DESCRIPTION("HFC-S PCI A Zaptel Driver");
+MODULE_AUTHOR("Klaus-Peter Junghanns <kpj@junghanns.net>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif	
+MODULE_PARM(modes,"i");
+MODULE_PARM(debug,"i");
diff -urNad --exclude=CVS --exclude=.svn ./zaphfc/zaphfc.h /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaphfc.h
--- ./zaphfc/zaphfc.h	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaphfc.h	2005-07-14 07:01:19.173624848 +0100
@@ -0,0 +1,289 @@
+/*
+ * zaphfc.h - Zaptel driver for HFC-S PCI A based ISDN BRI cards
+ *
+ * kernel module based on HFC PCI ISDN4Linux and Zaptel drivers
+ *
+ * Copyright (C) 2002, 2003, 2004, 2005 Junghanns.NET GmbH
+ *
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ * This program is free software and may be modified and
+ * distributed under the terms of the GNU Public License.
+ *
+ */
+
+/* HFC register addresses - accessed using memory mapped I/O */
+/* For a list, see datasheet section 3.2.1 at page 21 */
+
+#define hfc_outb(a,b,c) (writeb((c),(a)->pci_io+(b)))
+#define hfc_inb(a,b) (readb((a)->pci_io+(b)))
+
+/* GCI/IOM bus monitor registers */
+
+#define hfc_C_I       0x08
+#define hfc_TRxR      0x0C
+#define hfc_MON1_D    0x28
+#define hfc_MON2_D    0x2C
+
+
+/* GCI/IOM bus timeslot registers */
+
+#define hfc_B1_SSL    0x80
+#define hfc_B2_SSL    0x84
+#define hfc_AUX1_SSL  0x88
+#define hfc_AUX2_SSL  0x8C
+#define hfc_B1_RSL    0x90
+#define hfc_B2_RSL    0x94
+#define hfc_AUX1_RSL  0x98
+#define hfc_AUX2_RSL  0x9C
+
+/* GCI/IOM bus data registers */
+
+#define hfc_B1_D      0xA0
+#define hfc_B2_D      0xA4
+#define hfc_AUX1_D    0xA8
+#define hfc_AUX2_D    0xAC
+
+/* GCI/IOM bus configuration registers */
+
+#define hfc_MST_EMOD  0xB4
+#define hfc_MST_MODE	 0xB8
+#define hfc_CONNECT 	 0xBC
+
+
+/* Interrupt and status registers */
+
+#define hfc_FIFO_EN   0x44
+#define hfc_TRM       0x48
+#define hfc_B_MODE    0x4C
+#define hfc_CHIP_ID   0x58
+#define hfc_CIRM  	 0x60
+#define hfc_CTMT	 0x64
+#define hfc_INT_M1  	 0x68
+#define hfc_INT_M2  	 0x6C
+#define hfc_INT_S1  	 0x78
+#define hfc_INT_S2  	 0x7C
+#define hfc_STATUS  	 0x70
+
+/* S/T section registers */
+
+#define hfc_STATES  	 0xC0
+#define hfc_SCTRL  	 0xC4
+#define hfc_SCTRL_E   0xC8
+#define hfc_SCTRL_R   0xCC
+#define hfc_SQ  	 0xD0
+#define hfc_CLKDEL  	 0xDC
+#define hfc_B1_REC    0xF0
+#define hfc_B1_SEND   0xF0
+#define hfc_B2_REC    0xF4
+#define hfc_B2_SEND   0xF4
+#define hfc_D_REC     0xF8
+#define hfc_D_SEND    0xF8
+#define hfc_E_REC     0xFC
+
+/* Bits and values in various HFC PCI registers */
+
+/* bits in status register (READ) */
+#define hfc_STATUS_PCI_PROC   0x02
+#define hfc_STATUS_NBUSY	  0x04 
+#define hfc_STATUS_TIMER_ELAP 0x10
+#define hfc_STATUS_STATINT	  0x20
+#define hfc_STATUS_FRAMEINT	  0x40
+#define hfc_STATUS_ANYINT	  0x80
+
+/* bits in CTMT (Write) */
+#define hfc_CTMT_CLTIMER    0x80
+#define hfc_CTMT_TIM3_125   0x04
+#define hfc_CTMT_TIM25      0x10
+#define hfc_CTMT_TIM50      0x14
+#define hfc_CTMT_TIM400     0x18
+#define hfc_CTMT_TIM800     0x1C
+#define hfc_CTMT_AUTO_TIMER 0x20
+#define hfc_CTMT_TRANSB2    0x02
+#define hfc_CTMT_TRANSB1    0x01
+
+/* bits in CIRM (Write) */
+#define hfc_CIRM_AUX_MSK    0x07
+#define hfc_CIRM_RESET  	  0x08
+#define hfc_CIRM_B1_REV     0x40
+#define hfc_CIRM_B2_REV     0x80
+
+/* bits in INT_M1 and INT_S1 */
+#define hfc_INTS_B1TRANS  0x01
+#define hfc_INTS_B2TRANS  0x02
+#define hfc_INTS_DTRANS   0x04
+#define hfc_INTS_B1REC    0x08
+#define hfc_INTS_B2REC    0x10
+#define hfc_INTS_DREC     0x20
+#define hfc_INTS_L1STATE  0x40
+#define hfc_INTS_TIMER    0x80
+
+/* bits in INT_M2 */
+#define hfc_M2_PROC_TRANS    0x01
+#define hfc_M2_GCI_I_CHG     0x02
+#define hfc_M2_GCI_MON_REC   0x04
+#define hfc_M2_IRQ_ENABLE    0x08
+#define hfc_M2_PMESEL        0x80
+
+/* bits in STATES */
+#define hfc_STATES_STATE_MASK     0x0F
+#define hfc_STATES_LOAD_STATE    0x10
+#define hfc_STATES_ACTIVATE	     0x20
+#define hfc_STATES_DO_ACTION     0x40
+#define hfc_STATES_NT_G2_G3      0x80
+
+/* bits in HFCD_MST_MODE */
+#define hfc_MST_MODE_MASTER	     0x01
+#define hfc_MST_MODE_SLAVE         0x00
+/* remaining bits are for codecs control */
+
+/* bits in HFCD_SCTRL */
+#define hfc_SCTRL_B1_ENA	     0x01
+#define hfc_SCTRL_B2_ENA	     0x02
+#define hfc_SCTRL_MODE_TE        0x00
+#define hfc_SCTRL_MODE_NT        0x04
+#define hfc_SCTRL_LOW_PRIO	     0x08
+#define hfc_SCTRL_SQ_ENA	     0x10
+#define hfc_SCTRL_TEST	     0x20
+#define hfc_SCTRL_NONE_CAP	     0x40
+#define hfc_SCTRL_PWR_DOWN	     0x80
+
+/* bits in SCTRL_E  */
+#define hfc_SCTRL_E_AUTO_AWAKE    0x01
+#define hfc_SCTRL_E_DBIT_1        0x04
+#define hfc_SCTRL_E_IGNORE_COL    0x08
+#define hfc_SCTRL_E_CHG_B1_B2     0x80
+
+/* bits in FIFO_EN register */
+#define hfc_FIFOEN_B1TX   0x01
+#define hfc_FIFOEN_B1RX   0x02
+#define hfc_FIFOEN_B2TX   0x04
+#define hfc_FIFOEN_B2RX   0x08
+#define hfc_FIFOEN_DTX    0x10
+#define hfc_FIFOEN_DRX    0x20
+
+#define hfc_FIFOEN_B1     (hfc_FIFOEN_B1TX|hfc_FIFOEN_B1RX)
+#define hfc_FIFOEN_B2     (hfc_FIFOEN_B2TX|hfc_FIFOEN_B2RX)
+#define hfc_FIFOEN_D      (hfc_FIFOEN_DTX|hfc_FIFOEN_DRX)
+
+/* bits in the CONNECT register */
+#define hfc_CONNECT_B1_shift	0
+#define hfc_CONNECT_B2_shift	3
+
+#define	hfc_CONNECT_HFC_from_ST		0x0
+#define hfc_CONNECT_HFC_from_GCI	0x1
+#define hfc_CONNECT_ST_from_HFC		0x0
+#define hfc_CONNECT_ST_from_GCI		0x2
+#define hfc_CONNECT_GCI_from_HFC	0x0
+#define	hfc_CONNECT_GCI_from_ST		0x4
+
+/* bits in the __SSL and __RSL registers */
+#define	hfc_SRSL_STIO	0x40
+#define hfc_SRSL_ENABLE	0x80
+#define hfc_SRCL_SLOT_MASK	0x1f
+
+/* FIFO memory definitions */
+
+#define hfc_FMASK	0x000f
+#define hfc_ZMASK	0x01ff
+#define hfc_ZMASKB	0x1fff
+
+#define hfc_D_FIFO_SIZE	0x0200
+#define hfc_B_SUB_VAL	0x0200
+#define hfc_B_FIFO_SIZE	0x1E00
+#define hfc_MAX_DFRAMES	0x000f
+
+#define hfc_FIFO_DTX_Z1	0x2080
+#define hfc_FIFO_DTX_Z2 0x2082
+#define hfc_FIFO_DTX_F1	0x20a0
+#define hfc_FIFO_DTX_F2	0x20a1
+#define hfc_FIFO_DTX	0x0000
+#define hfc_FIFO_DTX_ZOFF	0x000
+
+#define hfc_FIFO_DRX_Z1	0x6080
+#define hfc_FIFO_DRX_Z2 0x6082
+#define hfc_FIFO_DRX_F1	0x60a0
+#define hfc_FIFO_DRX_F2	0x60a1
+#define hfc_FIFO_DRX	0x4000
+#define hfc_FIFO_DRX_ZOFF	0x4000
+
+#define hfc_FIFO_B1TX_Z1	0x2000
+#define hfc_FIFO_B1TX_Z2 	0x2002
+#define hfc_FIFO_B1RX_Z1	0x6000
+#define hfc_FIFO_B1RX_Z2 	0x6002
+
+#define hfc_FIFO_B1TX_F1	0x2080
+#define hfc_FIFO_B1TX_F2	0x2081
+#define hfc_FIFO_B1RX_F1	0x6080
+#define hfc_FIFO_B1RX_F2	0x6081
+
+#define hfc_FIFO_B1RX_ZOFF	0x4000
+#define hfc_FIFO_B1TX_ZOFF	0x0000
+
+#define hfc_FIFO_B2TX_Z1	0x2100
+#define hfc_FIFO_B2TX_Z2 	0x2102
+#define hfc_FIFO_B2RX_Z1	0x6100
+#define hfc_FIFO_B2RX_Z2 	0x6102
+
+#define hfc_FIFO_B2TX_F1	0x2180
+#define hfc_FIFO_B2TX_F2	0x2181
+#define hfc_FIFO_B2RX_F1	0x6180
+#define hfc_FIFO_B2RX_F2	0x6181
+
+#define hfc_FIFO_B2RX_ZOFF	0x6000
+#define hfc_FIFO_B2TX_ZOFF	0x2000
+
+#define hfc_BTRANS_THRESHOLD 128
+#define hfc_BTRANS_THRESMASK 0x00
+
+/* Structures */
+
+typedef struct hfc_regs {
+    unsigned char fifo_en;
+    unsigned char ctmt;
+    unsigned char int_m1;
+    unsigned char int_m2;
+    unsigned char sctrl;
+    unsigned char sctrl_e;
+    unsigned char sctrl_r;
+    unsigned char connect;
+    unsigned char trm;
+    unsigned char mst_mode;
+    unsigned char bswapped;
+    unsigned char nt_mode;
+    unsigned char int_drec;
+} hfc_regs;
+
+typedef struct hfc_card {
+    spinlock_t lock;
+    unsigned int irq;
+    unsigned int iomem;
+    int ticks;		
+    int clicks;		
+    unsigned char *pci_io;
+    void *fifomem;		// start of the shared mem
+    volatile void *fifos;	// 32k aligned mem for the fifos
+    struct hfc_regs regs;
+    unsigned int pcibus;
+    unsigned int pcidevfn;
+    struct pci_dev *pcidev;
+    struct zt_hfc *ztdev;
+    int	drecinframe;
+    unsigned char drecbuf[hfc_D_FIFO_SIZE];
+    unsigned char dtransbuf[hfc_D_FIFO_SIZE];
+    unsigned char brecbuf[2][ZT_CHUNKSIZE];
+    unsigned char btransbuf[2][ZT_CHUNKSIZE];
+    unsigned char cardno;
+    struct hfc_card *next;
+} hfc_card;
+
+typedef struct zt_hfc {
+    unsigned int usecount;
+    struct zt_span span;
+    struct zt_chan chans[3];
+    struct hfc_card *card;
+} zt_hfc;
+
+/* tune this */
+#define hfc_BCHAN_BUFFER	8
+#define hfc_MAX_CARDS		8
diff -urNad --exclude=CVS --exclude=.svn ./zaphfc/zaptel.conf /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaptel.conf
--- ./zaphfc/zaptel.conf	1970-01-01 01:00:00.000000000 +0100
+++ /tmp/dpep-work.6etaUP/asterisk-1.0.9.dfsg/zaphfc/zaptel.conf	2005-07-14 07:01:19.173624848 +0100
@@ -0,0 +1,8 @@
+# hfc-s pci a span definition
+# most of the values should be bogus because we are not really zaptel
+loadzone=nl
+defaultzone=nl
+
+span=1,1,3,ccs,ami
+bchan=1-2
+dchan=3
