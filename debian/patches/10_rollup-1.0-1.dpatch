#! /bin/sh -e
## 10_rollup-1.0-1.dpatch by Kilian Krause <kk@verfaction.de>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: New patch generated from asterisk 0.9.1+1.0RC1-5 diff.gz

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p1 ${patch_opts} < $0;;
    -unpatch) patch -R -p1 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

@DPATCH@

--- asterisk-0.9.1+1.0RC1.orig/apps/app_zapbarge.c
+++ asterisk-0.9.1+1.0RC1/apps/app_zapbarge.c
@@ -34,7 +34,7 @@
 #include <sys/ioctl.h>
 
 #ifdef __linux__
-#include <linux/zaptel.h>
+#include "linux/zaptel.h"
 #else
 #include <zaptel.h>
 #endif /* __linux__ */
--- asterisk-0.9.1+1.0RC1.orig/apps/Makefile
+++ asterisk-0.9.1+1.0RC1/apps/Makefile
@@ -34,15 +34,16 @@
 APPS+=app_intercom.so
 endif
 
-#APPS+=app_sql_postgres.so
+APPS+=app_sql_postgres.so
 #APPS+=app_sql_odbc.so
 #APPS+=app_rpt.so
 
+APPS+=$(shell if [ -f ../include/linux/zaptel.h ]; then echo "app_zapras.so app_meetme.so app_flash.so app_zapbarge.so app_zapscan.so" ; fi)
 APPS+=$(shell if [ -f /usr/include/linux/zaptel.h ]; then echo "app_zapras.so app_meetme.so app_flash.so app_zapbarge.so app_zapscan.so" ; fi)
 APPS+=$(shell if [ -f /usr/local/include/zaptel.h ]; then echo "app_zapras.so app_meetme.so app_flash.so app_zapbarge.so app_zapscan.so" ; fi)
 APPS+=$(shell if [ -f /usr/include/osp/osp.h ]; then echo "app_osplookup.so" ; fi)
 
-CFLAGS+=-fPIC
+CFLAGS+=-fPIC -dPIC
 
 ifeq ($(USE_POSTGRES_VM_INTERFACE),1)
 CFLAGS+=-DUSEPOSTGRESVM
@@ -88,7 +89,7 @@
 	$(CC) $(SOLINK) -o $@ $< -lodbc
 
 look:	look.c
-	gcc -pipe -O6 -g look.c -o look -lncurses
+	gcc -pipe $(OPTIMIZE) -g look.c -o look -lncurses
 
 ifneq ($(wildcard .depend),)
 include .depend
--- asterisk-0.9.1+1.0RC1.orig/apps/app_flash.c
+++ asterisk-0.9.1+1.0RC1/apps/app_flash.c
@@ -22,7 +22,7 @@
 #include <asterisk/options.h>
 #include <sys/ioctl.h>
 #ifdef __linux__
-#include <linux/zaptel.h>
+#include "linux/zaptel.h"
 #else
 #include <zaptel.h>
 #endif /* __linux__ */
--- asterisk-0.9.1+1.0RC1.orig/apps/app_sql_postgres.c
+++ asterisk-0.9.1+1.0RC1/apps/app_sql_postgres.c
@@ -26,7 +26,7 @@
 #include <sys/types.h>
 #include <stdio.h>
 #include <unistd.h>
-#include "libpq-fe.h"
+#include "postgresql/libpq-fe.h"
 
 #define EXTRA_LOG 0
 
--- asterisk-0.9.1+1.0RC1.orig/astconf.h
+++ asterisk-0.9.1+1.0RC1/astconf.h
@@ -28,5 +28,6 @@
 extern char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
+extern char ast_config_AST_DATA_DIR[AST_CONFIG_MAX_PATH];
 
 #endif
--- asterisk-0.9.1+1.0RC1.orig/codecs/gsm/Makefile
+++ asterisk-0.9.1+1.0RC1/codecs/gsm/Makefile
@@ -65,7 +65,7 @@
 # CCFLAGS 	= -c -O
 
 CC		?= gcc
-CCFLAGS 	+= -c -DNeedFunctionPrototypes=1 -funroll-loops -fPIC $(OPTIMIZE) -fomit-frame-pointer
+CCFLAGS 	+= -c -DNeedFunctionPrototypes=1 -funroll-loops -fPIC -DPIC $(OPTIMIZE) -fomit-frame-pointer
 
 LD 		= $(CC)
 
--- asterisk-0.9.1+1.0RC1.orig/codecs/ilbc/Makefile
+++ asterisk-0.9.1+1.0RC1/codecs/ilbc/Makefile
@@ -1,8 +1,8 @@
 ARCH=$(PROC)
 ifeq (${OSARCH},Darwin)
-CFLAGS+=-Wall -Werror -fPIC -O3 -funroll-loops -fomit-frame-pointer
+CFLAGS+=-Wall -Werror -fPIC -O2 -funroll-loops -fomit-frame-pointer
 else
-CFLAGS+=-Wall -Werror -fPIC -O3 -march=$(ARCH) -funroll-loops -fomit-frame-pointer
+CFLAGS+=-Wall -Werror -fPIC -O2 -funroll-loops -fomit-frame-pointer
 endif
 LIB=libilbc.a
 
--- asterisk-0.9.1+1.0RC1.orig/codecs/Makefile
+++ asterisk-0.9.1+1.0RC1/codecs/Makefile
@@ -21,13 +21,13 @@
 MODG723+=$(shell [ -f g723.1b/coder2.c ] && echo "codec_g723_1b.so")
 MODSPEEX=$(shell [ -f /usr/include/speex.h ] || [ -f /usr/local/include/speex.h ] && echo "codec_speex.so")
 MODILBC=$(shell [ -f ilbc/iLBC_decode.h ] && echo "codec_ilbc.so")
-CFLAGS+=-fPIC
+CFLAGS+=-fPIC -DPIC
 CFLAGS+=$(shell [ -f /usr/local/include/speex.h ] && echo "-I/usr/local/include")
 
 LIBG723=g723.1/libg723.a
 LIBG723B=g723.1b/libg723b.a
-LIBGSM=gsm/lib/libgsm.a
-LIBGSMT=gsm/lib/libgsm.a
+LIBGSM=$(shell if [ -f /usr/lib/libgsm.a ]; then echo "-lgsm"; else echo "gsm/lib/libgsm.a" ; fi)
+LIBGSMT=$(shell if [ -f /usr/lib/libgsm.a ]; then echo "-lgsm"; else echo "gsm/lib/libgsm.a" ; fi)
 LIBLPC10=lpc10/liblpc10.a
 LIBSPEEX=$(shell [ -f /usr/local/lib/libspeex.a ] && echo "-L/usr/local/lib")
 LIBSPEEX+=-lspeex -lm
--- asterisk-0.9.1+1.0RC1.orig/codecs/lpc10/Makefile
+++ asterisk-0.9.1+1.0RC1/codecs/lpc10/Makefile
@@ -22,7 +22,7 @@
 # 
 
 WARNINGS = -Wall -Wno-comment -Wno-error
-CFLAGS += $(OPTIMIZE) -I$(LIB_TARGET_DIR) $(WARNINGS) -fPIC
+CFLAGS += $(OPTIMIZE) -I$(LIB_TARGET_DIR) $(WARNINGS) -fPIC -DPIC
 #CFLAGS+= $(shell if uname -m | grep -q 86; then echo "-mpentium" ; fi)
 
 #fix for PPC processors and ALPHA too
@@ -31,7 +31,7 @@
 ifneq ($(PROC),ppc)
 ifneq ($(PROC),x86_64)
 ifneq ($(PROC),alpha)
-	CFLAGS+= -march=$(PROC)
+	CFLAGS+=$(shell if $(CC) -march=$(PROC) -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-march=$(PROC)"; fi)
 endif
 endif
 endif
--- asterisk-0.9.1+1.0RC1.orig/codecs/codec_gsm.c
+++ asterisk-0.9.1+1.0RC1/codecs/codec_gsm.c
@@ -30,8 +30,8 @@
 #include <netinet/in.h>
 #include <string.h>
 #include <stdio.h>
+#include <gsm/gsm.h>
 
-#include "gsm/inc/gsm.h"
 #include "../formats/msgsm.h"
 
 /* Sample frame data */
--- asterisk-0.9.1+1.0RC1.orig/image.c
+++ asterisk-0.9.1+1.0RC1/image.c
@@ -95,9 +95,9 @@
 			snprintf(buf, len, "%s.%s", filename, ext);
 	} else {
 		if (preflang && strlen(preflang))
-			snprintf(buf, len, "%s/%s/%s-%s.%s", ast_config_AST_VAR_DIR, "images", filename, preflang, ext);
+			snprintf(buf, len, "%s/%s/%s-%s.%s", ast_config_AST_DATA_DIR, "images", filename, preflang, ext);
 		else
-			snprintf(buf, len, "%s/%s/%s.%s", ast_config_AST_VAR_DIR, "images", filename, ext);
+			snprintf(buf, len, "%s/%s/%s.%s", ast_config_AST_DATA_DIR, "images", filename, ext);
 	}
 }
 
--- asterisk-0.9.1+1.0RC1.orig/asterisk.c
+++ asterisk-0.9.1+1.0RC1/asterisk.c
@@ -120,6 +120,7 @@
 char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
 char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
 char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
+char ast_config_AST_DATA_DIR[AST_CONFIG_MAX_PATH];
 
 static char *_argv[256];
 static int shuttingdown = 0;
@@ -1453,6 +1454,7 @@
 	strncpy((char *)ast_config_AST_PID,AST_PID,sizeof(ast_config_AST_PID)-1);
 	strncpy((char *)ast_config_AST_SOCKET,AST_SOCKET,sizeof(ast_config_AST_SOCKET)-1);
 	strncpy((char *)ast_config_AST_RUN_DIR,AST_RUN_DIR,sizeof(ast_config_AST_RUN_DIR)-1);
+	strncpy((char *)ast_config_AST_DATA_DIR,AST_DATA_DIR,sizeof(ast_config_AST_DATA_DIR)-1);
 	
 	/* no asterisk.conf? no problem, use buildtime config! */
 	if (!cfg) {
@@ -1520,13 +1522,6 @@
 	tdd_init();
 	if (getenv("HOME")) 
 		snprintf(filename, sizeof(filename), "%s/.asterisk_history", getenv("HOME"));
-	/* Check if we're root */
-	/*
-	if (geteuid()) {
-		ast_log(LOG_ERROR, "Must be run as root\n");
-		exit(1);
-	}
-	*/
 	/* Check for options */
 	while((c=getopt(argc, argv, "hfdvqprRgcinx:C:")) != -1) {
 		switch(c) {
--- asterisk-0.9.1+1.0RC1.orig/cli.c
+++ asterisk-0.9.1+1.0RC1/cli.c
@@ -27,7 +27,7 @@
 #include <signal.h>
 #include <string.h>
 /* For rl_filename_completion */
-#include "editline/readline/readline.h"
+#include "readline/readline.h"
 /* For module directory */
 #include "asterisk.h"
 #include "build.h"
--- asterisk-0.9.1+1.0RC1.orig/include/linux/zaptel.h
+++ asterisk-0.9.1+1.0RC1/include/linux/zaptel.h
@@ -0,0 +1,1424 @@
+/*
+ * Zapata Telephony Interface
+ *
+ * Written by Mark Spencer <markster@linux-suppot.net>
+ * Based on previous works, designs, and architectures conceived and
+ * written by Jim Dixon <jim@lambdatel.com>.
+ *
+ * Copyright (C) 2001 Jim Dixon / Zapata Telephony.
+ * Copyright (C) 2001, Linux Support Services, Inc.
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ * $Id: zaptel.h,v 1.34 2004/06/30 14:08:42 malcolmd Exp $
+ */
+
+#ifndef _LINUX_ZAPTEL_H
+#define _LINUX_ZAPTEL_H
+
+#ifdef __KERNEL__
+#include "zconfig.h"
+#include <linux/config.h>
+#include <linux/version.h>
+#ifdef CONFIG_ZAPATA_NET	
+#include <linux/hdlc.h>
+#endif
+#ifdef CONFIG_ZAPATA_PPP
+#include <linux/ppp_channel.h>
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#endif
+#include <linux/fs.h>
+
+#include "ecdis.h"
+#include "fasthdlc.h"
+#endif
+#ifdef CONFIG_DEVFS_FS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/devfs_fs_kernel.h>
+#else
+#undef CONFIG_DEVFS_FS
+//#warning "Zaptel doesn't support DEVFS in post 2.4 kernels.  Disabling DEVFS in zaptel"
+#endif
+#endif /* CONFIG_DEVFS_FS */
+#include <linux/ioctl.h>
+
+#ifndef ELAST
+#define ELAST 500
+#endif
+
+/* Per-span configuration values */
+#define	ZT_CONFIG_TXLEVEL	7	/* bits 0-2 are tx level */
+
+/* Line configuration */
+/* These apply to T1 */
+#define ZT_CONFIG_D4	 (1 << 4)	
+#define ZT_CONFIG_ESF	 (1 << 5)
+#define ZT_CONFIG_AMI	 (1 << 6)
+#define ZT_CONFIG_B8ZS 	 (1 << 7)
+/* These apply to E1 */
+#define	ZT_CONFIG_CCS	 (1 << 8)	/* CCS (ISDN) instead of CAS (Robbed Bit) */
+#define	ZT_CONFIG_HDB3	 (1 << 9)	/* HDB3 instead of AMI (line coding) */
+#define	ZT_CONFIG_CRC4   (1 << 10)	/* CRC4 framing */
+#define ZT_CONFIG_NOTOPEN (1 << 16)
+
+/* Signalling types */
+#define __ZT_SIG_FXO	 (1 << 12)	/* Never use directly */
+#define __ZT_SIG_FXS	 (1 << 13)	/* Never use directly */
+
+#define ZT_SIG_NONE		(0)			/* Channel not configured */
+#define ZT_SIG_FXSLS	((1 << 0) | __ZT_SIG_FXS)	/* FXS, Loopstart */
+#define ZT_SIG_FXSGS	((1 << 1) | __ZT_SIG_FXS)	/* FXS, Groundstart */
+#define ZT_SIG_FXSKS	((1 << 2) | __ZT_SIG_FXS)	/* FXS, Kewlstart */
+
+#define ZT_SIG_FXOLS	((1 << 3) | __ZT_SIG_FXO)	/* FXO, Loopstart */
+#define ZT_SIG_FXOGS	((1 << 4) | __ZT_SIG_FXO)	/* FXO, Groupstart */
+#define ZT_SIG_FXOKS	((1 << 5) | __ZT_SIG_FXO)	/* FXO, Kewlstart */
+
+#define ZT_SIG_EM	(1 << 6)		/* Ear & Mouth (E&M) */
+
+/* The following are all variations on clear channel */
+
+#define __ZT_SIG_DACS	 (1 << 16)
+
+#define ZT_SIG_CLEAR	 (1 << 7)					/* Clear channel */
+#define ZT_SIG_HDLCRAW	((1 << 8)  | ZT_SIG_CLEAR)	/* Raw unchecked HDLC */
+#define ZT_SIG_HDLCFCS	((1 << 9)  | ZT_SIG_HDLCRAW)	/* HDLC with FCS calculation */
+#define ZT_SIG_HDLCNET	((1 << 10) | ZT_SIG_HDLCFCS)	/* HDLC Network */
+#define ZT_SIG_SLAVE	 (1 << 11) 					/* Slave to another channel */
+#define	ZT_SIG_SF	 (1 << 14)			/* Single Freq. tone only, no sig bits */
+#define ZT_SIG_CAS	 (1 << 15)			/* Just get bits */
+#define ZT_SIG_DACS	(__ZT_SIG_DACS | ZT_SIG_CLEAR)	/* Cross connect */
+#define ZT_SIG_EM_E1	 (1 << 17)			/* E1 E&M Variation */
+#define ZT_SIG_DACS_RBS	 ((1 << 18) | __ZT_SIG_DACS)	/* Cross connect w/ RBS */
+
+/* tone flag values */
+#define	ZT_REVERSE_RXTONE 1  /* reverse polarity rx tone logic */
+#define	ZT_REVERSE_TXTONE 2  /* reverse polarity tx tone logic */
+
+#define ZT_ABIT			8
+#define ZT_BBIT			4
+#define	ZT_CBIT			2
+#define	ZT_DBIT			1
+
+#define ZT_MAJOR	196
+
+#define ZT_CODE	'J'
+
+/* Default chunk size for conferences and such -- static right now, might make
+   variable sometime.  8 samples = 1 ms = most frequent service interval possible
+   for a USB device */
+#define ZT_CHUNKSIZE		 8
+#define ZT_MIN_CHUNKSIZE	 ZT_CHUNKSIZE
+#define ZT_DEFAULT_CHUNKSIZE	 ZT_CHUNKSIZE
+#define ZT_MAX_CHUNKSIZE 	 ZT_CHUNKSIZE
+#define ZT_CB_SIZE		 2
+
+#define ZT_MAX_BLOCKSIZE 	 8192
+#define ZT_DEFAULT_NUM_BUFS	 2
+#define ZT_MAX_NUM_BUFS		 32
+#define ZT_MAX_BUF_SPACE         32768
+
+#define ZT_DEFAULT_BLOCKSIZE 1024
+#define ZT_DEFAULT_MTR_MRU	 2048
+
+#define ZT_POLICY_IMMEDIATE	 0		/* Start play/record immediately */
+#define ZT_POLICY_WHEN_FULL  1		/* Start play/record when buffer is full */
+
+#define	RING_DEBOUNCE_TIME	2000	/* 2000 ms ring debounce time */
+
+#ifdef __KERNEL__
+/* Echo cancellation */
+#if defined(ECHO_CAN_STEVE)
+#include "sec.h"
+#elif defined(ECHO_CAN_STEVE2)
+#include "sec-2.h"
+#elif defined(ECHO_CAN_MARK)
+#include "mec.h"
+#elif defined(ECHO_CAN_MARK2)
+#include "mec2.h"
+#else
+#include "mec3.h"
+#endif
+#endif
+
+typedef struct zt_params
+{
+int channo;		/* Channel number */
+int spanno;		/* Span itself */
+int chanpos;	/* Channel number in span */
+int	sigtype;  /* read-only */
+int sigcap;	 /* read-only */
+int rxisoffhook; /* read-only */
+int rxbits;	/* read-only */
+int txbits;	/* read-only */
+int txhooksig;	/* read-only */
+int rxhooksig;	/* read-only */
+int curlaw;	/* read-only  -- one of ZT_LAW_MULAW or ZT_LAW_ALAW */
+int idlebits;	/* read-only  -- What is considered the idle state */
+char name[40];	/* Name of channel */
+int	prewinktime;
+int	preflashtime;
+int	winktime;
+int	flashtime;
+int	starttime;
+int	rxwinktime;
+int	rxflashtime;
+int	debouncetime;
+} ZT_PARAMS;
+
+typedef struct zt_spaninfo
+{
+int	spanno;		/* span number (or -1 to use name) */
+char name[20];	/* Name of span */
+char desc[40];	/* Description of span */
+int	alarms;		/* alarms status */
+int	txlevel;	/* what TX level is set to */
+int	rxlevel;	/* current RX level */
+int	bpvcount;	/* current BPV count */
+int	crc4count;	/* current CRC4 error count */
+int	ebitcount;	/* current E-bit error count */
+int	fascount;	/* current FAS error count */
+int	irqmisses;	/* current IRQ misses */
+int	syncsrc;	/* span # of current sync source, or 0 for free run  */
+int	numchans;	/* number of configured channels on this span */
+int	totalchans;	/* total number of channels on the span */
+int	totalspans;	/* total number of zaptel spans in entire system */
+} ZT_SPANINFO;
+
+typedef struct zt_maintinfo
+{
+int	spanno;		/* span number 1-2 */
+int	command;	/* command */
+} ZT_MAINTINFO;
+
+typedef struct zt_confinfo
+{
+int	chan;		/* channel number, 0 for current */
+int	confno;		/* conference number */
+int	confmode;	/* conferencing mode */
+} ZT_CONFINFO;
+
+typedef struct zt_gains
+{
+int	chan;		/* channel number, 0 for current */
+unsigned char rxgain[256];	/* Receive gain table */
+unsigned char txgain[256];	/* Transmit gain table */
+} ZT_GAINS;
+
+typedef struct zt_lineconfig
+{
+int span;		/* Which span number (0 to use name) */
+char name[20];	/* Name of span to use */
+int	lbo;		/* line build-outs */
+int	lineconfig;	/* line config parameters (framing, coding) */
+int	sync;		/* what level of sync source we are */
+} ZT_LINECONFIG;
+
+typedef struct zt_chanconfig
+{
+int	chan;		/* Channel we're applying this to (0 to use name) */
+char name[40];		/* Name of channel to use */
+int	sigtype;	/* Signal type */
+int	deflaw;		/* Default law (ZT_LAW_DEFAULT, ZT_LAW_MULAW, or ZT_LAW_ALAW */
+int	master;		/* Master channel if sigtype is ZT_SLAVE */
+int	idlebits;	/* Idle bits (if this is a CAS channel) or
+			   channel to monitor (if this is DACS channel) */
+} ZT_CHANCONFIG;
+
+typedef struct zt_sfconfig
+{
+int	chan;		/* Channel we're applying this to (0 to use name) */
+char name[40];		/* Name of channel to use */
+long	rxp1;		/* receive tone det. p1 */
+long	rxp2;		/* receive tone det. p2 */
+long	rxp3;		/* receive tone det. p3 */
+int	txtone;		/* Tx tone factor */
+int	tx_v2;		/* initial v2 value */
+int	tx_v3;		/* initial v3 value */
+int	toneflag;	/* Tone flags */
+} ZT_SFCONFIG;
+
+typedef struct zt_bufferinfo
+{
+int txbufpolicy;	/* Policy for handling receive buffers */
+int rxbufpolicy;	/* Policy for handling receive buffers */
+int numbufs;		/* How many buffers to use */
+int bufsize;		/* How big each buffer is */
+int readbufs;		/* How many read buffers are full (read-only) */
+int writebufs;		/* How many write buffers are full (read-only) */
+} ZT_BUFFERINFO;
+
+typedef struct zt_dialparams
+{
+int mfv1_tonelen;	/* MF tone length (KP = this * 5/3) */
+int dtmf_tonelen;	/* DTMF tone length */
+int reserved[4];	/* Reserved for future expansion -- always set to 0 */
+} ZT_DIAL_PARAMS;
+
+
+typedef struct zt_dynamic_span {
+	char driver[20];	/* Which low-level driver to use */
+	char addr[40];		/* Destination address */
+	int numchans;		/* Number of channels */
+	int timing;		/* Timing source preference */
+	int spanno;		/* Span number (filled in by zaptel) */
+} ZT_DYNAMIC_SPAN;
+
+/* Define the max # of outgoing DTMF or MFv1 digits to queue in-kernel */
+#define ZT_MAX_DTMF_BUF 256
+
+#define ZT_DIAL_OP_APPEND	1
+#define ZT_DIAL_OP_REPLACE	2
+#define ZT_DIAL_OP_CANCEL	3
+
+#define ZT_LAW_DEFAULT	0	/* Default law for span */
+#define ZT_LAW_MULAW	1	/* Mu-law */
+#define ZT_LAW_ALAW	2	/* A-law */
+
+typedef struct zt_dialoperation
+{
+int op;
+char dialstr[ZT_MAX_DTMF_BUF];
+} ZT_DIAL_OPERATION;
+
+
+/* ioctl definitions */
+#define ZT_CODE	'J'
+
+/*
+ * Get Transfer Block Size.
+ */
+#define ZT_GET_BLOCKSIZE	_IOR (ZT_CODE, 1, int)
+
+/*
+ * Set Transfer Block Size.
+ */
+#define ZT_SET_BLOCKSIZE	_IOW (ZT_CODE, 2, int)
+
+/*
+ * Flush Buffer(s) and stop I/O
+ */
+#define	ZT_FLUSH		_IOW (ZT_CODE, 3, int)
+
+/*
+ * Wait for Write to Finish
+ */
+#define	ZT_SYNC		_IOW (ZT_CODE, 4, int)
+
+/*
+ * Get channel parameters
+ */
+#define ZT_GET_PARAMS		_IOR (ZT_CODE, 5, struct zt_params)
+
+/*
+ * Get channel parameters
+ */
+#define ZT_SET_PARAMS		_IOW (ZT_CODE, 6, struct zt_params)
+
+/*
+ * Set Hookswitch Status
+ */
+#define ZT_HOOK		_IOW (ZT_CODE, 7, int)
+
+/*
+ * Get Signalling Event
+ */
+#define ZT_GETEVENT		_IOR (ZT_CODE, 8, int)
+
+/*
+ * Wait for something to happen (IO Mux)
+ */
+#define ZT_IOMUX		_IOWR (ZT_CODE, 9, int)
+
+/*
+ * Get Span Status
+ */
+#define ZT_SPANSTAT		_IOWR (ZT_CODE, 10, struct zt_spaninfo)
+
+/*
+ * Set Maintenance Mode
+ */
+#define ZT_MAINT		_IOW (ZT_CODE, 11, struct zt_maintinfo)
+
+/*
+ * Get Conference Mode
+ */
+#define ZT_GETCONF		_IOWR (ZT_CODE, 12, struct zt_confinfo)
+
+/*
+ * Set Conference Mode
+ */
+#define ZT_SETCONF		_IOWR (ZT_CODE, 13, struct zt_confinfo)
+
+/*
+ * Setup or Remove Conference Link
+ */
+#define ZT_CONFLINK		_IOW (ZT_CODE, 14, struct zt_confinfo)
+
+/*
+ * Display Conference Diagnostic Information on Console
+ */
+#define ZT_CONFDIAG		_IOR (ZT_CODE, 15, int)
+
+/*
+ * Get Channel audio gains
+ */
+#define ZT_GETGAINS		_IOWR (ZT_CODE, 16, struct zt_gains)
+
+/*
+ * Set Channel audio gains
+ */
+#define ZT_SETGAINS		_IOWR (ZT_CODE, 17, struct zt_gains)
+
+/*
+ * Set Line (T1) Configurations and start system
+ */
+#define	ZT_SPANCONFIG		_IOW (ZT_CODE, 18, struct zt_lineconfig)
+
+/*
+ * Set Channel Configuration
+ */
+#define	ZT_CHANCONFIG		_IOW (ZT_CODE, 19, struct zt_chanconfig)
+
+/*
+ * Set Conference to mute mode
+ */
+#define	ZT_CONFMUTE		_IOW (ZT_CODE, 20, int)
+
+/*
+ * Send a particular tone (see ZT_TONE_*)
+ */
+#define	ZT_SENDTONE		_IOW (ZT_CODE, 21, int)
+
+/*
+ * Set your region for tones (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_SETTONEZONE		_IOW (ZT_CODE, 22, int)
+
+/*
+ * Retrieve current region for tones (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_GETTONEZONE		_IOR (ZT_CODE, 23, int)
+
+/*
+ * Master unit only -- set default zone (see ZT_TONE_ZONE_*)
+ */
+#define	ZT_DEFAULTZONE		_IOW (ZT_CODE, 24, int)
+
+/*
+ * Load a tone zone from a ZT_tone_def_header, see
+ * below...
+ */
+#define ZT_LOADZONE		_IOW (ZT_CODE, 25, struct zt_tone_def_header)
+
+/*
+ * Free a tone zone 
+ */
+#define ZT_FREEZONE		_IOW (ZT_CODE, 26, int)
+
+/*
+ * Set buffer policy 
+ */
+#define ZT_SET_BUFINFO		_IOW (ZT_CODE, 27, struct zt_bufferinfo)
+
+/*
+ * Get current buffer info
+ */
+#define ZT_GET_BUFINFO		_IOR (ZT_CODE, 28, struct zt_bufferinfo)
+
+/*
+ * Get dialing parameters
+ */
+#define ZT_GET_DIALPARAMS	_IOR (ZT_CODE, 29, struct zt_dialparams)
+
+/*
+ * Set dialing parameters
+ */
+#define ZT_SET_DIALPARAMS	_IOW (ZT_CODE, 30, struct zt_dialparams)
+
+/*
+ * Append, replace, or cancel a dial string
+ */
+#define ZT_DIAL			_IOW (ZT_CODE, 31, struct zt_dialoperation)
+
+/*
+ * Set a clear channel into audio mode
+ */
+#define ZT_AUDIOMODE		_IOW (ZT_CODE, 32, int)
+
+/*
+ * Enable or disable echo cancellation on a channel 
+ * The number is zero to disable echo cancellation and non-zero
+ * to enable echo cancellation.  If the number is between 32
+ * and 256, it will also set the number of taps in the echo canceller
+ */
+#define ZT_ECHOCANCEL		_IOW (ZT_CODE, 33, int)
+
+/*
+ * Return a channel's channel number (useful for the /dev/zap/pseudo type interfaces 
+ */
+#define ZT_CHANNO		_IOR (ZT_CODE, 34, int)
+
+/*
+ * Return a flag indicating whether channel is currently dialing
+ */
+#define ZT_DIALING		_IOR (ZT_CODE, 35, int)
+
+/* Numbers 60 to 90 are reserved for private use of low level hardware
+   drivers */
+
+/*
+ * Set a clear channel into HDLC w/out FCS checking/calculation mode
+ */
+#define ZT_HDLCRAWMODE		_IOW (ZT_CODE, 36, int)
+
+/*
+ * Set a clear channel into HDLC w/ FCS mode
+ */
+#define ZT_HDLCFCSMODE		_IOW (ZT_CODE, 37, int)
+
+/* 
+ * Specify a channel on /dev/zap/chan -- must be done before any other ioctl's and is only
+ * valid on /dev/zap/chan
+ */
+#define ZT_SPECIFY		_IOW (ZT_CODE, 38, int)
+
+/*
+ * Temporarily set the law on a channel to 
+ * ZT_LAW_DEFAULT, ZT_LAW_ALAW, or ZT_LAW_MULAW.  Is reset on close.  
+ */
+#define ZT_SETLAW		_IOW (ZT_CODE, 39, int)
+
+/*
+ * Temporarily set the channel to operate in linear mode when non-zero
+ * or default law if 0
+ */
+#define ZT_SETLINEAR		_IOW (ZT_CODE, 40, int)
+
+/*
+ * Set a clear channel into HDLC w/ PPP interface mode
+ */
+#define ZT_HDLCPPP		_IOW (ZT_CODE, 41, int)
+
+/*
+ * Set the ring cadence for FXS interfaces
+ */
+#define ZT_SETCADENCE		_IOW (ZT_CODE, 42, struct zt_ring_cadence)
+
+/*
+ * Set the bits going out for CAS interface
+ */
+#define ZT_SETTXBITS			_IOW (ZT_CODE, 43, int)
+
+
+/*
+ * Display Channel Diagnostic Information on Console
+ */
+#define ZT_CHANDIAG		_IOR (ZT_CODE, 44, int) 
+
+/* 
+ * Obtain received signalling
+ */
+#define ZT_GETRXBITS _IOR (ZT_CODE, 45, int)
+
+/*
+ * Set Channel's SF Tone Configuration
+ */
+#define	ZT_SFCONFIG		_IOW (ZT_CODE, 46, struct zt_sfconfig)
+
+/*
+ * Set timer expiration (in samples)
+ */
+#define ZT_TIMERCONFIG	_IOW (ZT_CODE, 47, int)
+
+/*
+ * Acknowledge timer expiration (number to acknowledge, or -1 for all)
+ */
+#define ZT_TIMERACK _IOW (ZT_CODE, 48, int)
+
+/*
+ * Get Conference to mute mode
+ */
+#define	ZT_GETCONFMUTE		_IOR (ZT_CODE, 49, int)
+
+/*
+ * Request echo training in some number of ms (with muting in the mean time)
+ */
+#define	ZT_ECHOTRAIN		_IOW (ZT_CODE, 50, int)
+
+/*
+ * Set on hook transfer for n number of ms -- implemnted by low level driver
+ */
+#define	ZT_ONHOOKTRANSFER		_IOW (ZT_CODE, 51, int)
+
+/*
+ * Queue Ping
+ */
+#define ZT_TIMERPING _IOW (ZT_CODE, 42, int) /* Should be 52, but works */
+
+/*
+ * Acknowledge ping
+ */
+#define ZT_TIMERPONG _IOW (ZT_CODE, 53, int)
+
+/*
+ * Set/get signalling freeze
+ */
+#define ZT_SIGFREEZE _IOW (ZT_CODE, 54, int)
+#define ZT_GETSIGFREEZE _IOR (ZT_CODE, 55, int)
+
+/*
+ *  60-80 are reserved for private drivers
+ *  80-85 are reserved for dynamic span stuff
+ */
+
+/*
+ * Create a dynamic span
+ */
+#define ZT_DYNAMIC_CREATE	_IOWR (ZT_CODE, 80, struct zt_dynamic_span)
+
+/* 
+ * Destroy a dynamic span 
+ */
+#define ZT_DYNAMIC_DESTROY	_IOW (ZT_CODE, 81, struct zt_dynamic_span)
+
+/* 
+ * Startup or Shutdown a span
+ */
+#define ZT_STARTUP		_IOW (ZT_CODE, 99, int)
+#define ZT_SHUTDOWN		_IOW (ZT_CODE, 100, int)
+
+#define ZT_TONE_ZONE_MAX		128
+
+#define ZT_TONE_ZONE_DEFAULT 	-1	/* To restore default */
+
+#define ZT_TONE_STOP		-1
+#define ZT_TONE_DIALTONE	0
+#define ZT_TONE_BUSY		1
+#define ZT_TONE_RINGTONE	2
+#define ZT_TONE_CONGESTION	3
+#define ZT_TONE_CALLWAIT	4
+#define ZT_TONE_DIALRECALL	5
+#define ZT_TONE_RECORDTONE	6
+#define ZT_TONE_INFO		7
+#define ZT_TONE_CUST1		8
+#define ZT_TONE_CUST2		9
+#define ZT_TONE_STUTTER		10
+#define ZT_TONE_MAX		16
+
+#define ZT_MAX_CADENCE		16
+
+struct zt_ring_cadence {
+	int ringcadence [ZT_MAX_CADENCE];
+};
+
+struct zt_tone_def_header {
+	int count;		/* How many samples follow */
+	int zone;		/* Which zone we are loading */
+	int ringcadence[ZT_MAX_CADENCE];	/* Ring cadence in ms (0=on, 1=off, ends with 0 value) */
+	char name[40];		/* Informational name of zone */
+	/* Immediately follow the ZT_tone_def_header by ZT_tone_def's */
+};
+
+struct zt_tone_def {		/* Structure for zone programming */
+	int tone;		/* See ZT_TONE_* */
+	int next;		/* What the next position in the cadence is
+				   (They're numbered by the order the appear here) */
+	int samples;		/* How many samples to play for this cadence */
+				/* Now come the constants we need to make tones */
+	int shift;		/* How much to scale down the volume (2 is nice) */
+
+	/* 
+		Calculate the next 6 factors using the following equations:
+		l = <level in dbm>, f1 = <freq1>, f2 = <freq2>
+		gain = pow(10.0, (l - 3.14) / 20.0) * 65536.0 / 2.0;
+
+		// Frequency factor 1 
+		fac_1 = 2.0 * cos(2.0 * M_PI * (f1/8000.0)) * 32768.0;
+		// Last previous two samples 
+		init_v2_1 = sin(-4.0 * M_PI * (f1/8000.0)) * gain;
+		init_v3_1 = sin(-2.0 * M_PI * (f1/8000.0)) * gain;
+
+		// Frequency factor 2 
+		fac_2 = 2.0 * cos(2.0 * M_PI * (f2/8000.0)) * 32768.0;
+		// Last previous two samples 
+		init_v2_2 = sin(-4.0 * M_PI * (f2/8000.0)) * gain;
+		init_v3_2 = sin(-2.0 * M_PI * (f2/8000.0)) * gain;
+	*/
+	int fac1;		
+	int init_v2_1;		
+	int init_v3_1;		
+	int fac2;		
+	int init_v2_2;		
+	int init_v3_2;
+	int modulate;
+
+};
+
+#ifdef __KERNEL__
+#endif /* KERNEL */
+
+/* Define the maximum block size */
+#define	ZT_MAX_BLOCKSIZE	8192
+
+/* Define the default network block size */
+#define ZT_DEFAULT_MTU_MRU	2048
+
+/* Flush and stop the read (input) process */
+#define	ZT_FLUSH_READ		1
+
+/* Flush and stop the write (output) process */
+#define	ZT_FLUSH_WRITE		2
+
+/* Flush and stop both (input and output) processes */
+#define	ZT_FLUSH_BOTH		(ZT_FLUSH_READ | ZT_FLUSH_WRITE)
+
+/* Flush the event queue */
+#define	ZT_FLUSH_EVENT		4
+
+/* Flush everything */
+#define	ZT_FLUSH_ALL		(ZT_FLUSH_READ | ZT_FLUSH_WRITE | ZT_FLUSH_EVENT)
+
+
+/* Value for ZT_HOOK, set to ON hook */
+#define	ZT_ONHOOK	0
+
+/* Value for ZT_HOOK, set to OFF hook */
+#define	ZT_OFFHOOK	1
+
+/* Value for ZT_HOOK, wink (off hook momentarily) */
+#define	ZT_WINK		2
+
+/* Value for ZT_HOOK, flash (on hook momentarily) */
+#define	ZT_FLASH	3
+
+/* Value for ZT_HOOK, start line */
+#define	ZT_START	4
+
+/* Value for ZT_HOOK, ring line (same as start line) */
+#define	ZT_RING		5
+
+/* Value for ZT_HOOK, turn ringer off */
+#define ZT_RINGOFF  6
+
+/* Ret. Value for GET/WAIT Event, no event */
+#define	ZT_EVENT_NONE	0
+
+/* Ret. Value for GET/WAIT Event, Went Onhook */
+#define	ZT_EVENT_ONHOOK 1
+
+/* Ret. Value for GET/WAIT Event, Went Offhook or got Ring */
+#define	ZT_EVENT_RINGOFFHOOK 2
+
+/* Ret. Value for GET/WAIT Event, Got Wink or Flash */
+#define	ZT_EVENT_WINKFLASH 3
+
+/* Ret. Value for GET/WAIT Event, Got Alarm */
+#define	ZT_EVENT_ALARM	4
+
+/* Ret. Value for GET/WAIT Event, Got No Alarm (after alarm) */
+#define	ZT_EVENT_NOALARM 5
+
+/* Ret. Value for GET/WAIT Event, HDLC Abort frame */
+#define ZT_EVENT_ABORT 6
+
+/* Ret. Value for GET/WAIT Event, HDLC Frame overrun */
+#define ZT_EVENT_OVERRUN 7
+
+/* Ret. Value for GET/WAIT Event, Bad FCS */
+#define ZT_EVENT_BADFCS 8
+
+/* Ret. Value for dial complete */
+#define ZT_EVENT_DIALCOMPLETE	9
+
+/* Ret Value for ringer going on */
+#define ZT_EVENT_RINGERON 10
+
+/* Ret Value for ringer going off */
+#define ZT_EVENT_RINGEROFF 11
+
+/* Ret Value for hook change complete */
+#define ZT_EVENT_HOOKCOMPLETE 12
+
+/* Ret Value for bits changing on a CAS / User channel */
+#define ZT_EVENT_BITSCHANGED 13
+
+/* Ret value for the beginning of a pulse coming on its way */
+#define ZT_EVENT_PULSE_START 14
+
+/* Timer event -- timer expired */
+#define ZT_EVENT_TIMER_EXPIRED	15
+
+/* Timer event -- ping ready */
+#define ZT_EVENT_TIMER_PING		16
+
+#define ZT_EVENT_PULSEDIGIT (1 << 16)	/* This is OR'd with the digit received */
+#define ZT_EVENT_DTMFDIGIT  (1 << 17)	/* Ditto for DTMF */
+
+/* Flag Value for IOMUX, read avail */
+#define	ZT_IOMUX_READ	1
+
+/* Flag Value for IOMUX, write avail */
+#define	ZT_IOMUX_WRITE	2
+
+/* Flag Value for IOMUX, write done */
+#define	ZT_IOMUX_WRITEEMPTY	4
+
+/* Flag Value for IOMUX, signalling event avail */
+#define	ZT_IOMUX_SIGEVENT	8
+
+/* Flag Value for IOMUX, Do Not Wait if nothing to report */
+#define	ZT_IOMUX_NOWAIT	0x100
+
+/* Alarm Condition bits */
+#define	ZT_ALARM_NONE		0	/* No alarms */
+#define	ZT_ALARM_RECOVER	1	/* Recovering from alarm */
+#define	ZT_ALARM_LOOPBACK	2	/* In loopback */
+#define	ZT_ALARM_YELLOW		4	/* Yellow Alarm */
+#define	ZT_ALARM_RED		8	/* Red Alarm */
+#define	ZT_ALARM_BLUE		16	/* Blue Alarm */
+#define ZT_ALARM_NOTOPEN	32
+/* Maintenance modes */
+#define	ZT_MAINT_NONE		0	/* Normal Mode */
+#define	ZT_MAINT_LOCALLOOP	1	/* Local Loopback */
+#define	ZT_MAINT_REMOTELOOP	2	/* Remote Loopback */
+#define	ZT_MAINT_LOOPUP	3	/* send loopup code */
+#define	ZT_MAINT_LOOPDOWN	4	/* send loopdown code */
+#define	ZT_MAINT_LOOPSTOP	5	/* stop sending loop codes */
+
+
+/* Conference modes */
+#define	ZT_CONF_MODE_MASK 0xff		/* mask for modes */
+#define	ZT_CONF_NORMAL	0		/* normal mode */
+#define	ZT_CONF_MONITOR 1		/* monitor mode (rx of other chan) */
+#define	ZT_CONF_MONITORTX 2		/* monitor mode (tx of other chan) */
+#define	ZT_CONF_MONITORBOTH 3		/* monitor mode (rx & tx of other chan) */
+#define	ZT_CONF_CONF 4			/* conference mode */
+#define	ZT_CONF_CONFANN 5		/* conference announce mode */
+#define	ZT_CONF_CONFMON 6		/* conference monitor mode */
+#define	ZT_CONF_CONFANNMON 7		/* conference announce/monitor mode */
+#define	ZT_CONF_REALANDPSEUDO 8	/* real and pseudo port both on conf */
+#define ZT_CONF_DIGITALMON 9	/* Do not decode or interpret */
+#define	ZT_CONF_FLAG_MASK 0xff00	/* mask for flags */
+#define	ZT_CONF_LISTENER 0x100		/* is a listener on the conference */
+#define	ZT_CONF_TALKER 0x200		/* is a talker on the conference */
+#define	ZT_CONF_PSEUDO_LISTENER 0x400	/* pseudo is a listener on the conference */
+#define	ZT_CONF_PSEUDO_TALKER 0x800	/* pseudo is a talker on the conference */
+
+
+#define	ZT_DEFAULT_WINKTIME	150	/* 150 ms default wink time */
+#define	ZT_DEFAULT_FLASHTIME	750	/* 750 ms default flash time */
+
+#define	ZT_DEFAULT_PREWINKTIME	50	/* 50 ms before wink */
+#define	ZT_DEFAULT_PREFLASHTIME 50	/* 50 ms before flash */
+#define	ZT_DEFAULT_STARTTIME 1500	/* 1500 ms of start */
+#define	ZT_DEFAULT_RINGTIME 2000	/* 2000 ms of ring on (start, FXO) */
+#if 0
+#define	ZT_DEFAULT_RXWINKTIME 250	/* 250ms longest rx wink */
+#endif
+#define	ZT_DEFAULT_RXWINKTIME 300	/* 300ms longest rx wink (to work with the Atlas) */
+#define	ZT_DEFAULT_RXFLASHTIME 1250	/* 1250ms longest rx flash */
+#define	ZT_DEFAULT_DEBOUNCETIME 600	/* 600ms of FXS GS signalling debounce */
+
+#define	ZT_MINPULSETIME (15 * 8)	/* 15 ms minimum */
+#define	ZT_MAXPULSETIME (150 * 8)	/* 150 ms maximum */
+#define	ZT_PULSETIMEOUT ((ZT_MAXPULSETIME / 8) + 50)
+
+#define ZT_RINGTRAILER (50 * 8)	/* Don't consider a ring "over" until it's been gone at least this
+									   much time */
+
+#define	ZT_LOOPCODE_TIME 10000		/* send loop codes for 10 secs */
+#define	ZT_ALARMSETTLE_TIME	5000	/* allow alarms to settle for 5 secs */
+#define	ZT_AFTERSTART_TIME 500		/* 500ms after start */
+
+#define ZT_RINGOFFTIME 4000		/* Turn off ringer for 4000 ms */
+#define	ZT_KEWLTIME 500		/* 500ms for kewl pulse */
+#define	ZT_AFTERKEWLTIME 300    /* 300ms after kewl pulse */
+
+#define ZT_MAX_PRETRAINING   1000	/* 1000ms max pretraining time */
+
+#define ZT_MAX_SPANS		128		/* Max, 128 spans */
+#define ZT_MAX_CHANNELS		1024	/* Max, 1024 channels */
+#define ZT_MAX_CONF			1024	/* Max, 1024 conferences */
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/poll.h>
+
+#define	ZT_MAX_EVENTSIZE	64	/* 64 events max in buffer */
+
+struct zt_span;
+struct zt_chan;
+
+struct zt_tone_state {
+	int v1_1;
+	int v2_1;
+	int v3_1;
+	int v1_2;
+	int v2_2;
+	int v3_2;
+	int modulate;
+};
+
+#ifdef CONFIG_ZAPATA_NET
+struct zt_hdlc {
+	hdlc_device netdev;
+	struct zt_chan *chan;
+};
+#endif
+
+/* Conference queue stucture */
+struct confq {
+	u_char buffer[ZT_CHUNKSIZE * ZT_CB_SIZE];
+	u_char *buf[ZT_CB_SIZE];
+	int inbuf;
+	int outbuf;
+};
+
+typedef struct
+{
+	long	x1;
+	long	x2;
+	long	y1;
+	long	y2;
+	long	e1;
+	long	e2;
+	int	samps;
+	int	lastdetect;
+} sf_detect_state_t;
+
+struct zt_chan {
+#ifdef CONFIG_ZAPATA_NET
+	/* Must be first */
+	struct zt_hdlc *hdlcnetdev;
+#endif
+#ifdef CONFIG_ZAPATA_PPP
+	struct ppp_channel *ppp;
+	struct tasklet_struct ppp_calls;
+	int do_ppp_wakeup;
+	int do_ppp_error;
+	struct sk_buff_head ppp_rq;
+#endif
+	spinlock_t lock;
+	char name[40];		/* Name */
+	/* Specified by zaptel */
+	int channo;			/* Zaptel Channel number */
+	int chanpos;
+	int flags;
+	long rxp1;
+	long rxp2;
+	long rxp3;
+	int txtone;
+	int tx_v2;
+	int tx_v3;
+	int v1_1;
+	int v2_1;
+	int v3_1;
+	int toneflags;
+	sf_detect_state_t rd;
+
+	struct zt_chan *master;	/* Our Master channel (could be us) */
+	/* Next slave (if appropriate) */
+	int nextslave;
+
+	u_char *writechunk;						/* Actual place to write to */
+	u_char swritechunk[ZT_MAX_CHUNKSIZE];	/* Buffer to be written */
+	u_char *readchunk;						/* Actual place to read from */
+	u_char sreadchunk[ZT_MAX_CHUNKSIZE];	/* Preallocated static area */
+	
+	/* Pointer to tx and rx gain tables */
+	u_char *rxgain;
+	u_char *txgain;
+	
+	/* Whether or not we have allocated gains or are using the default */
+	int gainalloc;
+
+	/* Specified by driver, readable by zaptel */
+	void *pvt;			/* Private channel data */
+	struct file *file;	/* File structure */
+	
+	
+	struct zt_span *span;		/* Span we're a member of */
+	int sig;			/* Signalling */
+	int sigcap;			/* Capability for signalling */
+	
+
+	/* Used only by zaptel -- NO DRIVER SERVICEABLE PARTS BELOW */
+	/* Buffer declarations */
+	u_char		*readbuf[ZT_MAX_NUM_BUFS];	/* read buffer */
+	int		inreadbuf;
+	int		outreadbuf;
+	wait_queue_head_t readbufq; /* read wait queue */
+
+	u_char		*writebuf[ZT_MAX_NUM_BUFS]; /* write buffers */
+	int		inwritebuf;
+	int		outwritebuf;
+	wait_queue_head_t writebufq; /* write wait queue */
+	
+	int		blocksize;	/* Block size */
+
+	int		eventinidx;  /* out index in event buf (circular) */
+	int		eventoutidx;  /* in index in event buf (circular) */
+	unsigned int	eventbuf[ZT_MAX_EVENTSIZE];  /* event circ. buffer */
+	wait_queue_head_t eventbufq; /* event wait queue */
+	
+	wait_queue_head_t txstateq;	/* waiting on the tx state to change */
+	
+	int		readn[ZT_MAX_NUM_BUFS];  /* # of bytes ready in read buf */
+	int		readidx[ZT_MAX_NUM_BUFS];  /* current read pointer */
+	int		writen[ZT_MAX_NUM_BUFS];  /* # of bytes ready in write buf */
+	int		writeidx[ZT_MAX_NUM_BUFS];  /* current write pointer */
+	
+	int		numbufs;			/* How many buffers in channel */
+	int		txbufpolicy;			/* Buffer policy */
+	int		rxbufpolicy;			/* Buffer policy */
+	int		txdisable;				/* Disable transmitter */
+	int 	rxdisable;				/* Disable receiver */
+	
+	
+	/* Tone zone stuff */
+	struct zt_zone *curzone;		/* Zone for selecting tones */
+	int 	tonezone;				/* Tone zone for this channel */
+	struct zt_tone *curtone;		/* Current tone we're playing (if any) */
+	int		tonep;					/* Current position in tone */
+	struct zt_tone_state ts;		/* Tone state */
+
+	/* Ring cadence */
+	int ringcadence[ZT_MAX_CADENCE];
+
+	/* Digit string dialing stuff */
+	int		digitmode;			/* What kind of tones are we sending? */
+	char	txdialbuf[ZT_MAX_DTMF_BUF];
+	int 	dialing;
+	int	afterdialingtimer;
+	int		cadencepos;				/* Where in the cadence we are */
+
+	/* I/O Mask */	
+	int		iomask;  /* I/O Mux signal mask */
+	wait_queue_head_t sel;	/* thingy for select stuff */
+	
+	/* HDLC state machines */
+	struct fasthdlc_state txhdlc;
+	struct fasthdlc_state rxhdlc;
+	int infcs;
+
+	/* Conferencing stuff */
+	int		confna;	/* conference number (alias) */
+	int		_confn;	/* Actual conference number */
+	int		confmode;  /* conference mode */
+	int		confmute; /* conference mute mode */
+
+	/* Incoming and outgoing conference chunk queues for
+	   communicating between zaptel master time and
+	   other boards */
+	struct confq confin;
+	struct confq confout;
+
+	short	getlin[ZT_MAX_CHUNKSIZE];			/* Last transmitted samples */
+	unsigned char getraw[ZT_MAX_CHUNKSIZE];		/* Last received raw data */
+	short	getlin_lastchunk[ZT_MAX_CHUNKSIZE];	/* Last transmitted samples from last chunk */
+	short	putlin[ZT_MAX_CHUNKSIZE];			/* Last received samples */
+	unsigned char putraw[ZT_MAX_CHUNKSIZE];		/* Last received raw data */
+	short	conflast[ZT_MAX_CHUNKSIZE];			/* Last conference sample -- base part of channel */
+	short	conflast1[ZT_MAX_CHUNKSIZE];		/* Last conference sample  -- pseudo part of channel */
+	short	conflast2[ZT_MAX_CHUNKSIZE];		/* Previous last conference sample -- pseudo part of channel */
+	
+
+	/* Is echo cancellation enabled or disabled */
+	int		echocancel;
+	echo_can_state_t	*ec;
+	echo_can_disable_detector_state_t txecdis;
+	echo_can_disable_detector_state_t rxecdis;
+	
+	int 	echostate;		/* State of echo canceller */
+	int		echolastupdate;	/* Last echo can update pos */
+	int		echotimer;		/* Timer for echo update */
+
+	/* RBS timings  */
+	int		prewinktime;  /* pre-wink time (ms) */
+	int		preflashtime;	/* pre-flash time (ms) */
+	int		winktime;  /* wink time (ms) */
+	int		flashtime;  /* flash time (ms) */
+	int		starttime;  /* start time (ms) */
+	int		rxwinktime;  /* rx wink time (ms) */
+	int		rxflashtime; /* rx flash time (ms) */
+	int		debouncetime;  /* FXS GS sig debounce time (ms) */
+
+	/* RING debounce timer */
+	int	ringdebtimer;
+	
+	/* RING trailing detector to make sure a RING is really over */
+	int ringtrailer;
+
+	/* PULSE digit receiver stuff */
+	int	pulsecount;
+	int	pulsetimer;
+
+	/* RBS timers */
+	int 	itimerset;		/* what the itimer was set to last */
+	int 	itimer;
+	int 	otimer;
+	
+	/* RBS state */
+	int gotgs;
+	int txstate;
+	int rxsig;
+	int txsig;
+	int rxsigstate;
+
+	/* non-RBS rx state */
+	int rxhooksig;
+	int txhooksig;
+	int kewlonhook;
+
+	/* Idle signalling if CAS signalling */
+	int idlebits;
+
+	int deflaw;		/* 1 = mulaw, 2=alaw, 0=undefined */
+	short *xlaw;
+#ifdef CONFIG_CALC_XLAW
+	unsigned char (*lineartoxlaw)(short a);
+#else
+	unsigned char *lin2x;
+#endif
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_handle_t fhandle;  /* File handle in devfs for the channel */
+	devfs_handle_t fhandle_symlink;
+#endif /* CONFIG_DEVFS_FS */
+};
+
+/* defines for transmit signalling */
+typedef enum {
+	ZT_TXSIG_ONHOOK,			/* On hook */
+	ZT_TXSIG_OFFHOOK,			/* Off hook */
+	ZT_TXSIG_START,				/* Start / Ring */
+	ZT_TXSIG_KEWL				/* Drop battery if possible */
+} zt_txsig_t;
+
+typedef enum {
+	ZT_RXSIG_ONHOOK,
+	ZT_RXSIG_OFFHOOK,
+	ZT_RXSIG_START,
+	ZT_RXSIG_RING,
+	ZT_RXSIG_INITIAL
+} zt_rxsig_t;
+	
+
+/* Span flags */
+#define ZT_FLAG_REGISTERED		(1 << 0)
+#define ZT_FLAG_RUNNING			(1 << 1)
+#define ZT_FLAG_RBS			(1 << 12)	/* Span uses RBS signalling */
+
+/* Channel flags */
+#define ZT_FLAG_DTMFDECODE		(1 << 2)	/* Channel supports native DTMF decode */
+#define ZT_FLAG_MFDECODE		(1 << 3)	/* Channel supports native MFr2 decode */
+#define ZT_FLAG_ECHOCANCEL		(1 << 4)	/* Channel supports native echo cancellation */
+
+#define ZT_FLAG_HDLC			(1 << 5)	/* Perform HDLC */
+#define ZT_FLAG_NETDEV			(1 << 6)	/* Send to network */
+#define ZT_FLAG_PSEUDO			(1 << 7)	/* Pseudo channel */
+#define ZT_FLAG_CLEAR			(1 << 8)	/* Clear channel */
+#define ZT_FLAG_AUDIO			(1 << 9)	/* Audio mode channel */
+
+#define ZT_FLAG_OPEN			(1 << 10)	/* Channel is open */
+#define ZT_FLAG_FCS			(1 << 11)	/* Calculate FCS */
+/* Reserve 12 for uniqueness with span flags */
+#define ZT_FLAG_LINEAR			(1 << 13)	/* Talk to user space in linear */
+#define ZT_FLAG_PPP			(1 << 14)	/* PPP is available */
+#define ZT_FLAG_T1PPP			(1 << 15)
+#define ZT_FLAG_SIGFREEZE		(1 << 16)	/* Freeze signalling */
+
+struct zt_span {
+	spinlock_t lock;
+	void *pvt;			/* Private stuff */
+	char name[40];			/* Span name */
+	char desc[80];			/* Span description */
+	int deflaw;			/* Default law (ZT_MULAW or ZT_ALAW) */
+	int alarms;			/* Pending alarms on span */
+	int flags;
+	int irq;			/* IRQ for this span's hardware */
+	int lbo;			/* Span Line-Buildout */
+	int lineconfig;			/* Span line configuration */
+	int linecompat;			/* Span line compatibility */
+	int channels;			/* Number of channels in span */
+	int txlevel;			/* Tx level */
+	int rxlevel;			/* Rx level */
+	int syncsrc;			/* current sync src (gets copied here) */
+	unsigned int bpvcount;		/* BPV counter */
+	unsigned int crc4count;	        /* CRC4 error counter */
+	unsigned int ebitcount;		/* current E-bit error count */
+	unsigned int fascount;		/* current FAS error count */
+
+	int maintstat;			/* Maintenance state */
+	wait_queue_head_t maintq;	/* Maintenance queue */
+	int mainttimer;			/* Maintenance timer */
+	
+	int irqmisses;			/* Interrupt misses */
+
+	struct zt_chan *chans;		/* Member channel structures */
+
+	/*   ==== Span Callback Operations ====   */
+	/* Req: Set the requested chunk size.  This is the unit in which you must
+	   report results for conferencing, etc */
+	int (*setchunksize)(struct zt_span *span, int chunksize);
+
+	/* Opt: Configure the span (if appropriate) */
+	int (*spanconfig)(struct zt_span *span, struct zt_lineconfig *lc);
+	
+	/* Opt: Start the span */
+	int (*startup)(struct zt_span *span);
+	
+	/* Opt: Shutdown the span */
+	int (*shutdown)(struct zt_span *span);
+	
+	/* Opt: Enable maintenance modes */
+	int (*maint)(struct zt_span *span, int mode);
+
+	/* ====  Channel Callback Operations ==== */
+	/* Opt: Set signalling type (if appropriate) */
+	int (*chanconfig)(struct zt_chan *chan, int sigtype);
+
+	/* Opt: Prepare a channel for I/O */
+	int (*open)(struct zt_chan *chan);
+
+	/* Opt: Close channel for I/O */
+	int (*close)(struct zt_chan *chan);
+	
+	/* Opt: IOCTL */
+	int (*ioctl)(struct zt_chan *chan, unsigned int cmd, unsigned long data);
+	
+	/* Okay, now we get to the signalling.  You have several options: */
+
+	/* Option 1: If you're a T1 like interface, you can just provide a
+	   rbsbits function and we'll assert robbed bits for you.  Be sure to 
+	   set the ZT_FLAG_RBS in this case.  */
+
+	/* Opt: If the span uses A/B bits, set them here */
+	int (*rbsbits)(struct zt_chan *chan, int bits);
+	
+	/* Option 2: If you don't know about sig bits, but do have their
+	   equivalents (i.e. you can disconnect battery, detect off hook,
+	   generate ring, etc directly) then you can just specify a
+	   sethook function, and we'll call you with appropriate hook states
+	   to set.  Still set the ZT_FLAG_RBS in this case as well */
+	int (*hooksig)(struct zt_chan *chan, zt_txsig_t hookstate);
+	
+	/* Option 3: If you can't use sig bits, you can write a function
+	   which handles the individual hook states  */
+	int (*sethook)(struct zt_chan *chan, int hookstate);
+
+	/* Used by zaptel only -- no user servicable parts inside */
+	int spanno;			/* Span number for zaptel */
+	int offset;			/* Offset within a given card */
+	int lastalarms;		/* Previous alarms */
+
+#ifdef CONFIG_DEVFS_FS
+	devfs_handle_t dhandle;  /* Directory name */
+#endif	
+	/* If the watchdog detects no received data, it will call the
+	   watchdog routine */
+	int (*watchdog)(struct zt_span *span, int cause);
+#ifdef CONFIG_ZAPTEL_WATCHDOG
+	int watchcounter;
+	int watchstate;
+#endif	
+};
+
+#define ZT_WATCHDOG_NOINTS		(1 << 0)
+
+#define ZT_WATCHDOG_INIT			1000
+
+#define ZT_WATCHSTATE_UNKNOWN		0
+#define ZT_WATCHSTATE_OK			1
+#define ZT_WATCHSTATE_RECOVERING	2
+#define ZT_WATCHSTATE_FAILED		3
+
+
+struct zt_dynamic_driver {
+	/* Driver name (e.g. Eth) */
+	char name[20];
+
+	/* Driver description */
+	char desc[80];
+
+	/* Create a new transmission pipe */
+	void *(*create)(struct zt_span *span, char *address);
+
+	/* Destroy a created transmission pipe */
+	void (*destroy)(void *tpipe);
+
+	/* Transmit a given message */
+	int (*transmit)(void *tpipe, unsigned char *msg, int msglen);
+
+	struct zt_dynamic_driver *next;
+};
+
+/* Receive a dynamic span message */
+extern void zt_dynamic_receive(struct zt_span *span, unsigned char *msg, int msglen);
+
+/* Register a dynamic driver */
+extern int zt_dynamic_register(struct zt_dynamic_driver *driver);
+
+/* Unregister a dynamic driver */
+extern void zt_dynamic_unregister(struct zt_dynamic_driver *driver);
+
+/* Receive on a span.  The zaptel interface will handle all the calculations for
+   all member channels of the span, pulling the data from the readchunk buffer */
+extern int zt_receive(struct zt_span *span);
+
+/* Prepare writechunk buffers on all channels for this span */
+extern int zt_transmit(struct zt_span *span);
+
+
+/* Register a span.  Returns 0 on success, -1 on failure.  Pref-master is non-zero if
+   we should have preference in being the master device */
+extern int zt_register(struct zt_span *span, int prefmaster);
+
+/* Unregister a span */
+extern int zt_unregister(struct zt_span *span);
+
+/* Gives a name to an LBO */
+extern char *zt_lboname(int lbo);
+
+/* Tell Zaptel about changes in received rbs bits */
+extern void zt_rbsbits(struct zt_chan *chan, int bits);
+
+/* Tell Zaptel abou changes in received signalling */
+extern void zt_hooksig(struct zt_chan *chan, zt_rxsig_t rxsig);
+
+/* Queue an event on a channel */
+extern void zt_qevent_nolock(struct zt_chan *chan, int event);
+
+/* Queue an event on a channel, locking it first */
+extern void zt_qevent_lock(struct zt_chan *chan, int event);
+
+/* Notify a change possible change in alarm status */
+extern void zt_alarm_notify(struct zt_span *span);
+
+/* Initialize a tone state */
+extern void zt_init_tone_state(struct zt_tone_state *ts, struct zt_tone *zt);
+
+/* Get a given DTMF or MF tone struct, suitable for zt_tone_nextsample.
+   Set 'mf' to 0 for DTMF or 1 for MFv1 */
+extern struct zt_tone *zt_dtmf_tone(char digit, int mf);
+
+/* Echo cancel a receive and transmit chunk for a given channel.  This
+   should be called by the low-level driver as close to the interface
+   as possible.  ECHO CANCELLATION IS NO LONGER AUTOMATICALLY DONE
+   AT THE ZAPTEL LEVEL.  zt_ec_chunk will not echo cancel if it should
+   not be doing so.  rxchunk is modified in-place */
+
+extern void zt_ec_chunk(struct zt_chan *chan, unsigned char *rxchunk, const unsigned char *txchunk);
+
+/* Don't use these directly -- they're not guaranteed to
+   be there. */
+extern short __zt_mulaw[256];
+extern short __zt_alaw[256];
+#ifdef CONFIG_CALC_XLAW
+extern u_char __zt_lineartoulaw(short a);
+extern u_char __zt_lineartoalaw(short a);
+#else
+extern u_char __zt_lin2mu[16384];
+extern u_char __zt_lin2a[16384];
+#endif
+
+/* Used by dynamic zaptel -- don't use directly */
+extern void zt_set_dynamic_ioctl(int (*func)(unsigned int cmd, unsigned long data));
+
+/* Used privately by zaptel.  Avoid touching directly */
+struct zt_tone {
+	int fac1;
+	int init_v2_1;
+	int init_v3_1;
+
+	int fac2;
+	int init_v2_2;
+	int init_v3_2;
+
+	int tonesamples;		/* How long to play this tone before 
+					   going to the next (in samples) */
+	struct zt_tone *next;		/* Next tone in this sequence */
+
+	int modulate;
+};
+
+static inline short zt_tone_nextsample(struct zt_tone_state *ts, struct zt_tone *zt)
+{
+	/* follow the curves, return the sum */
+
+	int p;
+
+	ts->v1_1 = ts->v2_1;
+	ts->v2_1 = ts->v3_1;
+	ts->v3_1 = (zt->fac1 * ts->v2_1 >> 15) - ts->v1_1;
+
+	ts->v1_2 = ts->v2_2;
+	ts->v2_2 = ts->v3_2;
+	ts->v3_2 = (zt->fac2 * ts->v2_2 >> 15) - ts->v1_2;
+
+	/* Return top 16 bits */
+	if (!ts->modulate) return ts->v3_1 + ts->v3_2;
+	/* we are modulating */
+	p = ts->v3_2 - 32768;
+	if (p < 0) p = -p;
+	p = ((p * 9) / 10) + 1;
+	return (ts->v3_1 * p) >> 15;
+
+}
+
+static inline short zt_txtone_nextsample(struct zt_chan *ss)
+{
+	/* follow the curves, return the sum */
+
+	ss->v1_1 = ss->v2_1;
+	ss->v2_1 = ss->v3_1;
+	ss->v3_1 = (ss->txtone * ss->v2_1 >> 15) - ss->v1_1;
+	return ss->v3_1;
+}
+
+/* These are the right functions to use.  */
+
+#define ZT_MULAW(a) (__zt_mulaw[(a)])
+#define ZT_ALAW(a) (__zt_alaw[(a)])
+#define ZT_XLAW(a,c) (c->xlaw[(a)])
+
+#ifdef CONFIG_CALC_XLAW
+#define ZT_LIN2MU(a) (__zt_lineartoulaw((a)))
+#define ZT_LIN2A(a) (__zt_lineartoalaw((a)))
+
+#define ZT_LIN2X(a,c) ((c)->lineartoxlaw((a)))
+
+#else
+/* Use tables */
+#define ZT_LIN2MU(a) (__zt_lin2mu[((unsigned short)(a)) >> 2])
+#define ZT_LIN2A(a) (__zt_lin2a[((unsigned short)(a)) >> 2])
+
+/* Manipulate as appropriate for x-law */
+#define ZT_LIN2X(a,c) ((c)->lin2x[((unsigned short)(a)) >> 2])
+
+#endif /* CONFIG_CALC_XLAW */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_ZAPTEL_H */
--- asterisk-0.9.1+1.0RC1.orig/contrib/asterisk-ng-doxygen
+++ asterisk-0.9.1+1.0RC1/contrib/asterisk-ng-doxygen
@@ -707,7 +707,7 @@
 # toolkit from AT&T and Lucent Bell Labs. The other options in this section 
 # have no effect if this option is set to NO (the default)
 
-HAVE_DOT               = YES
+HAVE_DOT               = NO
 
 # If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
 # will generate a graph for each documented class showing the direct and 
--- asterisk-0.9.1+1.0RC1.orig/file.c
+++ asterisk-0.9.1+1.0RC1/file.c
@@ -282,7 +282,7 @@
 	int fnsize = 0;
 	char tmp[AST_CONFIG_MAX_PATH]="";
 
-	snprintf(tmp, sizeof(tmp), "%s/%s", ast_config_AST_VAR_DIR, "sounds");
+	snprintf(tmp, sizeof(tmp), "%s/%s", ast_config_AST_DATA_DIR, "sounds");
 	fnsize = strlen(tmp) + strlen(filename) + strlen(ext) + 10;
 	fn = malloc(fnsize);
 	if (fn) {
--- asterisk-0.9.1+1.0RC1.orig/formats/Makefile
+++ asterisk-0.9.1+1.0RC1/formats/Makefile
@@ -20,9 +20,9 @@
 #
 #FORMAT_LIBS+=format_g723.so
 
-GSMLIB=../codecs/gsm/lib/libgsm.a
+GSMLIB=$(shell if [ -f /usr/lib/libgsm.a ]; then echo "-lgsm"; else echo "../codecs/gsm/lib/libgsm.a" ; fi)
 
-CFLAGS+=-fPIC
+CFLAGS+=-fPIC -DPIC
 
 all: depend $(FORMAT_LIBS)
 
--- asterisk-0.9.1+1.0RC1.orig/res/Makefile
+++ asterisk-0.9.1+1.0RC1/res/Makefile
@@ -18,9 +18,10 @@
 
 CRYPTO_LIBS=-lssl -lcrypto
 
-CFLAGS+=
+CFLAGS+=-fPIC -DPIC
 CFLAGS+=$(shell [ -f /usr/include/linux/zaptel.h ] && echo " -DZAPATA_MOH")
 CFLAGS+=$(shell [ -f /usr/local/include/zaptel.h ] && echo " -DZAPATA_MOH")
+CFLAGS+=$(shell [ -f ../include/linux/zaptel.h ] && echo " -DZAPATA_MOH")
 #
 # Work around buggy RedHat 9.0
 #
--- asterisk-0.9.1+1.0RC1.orig/Makefile
+++ asterisk-0.9.1+1.0RC1/Makefile
@@ -18,6 +18,7 @@
 
 OSARCH=$(shell uname -s)
 
+ifeq ($(strip $(PROC)),)
 ifeq (${OSARCH},Linux)
 PROC=$(shell uname -m)
 ifeq ($(PROC),x86_64)
@@ -31,6 +32,7 @@
 ifeq ($(findstring BSD,${OSARCH}),BSD)
 PROC=$(shell uname -m)
 endif
+endif
 
 # Pentium Pro Optimize
 #PROC=i686
@@ -50,7 +52,7 @@
 #K6OPT  = -DK6OPT
 
 #Tell gcc to optimize the asterisk's code
-OPTIMIZE=-O6
+OPTIMIZE=-O2
 
 #Include debug symbols in the executables (-g) and profiling info (-pg)
 DEBUG=-g #-pg
@@ -107,16 +109,17 @@
 ASTCONFPATH=$(ASTETCDIR)/asterisk.conf
 ASTBINDIR=$(INSTALL_PREFIX)/usr/bin
 ASTSBINDIR=$(INSTALL_PREFIX)/usr/sbin
-ASTVARRUNDIR=$(INSTALL_PREFIX)/var/run
+ASTVARRUNDIR=$(INSTALL_PREFIX)/var/run/asterisk
+ASTDATADIR=$(INSTALL_PREFIX)/usr/share/asterisk
 
 MODULES_DIR=$(ASTLIBDIR)/modules
-AGI_DIR=$(ASTVARLIBDIR)/agi-bin
+AGI_DIR=$(ASTDATADIR)/agi-bin
 
 INCLUDE=-Iinclude -I../include
 CFLAGS=-pipe  -Wall -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations $(DEBUG) $(INCLUDE) -D_REENTRANT -D_GNU_SOURCE #-DMAKE_VALGRIND_HAPPY
 CFLAGS+=$(OPTIMIZE)
 CFLAGS+=$(shell if $(CC) -march=$(PROC) -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-march=$(PROC)"; fi)
-CFLAGS+=$(shell if uname -m | grep -q ppc; then echo "-fsigned-char"; fi)
+CFLAGS+=$(shell if uname -m | grep -q "ppc\|arm\|s390"; then echo "-fsigned-char"; fi)
 CFLAGS+=$(shell if [ -f /usr/include/osp/osp.h ]; then echo "-DOSP_SUPPORT -I/usr/include/osp" ; fi)
 
 ifeq (${OSARCH},FreeBSD)
@@ -137,7 +140,7 @@
 CFLAGS+=$(shell if [ -f /usr/include/linux/zaptel.h ]; then echo "-DZAPTEL_OPTIMIZATIONS"; fi)
 CFLAGS+=$(shell if [ -f /usr/local/include/zaptel.h ]; then echo "-DZAPTEL_OPTIMIZATIONS"; fi)
 
-LIBEDIT=editline/libedit.a
+LIBEDIT=$(shell if [ -f /usr/lib/libedit.a ]; then echo "-ledit"; else echo "editline/libedit.a"; fi)
 
 ASTERISKVERSION=$(shell if [ -f .version ]; then cat .version; else if [ -d CVS ]; then if [ -f CVS/Tag ] ; then echo "CVS-`sed 's/^T//g' CVS/Tag`-`date +"%D-%T"`"; else echo "CVS-HEAD-`date +"%D-%T"`"; fi; fi; fi)
 HTTPDIR=$(shell if [ -d /var/www ]; then echo "/var/www"; else echo "/home/httpd"; fi)
@@ -149,6 +152,7 @@
 CFLAGS+=-DASTVARLIBDIR=\"$(ASTVARLIBDIR)\"
 CFLAGS+=-DASTVARRUNDIR=\"$(ASTVARRUNDIR)\"
 CFLAGS+=-DASTSPOOLDIR=\"$(ASTSPOOLDIR)\"
+CFLAGS+=-DASTDATADIR=\"$(ASTDATADIR)\"
 CFLAGS+=-DASTLOGDIR=\"$(ASTLOGDIR)\"
 CFLAGS+=-DASTCONFPATH=\"$(ASTCONFPATH)\"
 CFLAGS+=-DASTMODDIR=\"$(MODULES_DIR)\"
@@ -256,7 +260,7 @@
 		exit 1; \
 	fi
 
-asterisk: editline/libedit.a db1-ast/libdb1.a stdtime/libtime.a $(OBJS)
+asterisk: db1-ast/libdb1.a stdtime/libtime.a $(OBJS)
 	$(CC) $(DEBUG) -o asterisk $(ASTLINK) $(OBJS) $(LIBEDIT) db1-ast/libdb1.a stdtime/libtime.a $(LIBS)
 
 muted: muted.o
@@ -275,10 +279,10 @@
 	$(MAKE) -C stdtime clean
 
 datafiles: all
-	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/sounds/digits
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/digits
 	for x in sounds/digits/*.gsm; do \
 		if grep -q "^%`basename $$x`%" sounds.txt; then \
-			install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/sounds/digits ; \
+			install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds/digits ; \
 		else \
 			echo "No description for $$x"; \
 			exit 1; \
@@ -304,16 +308,16 @@
 	done
 	for x in sounds/vm-* sounds/transfer* sounds/pbx-* sounds/ss-* sounds/beep* sounds/dir-* sounds/conf-* sounds/agent-* sounds/invalid* sounds/tt-* sounds/auth-* sounds/privacy-* sounds/queue-*; do \
 		if grep -q "^%`basename $$x`%" sounds.txt; then \
-			install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/sounds ; \
+			install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds ; \
 		else \
 			echo "No description for $$x"; \
 			exit 1; \
 		fi; \
 	done
-	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/mohmp3
-	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/images
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/mohmp3
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/images
 	for x in images/*.jpg; do \
-		install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/images ; \
+		install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/images ; \
 	done
 	mkdir -p $(DESTDIR)$(AGI_DIR)
 
@@ -333,6 +337,7 @@
 	mkdir -p $(DESTDIR)$(ASTBINDIR)
 	mkdir -p $(DESTDIR)$(ASTSBINDIR)
 	mkdir -p $(DESTDIR)$(ASTVARRUNDIR)
+	mkdir -p $(DESTDIR)$(ASTDATADIR)
 	mkdir -p $(DESTDIR)$(ASTSPOOLDIR)/voicemail
 	install -m 755 asterisk $(DESTDIR)$(ASTSBINDIR)/
 	install -m 755 contrib/scripts/astgenkey $(DESTDIR)$(ASTSBINDIR)/
@@ -342,15 +347,15 @@
 	for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
 	install -d $(DESTDIR)$(ASTHEADERDIR)
 	install -m 644 include/asterisk/*.h $(DESTDIR)$(ASTHEADERDIR)
-	rm -f $(DESTDIR)$(ASTVARLIBDIR)/sounds/vm
-	rm -f $(DESTDIR)$(ASTVARLIBDIR)/sounds/voicemail
+	rm -f $(DESTDIR)$(ASTDATADIR)/sounds/vm
+	rm -f $(DESTDIR)$(ASTDATADIR)/sounds/voicemail
 	if [ ! -h $(DESTDIR)$(ASTSPOOLDIR)/vm ] && [ -d $(DESTDIR)$(ASTSPOOLDIR)/vm ]; then \
 		mv $(DESTDIR)$(ASTSPOOLDIR)/vm $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default; \
 	else \
 		mkdir -p $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default; \
 		rm -f $(DESTDIR)$(ASTSPOOLDIR)/vm; \
 	fi
-	ln -s $(ASTSPOOLDIR)/voicemail/default $(DESTDIR)$(ASTSPOOLDIR)/vm
+	ln -s ../voicemail/default $(DESTDIR)$(ASTSPOOLDIR)/vm
 	rm -f $(DESTDIR)$(MODULES_DIR)/chan_ixj.so
 	rm -f $(DESTDIR)$(MODULES_DIR)/chan_tor.so
 	rm -f $(DESTDIR)$(MODULES_DIR)/cdr_mysql.so
@@ -358,7 +363,7 @@
 	rm -f $(DESTDIR)$(MODULES_DIR)/codec_mp3_d.so
 	rm -f $(DESTDIR)$(MODULES_DIR)/format_mp3.so
 	rm -f $(DESTDIR)$(MODULES_DIR)/app_voicemail2.so
-	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/sounds
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds
 	mkdir -p $(DESTDIR)$(ASTLOGDIR)/cdr-csv
 	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/keys
 	mkdir -p $(DESTDIR)$(ASTVARLIBDIR)/firmware
@@ -370,8 +375,8 @@
 	else \
 		echo "You need to do cvs update -d not just cvs update" ; \
 	fi 
-	( cd $(DESTDIR)$(ASTVARLIBDIR)/sounds  ; ln -s $(ASTSPOOLDIR)/vm . )
-	( cd $(DESTDIR)$(ASTVARLIBDIR)/sounds  ; ln -s $(ASTSPOOLDIR)/voicemail . )
+	( cd $(DESTDIR)$(ASTDATADIR)/sounds  ; ln -s /var/spool/asterisk/vm . )
+	( cd $(DESTDIR)$(ASTDATADIR)/sounds  ; ln -s /var/spool/asterisk/voicemail . )
 	@echo " +---- Asterisk Installation Complete -------+"  
 	@echo " +                                           +"
 	@echo " +    YOU MUST READ THE SECURITY DOCUMENT    +"
@@ -424,23 +429,23 @@
 	echo "astlogdir => $(ASTLOGDIR)" >> $(DESTDIR)$(ASTETCDIR)/asterisk.conf
 	for x in sounds/demo-*; do \
 		if grep -q "^%`basename $$x`%" sounds.txt; then \
-			install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/sounds ; \
+			install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds ; \
 		else \
 			echo "No description for $$x"; \
 			exit 1; \
 		fi; \
 	done
 	for x in sounds/*.mp3; do \
-		install -m 644 $$x $(DESTDIR)$(ASTVARLIBDIR)/mohmp3 ; \
+		install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/mohmp3 ; \
 	done
 	mkdir -p $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/INBOX
 	:> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/unavail.gsm
 	for x in vm-theperson digits/1 digits/2 digits/3 digits/4 vm-isunavail; do \
-		cat $(DESTDIR)$(ASTVARLIBDIR)/sounds/$$x.gsm >> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/unavail.gsm ; \
+		cat $(DESTDIR)$(ASTDATADIR)/sounds/$$x.gsm >> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/unavail.gsm ; \
 	done
 	:> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/busy.gsm
 	for x in vm-theperson digits/1 digits/2 digits/3 digits/4 vm-isonphone; do \
-		cat $(DESTDIR)$(ASTVARLIBDIR)/sounds/$$x.gsm >> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/busy.gsm ; \
+		cat $(DESTDIR)$(ASTDATADIR)/sounds/$$x.gsm >> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/busy.gsm ; \
 	done
 
 webvmail:
--- asterisk-0.9.1+1.0RC1.orig/pbx/Makefile
+++ asterisk-0.9.1+1.0RC1/pbx/Makefile
@@ -27,7 +27,7 @@
 MOC=$(QTDIR)/bin/moc
 KDE_FLAGS=-I$(KDEDIR)/include -I$(KDEDIR)/include/kde -I$(QTDIR)/include
 KDE_LIBS=-L$(KDEDIR)/lib -L$(QTDIR)/lib -lqt -lkdecore -lkdeui
-CFLAGS+=-fPIC
+CFLAGS+=-fPIC -DPIC
 
 KDE_CONSOLE_OBJS=pbx_kdeconsole_main.o pbx_kdeconsole.o 
 
--- asterisk-0.9.1+1.0RC1.orig/pbx/pbx_wilcalu.c
+++ asterisk-0.9.1+1.0RC1/pbx/pbx_wilcalu.c
@@ -12,7 +12,7 @@
  * the GNU General Public License
 
  *  Autodialer for Asterisk 
- *  Redirect dialstring thru fifo "/var/run/autodial.ctl"
+ *  Redirect dialstring thru fifo "/var/run/asterisk/autodial.ctl"
  *  Format of string is :
  *  "tech/tele,filename&" ie. "tor1/23,file&"
  */
--- asterisk-0.9.1+1.0RC1.orig/cdr/Makefile
+++ asterisk-0.9.1+1.0RC1/cdr/Makefile
@@ -12,10 +12,10 @@
 #
 
 #ADD cdr_pgsql.so to MODS= to include PostgreSQL support: REQUIRES PostgreSQL libs
-MODS=cdr_csv.so
+MODS=cdr_csv.so cdr_pgsql.so
 
 
-CFLAGS+=-fPIC
+CFLAGS+=-fPIC -DPIC
 
 OSARCH=$(shell uname -s)
 ifeq (${OSARCH},FreeBSD)
--- asterisk-0.9.1+1.0RC1.orig/channels/Makefile
+++ asterisk-0.9.1+1.0RC1/channels/Makefile
@@ -41,8 +41,8 @@
 CHANH323LIB=-L/usr/local/lib
 else
 MYSQLLIB=-L/usr/lib/mysql -lmysqlclient
-PTLIB=-lpt_linux_x86_r
-H323LIB=-lh323_linux_x86_r
+PTLIB=-lpt
+H323LIB=-lopenh323
 CHANH323LIB=-ldl
 endif
 
@@ -58,6 +58,7 @@
 CHANNEL_LIBS+=$(shell [ -f /usr/local/include/ixjuser.h ] && echo chan_phone.so)
 CHANNEL_LIBS+=$(shell [ -f h323/libchanh323.a ] && echo chan_h323.so)
 
+CFLAGS+=-fPIC -DPIC
 CFLAGS+=-Wno-missing-prototypes -Wno-missing-declarations
 CFLAGS+=$(shell [ ! -f /usr/include/linux/if_wanpipe.h ] && echo " -DOLD_SANGOMA_API")
 CHANNEL_LIBS+=$(shell [ -f /usr/include/alsa/asoundlib.h ] && echo "chan_alsa.so")
@@ -66,6 +67,7 @@
 CFLAGS+=$(shell [ -f alsa-monitor.h ] && echo " -DALSA_MONITOR")
 ZAPPRI=$(shell [ -f /usr/lib/libpri.so.1 ] && echo "-lpri")
 ZAPR2=$(shell [ -f /usr/lib/libmfcr2.so.1 ] && echo "-lmfcr2")
+CFLAGS+=$(shell [ -f ../include/linux/zaptel.h ] && echo "-DIAX_TRUNKING")
 CFLAGS+=$(shell [ -f /usr/include/linux/zaptel.h ] && echo "-DIAX_TRUNKING")
 CFLAGS+=$(shell [ -f /usr/local/include/zaptel.h ] && echo "-DIAX_TRUNKING")
 CHANNEL_LIBS+=$(shell [ -f /usr/include/vpbapi.h ] && echo "chan_vpb.so" )
@@ -89,6 +91,7 @@
 
 ZAPDIR=/usr/lib
 
+CHANNEL_LIBS+=$(shell [ -f ../include/linux/zaptel.h ] && echo "chan_zap.so")
 CHANNEL_LIBS+=$(shell [ -f /usr/include/linux/zaptel.h ] && echo "chan_zap.so")
 CHANNEL_LIBS+=$(shell [ -f /usr/local/include/zaptel.h ] && echo "chan_zap.so")
 
--- asterisk-0.9.1+1.0RC1.orig/channels/h323/Makefile
+++ asterisk-0.9.1+1.0RC1/channels/h323/Makefile
@@ -1,5 +1,9 @@
 # include the Makefile of OpenH323 
 
+OPENH323DIR=/usr/share/openh323
+PWLIBDIR=/usr/share/pwlib
+
+
 ifndef OPENH323DIR
 OPENH323DIR=$(HOME)/openh323
 endif
@@ -21,7 +25,7 @@
 #
 OSARCH=$(shell uname -s)
 ifneq (${OSARCH},FreeBSD)
-CFLAGS += -march=$(shell uname -m)
+CFLAGS+=$(shell if $(CC) -march=$(PROC) -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-march=$(PROC)"; fi)
 endif
 CFLAGS += -DPBYTE_ORDER=PLITTLE_ENDIAN
 
@@ -57,10 +61,11 @@
 CFLAGS += -DP_HAS_SEMAPHORES -DP_SSL -DP_PTHREADS
 CFLAGS += -DPHAS_TEMPLATES -DPTRACING -DP_USE_PRAGMA
 CFLAGS += -I../../include
-CFLAGS += -I$(PWLIBDIR)/include/ptlib/unix -I$(PWLIBDIR)/include
-CFLAGS += -I$(OPENH323DIR)/include
-CFLAGS += -Wno-missing-prototypes -Wno-missing-declarations
-LIBS+= -lcrypto -lssl -lexpat
+CFLAGS += -I/usr/include/pwlib -I/usr/share/pwlib/include -I/usr/include/openh323
+#CFLAGS += -I$(PWLIBDIR)/include/ptlib/unix -I$(PWLIBDIR)/include
+#CFLAGS += -I$(OPENH323DIR)/include
+#CFLAGS += -Wno-missing-prototypes -Wno-missing-declarations
+LIBS+= -lcrypto -lssl -lexpat -lpt -lopenh323
 
 all:   	libchanh323.a
 
--- asterisk-0.9.1+1.0RC1.orig/asterisk.h
+++ asterisk-0.9.1+1.0RC1/asterisk.h
@@ -28,11 +28,12 @@
 #define AST_AGI_DIR	ASTAGIDIR
 #define AST_KEY_DIR	ASTVARLIBDIR "/keys"
 #define AST_DB		ASTVARLIBDIR "/astdb"
+#define AST_DATA_DIR	ASTDATADIR
 
 #define AST_CONFIG_FILE ASTCONFPATH
 
-#define AST_SOUNDS AST_VAR_DIR "/sounds"
-#define AST_IMAGES AST_VAR_DIR "/images"
+#define AST_SOUNDS ASTDATADIR "/sounds"
+#define AST_IMAGES ASTDATADIR "/images"
 
 /* Provided by module.c */
 extern int load_modules(void);
--- asterisk-0.9.1+1.0RC1.orig/.version.debdiff
+++ asterisk-0.9.1+1.0RC1/.version.debdiff
@@ -0,0 +1 @@
+CVS-05/31/04-22:00:51
