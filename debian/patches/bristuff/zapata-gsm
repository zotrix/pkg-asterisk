--- a/channels/chan_zap.c
+++ b/channels/chan_zap.c
@@ -77,6 +77,9 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #ifdef HAVE_PRI
 #include <bristuffed/libpri.h>
 #endif
+#ifdef HAVE_GSMAT
+#include <libgsmat.h>
+#endif
 
 #include "asterisk/lock.h"
 #include "asterisk/channel.h"
@@ -185,6 +188,7 @@ static const char config[] = "zapata.con
 #define SIG_FXOGS	ZT_SIG_FXOGS
 #define SIG_FXOKS	ZT_SIG_FXOKS
 #define SIG_PRI		ZT_SIG_CLEAR
+#define SIG_GSM		(0x100000 | ZT_SIG_CLEAR)
 #define	SIG_SF		ZT_SIG_SF
 #define SIG_SFWINK 	(0x0100000 | ZT_SIG_SF)
 #define SIG_SF_FEATD	(0x0200000 | ZT_SIG_SF)
@@ -234,6 +238,8 @@ static int matchdigittimeout = 3000;
 /*! \brief Protect the interface list (of zt_pvt's) */
 AST_MUTEX_DEFINE_STATIC(iflock);
 
+static char gsm_modem_pin[20];
+static char gsm_modem_exten[AST_MAX_EXTENSION];
 
 static int ifcount = 0;
 
@@ -251,6 +257,7 @@ static enum ast_bridge_result zt_bridge(
 
 static int zt_sendtext(struct ast_channel *c, const char *text);
 
+static int zt_sendmessage(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 
 /*! \brief Avoid the silly zt_getevent which ignores a bunch of events */
 static inline int zt_get_event(int fd)
@@ -364,6 +371,19 @@ struct zt_pri {
 	int debugfd;
 };
 
+#ifdef HAVE_GSMAT
+struct zt_gsm {
+	pthread_t master;
+	ast_mutex_t lock;		/* Mutex */
+	int fd;
+	int span;
+	struct gsm_modul *modul;
+	char pin[256];
+	int available;
+	char exten[AST_MAX_EXTENSION];		/* Where to idle extra calls */
+	struct zt_pvt *pvt;
+};
+#endif
 
 static struct zt_pri pris[NUM_SPANS];
 
@@ -392,6 +412,7 @@ struct zt_pri;
 #define POLARITY_REV    1
 
 
+
 static struct zt_distRings drings;
 
 struct distRingData {
@@ -604,6 +625,9 @@ static struct zt_pvt {
 	int prioffset;
 	int logicalspan;
 #endif	
+#ifdef HAVE_GSMAT
+	struct zt_gsm gsm;
+#endif
 	int polarity;
 	int dsp_features;
 	char begindigit;
@@ -710,7 +734,7 @@ static struct zt_chan_conf zt_chan_conf_
 static struct ast_channel *zt_request(const char *type, int format, void *data, int *cause);
 static int zt_digit_begin(struct ast_channel *ast, char digit);
 static int zt_digit_end(struct ast_channel *ast, char digit, unsigned int duration);
-static int zt_sendtext(struct ast_channel *c, const char *text);
+static int zt_sendmessage(struct ast_channel *c, const char *dest, const char *text, int ispdu);
 static int zt_call(struct ast_channel *ast, char *rdest, int timeout);
 static int zt_hangup(struct ast_channel *ast);
 static int zt_answer(struct ast_channel *ast);
@@ -732,6 +756,7 @@ static const struct ast_channel_tech zap
 	.send_digit_begin = zt_digit_begin,
 	.send_digit_end = zt_digit_end,
 	.send_text = zt_sendtext,
+	.send_message = zt_sendmessage,
 	.call = zt_call,
 	.hangup = zt_hangup,
 	.answer = zt_answer,
@@ -1262,6 +1287,8 @@ static char *zap_sig2str(int sig)
 		return "GR-303 with FXOKS";
 	case SIG_GR303FXSKS:
 		return "GR-303 with FXSKS";
+	case SIG_GSM:
+		return "GSM";
 	case 0:
 		return "Pseudo";
 	default:
@@ -1683,7 +1710,7 @@ static inline int zt_confmute(struct zt_
 {
 	int x, y, res;
 	x = muted;
-	if (p->sig == SIG_PRI) {
+	if ((p->sig == SIG_PRI) || (p->sig == SIG_GSM)) {
 		y = 1;
 		res = ioctl(p->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &y);
 		if (res)
@@ -2098,6 +2125,25 @@ static int zt_call(struct ast_channel *a
 		p->dialdest[0] = '\0';
 		disable_dtmf_detect(p);
 		break;
+	case SIG_GSM:
+#ifdef HAVE_GSMAT
+		if (p->gsm.modul) {
+		    c = strchr(dest, '/');
+		    if (c)
+			c++;
+		    else
+			c = dest;
+		    ast_mutex_lock(&p->gsm.lock);
+		    if (gsm_dial(p->gsm.modul, p->use_callingpres ? ast->cid.cid_pres : 0, c)) {
+			ast_log(LOG_WARNING, "dialing failed on channel %d\n", p->channel);
+			ast_mutex_unlock(&p->gsm.lock);
+			ast_mutex_unlock(&p->lock);
+			return -1;
+		    }
+		    ast_mutex_unlock(&p->gsm.lock);
+		}
+#endif
+		break;
 	default:
 		ast_log(LOG_DEBUG, "not yet implemented\n");
 		ast_mutex_unlock(&p->lock);
@@ -2737,7 +2783,13 @@ static int zt_hangup(struct ast_channel 
 			}
 		}
 #endif
-		if (p->sig && (p->sig != SIG_PRI))
+#ifdef HAVE_GSMAT
+		if (p->gsm.modul) {
+		    if (!p->alreadyhungup)
+			gsm_hangup(p->gsm.modul);
+		}
+#endif
+		if (p->sig && (p->sig != SIG_PRI) && (p->sig != SIG_GSM))
 			res = zt_set_hook(p->subs[SUB_REAL].zfd, ZT_ONHOOK);
 		if (res < 0) {
 			ast_log(LOG_WARNING, "Unable to hangup line %s\n", ast->name);
@@ -2914,6 +2966,13 @@ static int zt_answer(struct ast_channel 
 		zt_train_ec(p);
 		break;
 #endif
+#ifdef HAVE_GSMAT
+	case SIG_GSM:
+		if (p->gsm.modul) {
+		    gsm_answer(p->gsm.modul);
+		}
+		break;
+#endif
 	case 0:
 		ast_mutex_unlock(&p->lock);
 		return 0;
@@ -7297,6 +7356,10 @@ static int pri_create_spanmap(int span, 
 
 #endif
 
+#ifdef HAVE_GSMAT
+static void *gsm_dchannel(void *vgsm);
+#endif
+
 static struct zt_pvt *mkintf(int channel, struct zt_chan_conf conf, struct zt_pri *pri, int reloading)
 {
 	/* Make a zt_pvt structure for this interface (or CRV if "pri" is specified) */
@@ -7525,6 +7588,37 @@ static struct zt_pvt *mkintf(int channel
 				tmp->prioffset = 0;
 			}
 #endif
+#ifdef HAVE_GSMAT
+		if (conf.chan.sig == SIG_GSM) {
+		    struct zt_bufferinfo bi;
+		    ast_mutex_init(&tmp->gsm.lock);
+		    strncpy(tmp->gsm.pin, gsm_modem_pin, sizeof(tmp->gsm.pin) - 1);
+		    strncpy(tmp->gsm.exten, gsm_modem_exten, sizeof(tmp->gsm.exten) - 1);
+		    tmp->gsm.available = 0;
+		    snprintf(fn, sizeof(fn), "%d", channel + 1);
+		    /* Open non-blocking */
+		    tmp->gsm.fd = zt_open(fn);
+		    bi.txbufpolicy = ZT_POLICY_IMMEDIATE;
+		    bi.rxbufpolicy = ZT_POLICY_IMMEDIATE;
+		    bi.numbufs = 16;
+		    bi.bufsize = 1024;
+		    if (ioctl(tmp->gsm.fd, ZT_SET_BUFINFO, &bi)) {
+			ast_log(LOG_ERROR, "Unable to set buffer info on channel '%s': %s\n", fn, strerror(errno));
+			return NULL;
+		    }
+		    tmp->gsm.pvt = tmp;
+		    tmp->gsm.span = tmp->span;
+		    tmp->gsm.modul = gsm_new(tmp->gsm.fd, 0, tmp->gsm.pin, tmp->span, tmp->channel);
+		    if (ioctl(tmp->subs[SUB_REAL].zfd, ZT_AUDIOMODE, tmp->channel)) {
+			ast_log(LOG_ERROR, "Unable to set clear mode on clear channel %d: %s\n", tmp->channel, strerror(errno));
+			destroy_zt_pvt(&tmp);
+			return NULL;
+		    }
+		    if (ast_pthread_create(&tmp->gsm.master, NULL, gsm_dchannel, &tmp->gsm)) {
+			zt_close(tmp->gsm.fd);
+		    }
+		}
+#endif
 		} else {
 			conf.chan.sig = tmp->sig;
 			conf.chan.radio = tmp->radio;
@@ -7814,6 +7908,12 @@ static inline int available(struct zt_pv
 				return 1;
 		}
 #endif
+#ifdef HAVE_GSMAT
+		if (p->gsm.modul) {
+		    return gsm_available(p->gsm.modul);
+		}
+
+#endif
 		if (!(p->radio || (p->oprmode < 0)))
 		{
 			if (!p->sig || (p->sig == SIG_FXSLS))
@@ -8171,6 +8271,235 @@ next:
 	return tmp;
 }
 
+#ifdef HAVE_GSMAT
+static int zt_reset_span(int span, int sleep) {
+	int ctl;
+	int res;
+
+	ctl = open("/dev/zap/ctl", O_RDWR);
+	if (ctl < 0) {
+		ast_log(LOG_WARNING, "Unable to open /dev/zap/ctl: %s\n", strerror(errno));
+		return -1;
+	}
+	ast_verbose(VERBOSE_PREFIX_2 "Shutting down span %d. Please wait...\n", span);
+	res = ioctl(ctl, ZT_SHUTDOWN, &span);
+	if (res) {
+		ast_log(LOG_WARNING, "error shutting down span %d\n", span);
+		return -1;
+	}
+	usleep(sleep * 1000);
+	ast_verbose(VERBOSE_PREFIX_2 "Starting up span %d. Please wait...\n", span);
+	res = ioctl(ctl, ZT_STARTUP, &span);
+	if (res) {
+		ast_log(LOG_WARNING, "error starting up span %d\n", span);
+		return -1;
+	}
+	ast_verbose(VERBOSE_PREFIX_2 "Reset of span %d completed.\n", span);
+	return 0;
+}
+
+
+static void handle_gsm_event(struct zt_gsm *gsm, gsm_event *e)
+{
+	struct ast_channel *c = NULL;
+	int law = ZT_LAW_ALAW;
+	int res = 0;
+
+	switch(e->e) {
+	case GSM_EVENT_DCHAN_UP:
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_3 "GSM Span %d registered to network!\n", gsm->span);
+		gsm->available = 1;
+		break;
+	case GSM_EVENT_DCHAN_DOWN:
+		if (option_verbose > 2)
+		    ast_verbose(VERBOSE_PREFIX_3 "GSM Span %d unregistered from network!\n", gsm->span);
+		gsm->available = 0;
+/*		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock); */
+		break;
+	case GSM_EVENT_RING:
+		ast_mutex_lock(&gsm->pvt->lock);
+		if (!ast_strlen_zero(e->ring.callingnum)) {
+		    strncpy(gsm->pvt->cid_num, e->ring.callingnum, sizeof(gsm->pvt->cid_num) - 1);
+		} else {
+		    strncpy(gsm->pvt->cid_name, "CID withheld", sizeof(gsm->pvt->cid_name));
+		}
+		if (!ast_strlen_zero(gsm->exten)) {
+		    strncpy(gsm->pvt->exten, gsm->exten, sizeof(gsm->pvt->exten) - 1);
+		} else {
+		    gsm->pvt->exten[0] = 's';
+		    gsm->pvt->exten[1] = '\0';
+		}
+		c = zt_new(gsm->pvt, AST_STATE_RING, 1, SUB_REAL, ZT_LAW_ALAW, AST_TRANS_CAP_SPEECH);
+		if (c) {
+		    if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Ring on channel %d (from %s to %s)\n", e->ring.channel, e->ring.callingnum, gsm->exten);
+		    gsm->pvt->owner = c;
+		    if (ioctl(gsm->pvt->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+			ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", gsm->pvt->channel, law);
+		    res = zt_setlaw(gsm->pvt->subs[SUB_REAL].zfd, law);
+		    res = set_actual_gain(gsm->pvt->subs[SUB_REAL].zfd, 0, gsm->pvt->rxgain, gsm->pvt->txgain, law);
+		    if (res < 0) {
+ 		        ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", gsm->pvt->channel);
+//		    } else {
+//		        ast_log(LOG_NOTICE, "tx gain %f rx gain %f law %d pvt->law %d\n", gsm->pvt->txgain, gsm->pvt->rxgain, law, gsm->pvt->law);
+		    }
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_HANGUP:
+		ast_verbose(VERBOSE_PREFIX_3 "Got hang up on channel %d\n", e->hangup.channel);
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->hangupcause = e->hangup.cause;
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_ERROR:
+		ast_log(LOG_WARNING, "Got error on channel\n");
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->alreadyhungup = 1;
+		if (gsm->pvt->owner) {
+		    gsm->pvt->owner->hangupcause = e->error.cause;
+		    gsm->pvt->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+		}
+		ast_mutex_unlock(&gsm->pvt->lock);
+		if (e->error.hard) {
+//		    gsm_poweroff(gsm->modul);
+		    zt_reset_span(gsm->span, 8000);
+//		    gsm_restart(gsm->modul, 10000);
+		} else {
+//		    gsm_poweroff(gsm->modul);
+		    zt_reset_span(gsm->span, 8000);
+//		    gsm_restart(gsm->modul, 10000);
+		}
+		break;
+	case GSM_EVENT_ALERTING:
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->subs[SUB_REAL].needringing =1;
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_ANSWER:
+		ast_mutex_lock(&gsm->pvt->lock);
+		gsm->pvt->dialing = 0;
+		gsm->pvt->subs[SUB_REAL].needanswer =1;
+		gsm->pvt->ignoredtmf = 0;
+		ast_mutex_unlock(&gsm->pvt->lock);
+		break;
+	case GSM_EVENT_PIN_REQUIRED:
+		gsm_send_pin(gsm->modul, gsm->pin);
+		break;
+	case GSM_EVENT_SM_RECEIVED:
+		ast_verbose(VERBOSE_PREFIX_3 "SMS from %s received on span %d. (Text: %s) (PDU: %s)\n", e->sm_received.sender, gsm->span, e->sm_received.text, e->sm_received.pdu);
+		manager_event(EVENT_FLAG_CALL, "Message received",
+			"Span: %d\r\n"
+		  	"Sender: %s\r\n"
+		  	"SMSC: %s\r\n"
+		      	"Length: %d\r\n"
+		  	"Text: %s\r\n"
+		  	"PDU: %s\r\n",
+			gsm->span, 
+			e->sm_received.sender,
+			e->sm_received.smsc,
+			e->sm_received.len,
+			e->sm_received.text,
+			e->sm_received.pdu);
+		break;
+	default:
+		ast_log(LOG_WARNING,"!! Unknown GSM event %d !!\n", e->e);
+	}
+}
+
+static void *gsm_dchannel(void *vgsm)
+{
+	struct zt_gsm *gsm = vgsm;
+	gsm_event *e;
+	struct timeval tv = {0,0}, *next;
+	fd_set rfds, efds;
+	int res,x;
+
+	if (!gsm) return NULL;
+
+	if (!gsm->modul) {
+		fprintf(stderr, "No gsm_mod\n");
+		return NULL;
+	}
+	gsm_set_debug(gsm->modul, GSM_DEBUG_NONE);
+	for (;;) {
+		
+		/* Run the D-Channel */
+		FD_ZERO(&rfds);
+		FD_ZERO(&efds);
+		FD_SET(gsm->fd, &rfds);
+		FD_SET(gsm->fd, &efds);
+
+		if ((next = gsm_schedule_next(gsm->modul))) {
+			gettimeofday(&tv, NULL);
+			tv.tv_sec = next->tv_sec - tv.tv_sec;
+			tv.tv_usec = next->tv_usec - tv.tv_usec;
+			if (tv.tv_usec < 0) {
+				tv.tv_usec += 1000000;
+				tv.tv_sec -= 1;
+			}
+			if (tv.tv_sec < 0) {
+				tv.tv_sec = 0;
+				tv.tv_usec = 0;
+			}
+		}
+		res = select(gsm->fd + 1, &rfds, NULL, &efds, next ? &tv : NULL);
+		e = NULL;
+
+		ast_mutex_lock(&gsm->lock);
+		if (!res) {
+			e = gsm_schedule_run(gsm->modul);
+		} else if (res > 0) {
+			e = gsm_check_event(gsm->modul, 1);
+		} else if (errno == ELAST) {
+			res = ioctl(gsm->fd, ZT_GETEVENT, &x);
+			printf("Got Zaptel event: %d\n", x);
+		} else if (errno != EINTR) 
+			fprintf(stderr, "Error (%d) on select: %s\n", ELAST, strerror(errno));
+
+		if (!e) {
+		    e = gsm_check_event(gsm->modul, 0);
+		}
+
+		if (e) {
+			handle_gsm_event(gsm, e);
+		}
+		ast_mutex_unlock(&gsm->lock);
+
+		res = ioctl(gsm->fd, ZT_GETEVENT, &x);
+
+		if (!res && x) {
+			switch (x) {
+			    case ZT_EVENT_NOALARM:
+				ast_log(LOG_NOTICE, "Alarm cleared on span %d\n", gsm->span);
+				usleep(1000);
+				gsm_restart(gsm->modul, 10000);
+			    break;
+			    case ZT_EVENT_ALARM:
+				ast_log(LOG_NOTICE, "Alarm detected on span %d\n", gsm->span);
+			    break;
+			    default:
+				fprintf(stderr, "Got event on GSM interface: %d\n", x);
+			}
+		}
+
+
+	}
+	return NULL;
+}
+
+#endif
+
 #ifdef HAVE_PRI
 static struct zt_pvt *pri_find_crv(struct zt_pri *pri, int crv)
 {
@@ -8450,6 +8779,18 @@ static void zt_pri_error(char *s, int sp
 	ast_log(LOG_WARNING, "%d %s", span, s);
 }
 
+#ifdef HAVE_GSMAT
+static void zt_gsm_message(char *s, int channel)
+{
+	ast_verbose("GSM %d: %s", channel, s);
+}
+
+static void zt_gsm_error(char *s, int channel)
+{
+	ast_log(LOG_WARNING, "GSM %d: %s", channel, s);
+}
+#endif
+
 static int pri_check_restart(struct zt_pri *pri)
 {
 	if ((pri->nodetype != PRI_NETWORK) && (pri->nodetype != PRI_CPE)) {
@@ -10887,6 +11228,243 @@ static int app_zapInband(struct ast_chan
 
 #endif /* HAVE_PRI */
 
+#ifdef HAVE_GSMAT
+static int handle_zap_reset_span(int fd, int argc, char *argv[])
+{
+	int span;
+	int sleep = 5000;
+	if (argc < 4)
+		return RESULT_SHOWUSAGE;
+	span = atoi(argv[3]);
+	if ((span < 1) || (span > NUM_SPANS)) {
+		ast_cli(fd, "Invalid span '%s'.  Should be a number from %d to %d\n", argv[3], 1, NUM_SPANS);
+		return RESULT_SUCCESS;
+	}
+	if (zt_reset_span(span, sleep)) {
+	    return RESULT_FAILURE;
+	}
+	return RESULT_SUCCESS;
+}
+
+static int handle_gsm_debug_helper(int fd, int channel, int debug)
+{
+/* gsm debug channel <channel> */
+	struct zt_pvt *pvt = NULL;
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %d.  Should be a number.\n", channel);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		ast_mutex_lock(&pvt->lock);
+		gsm_set_debug(pvt->gsm.modul, debug);
+		ast_mutex_unlock(&pvt->lock);
+		ast_cli(fd, "%s debugging on channel %d\n", debug ? "Enabled":"Disabled", channel);
+		return RESULT_SUCCESS;
+	    }
+	    pvt = pvt->next;
+	}
+	
+	ast_cli(fd, "No GSM running on channel %d\n", channel);
+	return RESULT_SUCCESS;
+}
+
+
+
+static int handle_gsm_debug(int fd, int argc, char *argv[])
+{
+/* gsm debug channel <channel> */
+ int channel;
+ if (argc < 4) {
+ 	return RESULT_SHOWUSAGE;
+ }
+ channel = atoi(argv[3]);
+ return handle_gsm_debug_helper(fd, channel, GSM_DEBUG_AT);
+}
+
+static int handle_gsm_no_debug(int fd, int argc, char *argv[])
+{
+/* gsm no debug channel <channel> */
+ int channel;
+ if (argc < 5) {
+ 	return RESULT_SHOWUSAGE;
+ }
+ channel = atoi(argv[4]);
+ return handle_gsm_debug_helper(fd, channel, GSM_DEBUG_NONE);
+}
+
+static char zap_reset_help[] = 
+	"Usage: zap reset span <span>\n"
+	"       Reset/Restart a zaptel span\n";
+
+static char gsm_debug_help[] = 
+	"Usage: gsm debug channel <channel>\n"
+	"       Enables debugging on a given GSM channel\n";
+	
+static char gsm_no_debug_help[] = 
+	"Usage: gsm no debug channel <channel>\n"
+	"       Disables debugging on a given GSM channel\n";
+
+static struct ast_cli_entry zap_gsm_cli[] = {
+	{ { "zap", "reset", "span", NULL }, handle_zap_reset_span,
+	  "Restart a zaptel span", zap_reset_help, complete_span_4 },
+	{ { "gsm", "debug", "channel", NULL }, handle_gsm_debug,
+	  "Enables GSM debugging on a channel", gsm_debug_help },
+	{ { "gsm", "no", "debug", "channel", NULL }, handle_gsm_no_debug,
+	  "Disables GSM debugging on a channel", gsm_no_debug_help},
+};
+
+
+
+static char gsm_send_pdu_help[] = 
+	"Usage: gsm send pdu <channel> <pdu>\n"
+	"       Sends a PDU on a GSM channel\n";
+
+
+
+static int handle_gsm_send_pdu(int fd, int argc, char *argv[])
+{
+/* gsm send sms <channel> <destination> <message> */
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 5) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_sms_send_pdu(pvt->gsm.modul, argv[4]);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static struct ast_cli_entry gsm_send_pdu = {
+	{ "gsm", "send", "pdu", NULL }, handle_gsm_send_pdu, "Sends a SM on a GSM channel", gsm_send_pdu_help, complete_span_4 };
+
+
+static char gsm_send_sms_help[] = 
+	"Usage: gsm send sms <channel> <destination> <message>\n"
+	"       Sends a SM on a GSM channel\n";
+
+
+static int handle_gsm_send_sms(int fd, int argc, char *argv[])
+{
+/* gsm send sms <channel> <destination> <message> */
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 6) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_sms_send_text(pvt->gsm.modul, argv[4], argv[5]);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static int zt_gsm_sendtext(struct ast_channel *chan, const char * dest, const char *text, int ispdu) {
+     struct zt_pvt *pvt = NULL;
+     char *c = NULL;
+     pvt = chan->tech_pvt;
+     
+     if (!pvt) return -1;
+     
+     /* parse dialstring */
+     c = strrchr(dest, '/');
+     if (c)
+ 	c++;
+     else
+ 	c = (char *)dest;
+ 
+     ast_mutex_lock(&pvt->lock);
+ 	if (ispdu) {
+     	    gsm_sms_send_pdu(pvt->gsm.modul, (char *)text);
+ 	} else {
+     	    gsm_sms_send_text(pvt->gsm.modul, c, (char *)text);
+ 	}
+     ast_mutex_unlock(&pvt->lock);
+     gsm_wait(pvt->gsm.modul);
+     return 0;
+}
+ 
+static struct ast_cli_entry gsm_send_sms = {
+	{ "gsm", "send", "sms", NULL }, handle_gsm_send_sms, "Sends a SM on a GSM channel", gsm_send_sms_help, complete_span_4 };
+
+static char gsm_show_status_help[] = 
+	"Usage: gsm show status <channel>>\n"
+	"       Displays status information about the GSM channel.\n";
+
+
+static int handle_gsm_show_status(int fd, int argc, char *argv[])
+{
+	int channel;
+	struct zt_pvt *pvt = NULL;
+	if (argc < 4) {
+		return RESULT_SHOWUSAGE;
+	}
+	channel = atoi(argv[3]);
+	if (channel < 1) {
+		ast_cli(fd, "Invalid channel %s.  Should be a number.\n", argv[3]);
+		return RESULT_SUCCESS;
+	}
+	pvt = iflist;
+	while (pvt) {
+	    if (pvt->channel == channel) {
+		if (pvt->owner) {
+		    ast_cli(fd, "Channel in use.\n");
+		    return RESULT_FAILURE;
+		} else {
+		    ast_mutex_lock(&pvt->lock);
+		    gsm_request_status(pvt->gsm.modul);
+		    ast_mutex_unlock(&pvt->lock);
+		    return RESULT_SUCCESS;
+		}
+	    }
+	    pvt = pvt->next;
+	}
+	
+	return RESULT_SUCCESS;
+}
+
+static struct ast_cli_entry gsm_show_status = {
+	{ "gsm", "show", "status", NULL }, handle_gsm_show_status, "Displays status information about the GSM channel.", gsm_show_status_help, complete_span_4 };
+
+#endif /* HAVE_GSMAT */
+
 static int app_zapEC(struct ast_channel *chan, void *data)
 {
  int res=-1;
@@ -11508,6 +12086,12 @@ static int __unload_module(void)
 	ast_unregister_application(zapCD_app);
 	ast_unregister_application(zapInband_app);
 #endif
+#ifdef HAVE_GSMAT
+	ast_cli_unregister_multiple(zap_gsm_cli, sizeof(zap_gsm_cli) / sizeof(zap_gsm_cli[0]));
+	ast_cli_unregister(&gsm_send_sms);
+	ast_cli_unregister(&gsm_send_pdu);
+	ast_cli_unregister(&gsm_show_status);
+#endif
 	ast_cli_unregister_multiple(zap_cli, sizeof(zap_cli) / sizeof(struct ast_cli_entry));
 	ast_unregister_application(zapEC_app);
 	ast_manager_unregister( "ZapDialOffhook" );
@@ -12028,6 +12612,11 @@ static int process_zap(struct zt_chan_co
  					confp->chan.radio = 0;
  					confp->pri.nodetype = BRI_CPE;
 #endif
+#ifdef HAVE_GSMAT
+				} else if (!strcasecmp(v->value, "gsm")) {
+					confp->chan.sig = SIG_GSM;
+					confp->chan.radio = 0;
+#endif				
 				} else {
 					ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
 				}
@@ -12170,6 +12759,10 @@ static int process_zap(struct zt_chan_co
   				ast_copy_string(confp->pri.nocid, v->value, sizeof(confp->pri.nocid));
   			} else if (!strcasecmp(v->name, "withheldcid")) {
   				ast_copy_string(confp->pri.withheldcid, v->value, sizeof(confp->pri.withheldcid));
+			} else if (!strcasecmp(v->name, "pin")) {
+				ast_copy_string(gsm_modem_pin, v->value, sizeof(gsm_modem_pin) - 1);
+			} else if (!strcasecmp(v->name, "exten")) {
+				ast_copy_string(gsm_modem_exten, v->value, sizeof(gsm_modem_exten) - 1);
 			} else if (!strcasecmp(v->name, "resetinterval")) {
 				if (!strcasecmp(v->value, "never"))
 					confp->pri.resetinterval = -1;
@@ -12524,6 +13117,10 @@ static int load_module(void)
 	ast_register_application(zap_send_keypad_facility_app, zap_send_keypad_facility_exec,
 			zap_send_keypad_facility_synopsis, zap_send_keypad_facility_descrip);
 #endif
+#ifdef HAVE_GSMAT
+	gsm_set_error(zt_gsm_error);
+	gsm_set_message(zt_gsm_message);
+#endif
 	res = setup_zap(0);
 	/* Make sure we can register our Zap channel type */
 	if (res)
@@ -12542,6 +13139,12 @@ static int load_module(void)
 #endif	
 	ast_register_application(zapEC_app, app_zapEC, zapEC_synopsis, zapEC_tdesc);
 	ast_cli_register_multiple(zap_cli, sizeof(zap_cli) / sizeof(struct ast_cli_entry));
+#ifdef HAVE_GSMAT
+	ast_cli_register(&gsm_send_sms);
+	ast_cli_register(&gsm_send_pdu);
+	ast_cli_register(&gsm_show_status);
+	ast_cli_register_multiple(zap_gsm_cli, sizeof(zap_gsm_cli) / sizeof(zap_gsm_cli[0]));
+#endif
 	
 	memset(round_robin, 0, sizeof(round_robin));
 	ast_manager_register( "ZapTransfer", 0, action_transfer, "Transfer Zap Channel" );
@@ -12555,7 +13158,66 @@ static int load_module(void)
 	return res;
 }
 
-static int zt_sendtext(struct ast_channel *c, const char *text)
+#ifdef HAVE_PRI
+static int zt_tdd_sendtext(struct ast_channel *c, const char *text);
+
+static int zt_pri_sendtext(struct ast_channel *c, const char *text) {
+ struct zt_pvt *p = c->tech_pvt;
+ if (!p) return -1;
+ if (!p->pri) return -1;
+	    if (strlen(text)) {
+		if (p->pri) {		
+		    if (!pri_grab(p, p->pri)) {
+		//	ast_log(LOG_NOTICE, "Sending Display IE  '%s'\n", text);
+			pri_information_display(p->pri->pri,p->call,(char *)text);
+			pri_rel(p->pri);
+	    	    } else ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
+		}
+	    }
+ return 0;
+}
+#endif
+
+static int zt_sendtext(struct ast_channel *c, const char *text) {
+ struct zt_pvt *p = c->tech_pvt;
+ if (!p) return -1;
+ if (p->sig == SIG_PRI) {
+#ifdef HAVE_PRI
+	return zt_pri_sendtext(c, text);
+#endif
+ } else if (p->sig == SIG_GSM) {
+ } else {
+	return zt_tdd_sendtext(c, text);
+ }
+ return -1;
+}
+
+static int zt_sendmessage(struct ast_channel *c, const char *dest, const char *text, int ispdu) {
+ struct zt_pvt *p = c->tech_pvt;
+ if (!p) return -1;
+ if (p->sig == SIG_PRI) {
+#ifdef HAVE_PRI
+	if (ispdu) {
+	    ast_log(LOG_WARNING, "Dont know how to send PDU on ZAP ISDN channel\n");
+	    return -1;
+	}
+	return zt_pri_sendtext(c, text);
+#endif
+ } else if (p->sig == SIG_GSM) {
+#ifdef HAVE_GSMAT
+     return zt_gsm_sendtext(c, dest, text, ispdu);
+#endif
+ } else {
+	if (ispdu) {
+	    ast_log(LOG_WARNING, "Dont know how to send PDU on ZAP channel\n");
+	    return -1;
+	}
+	return zt_tdd_sendtext(c, text);
+ }
+ return -1;
+}
+
+static int zt_tdd_sendtext(struct ast_channel *c, const char *text)
 {
 #define	END_SILENCE_LEN 400
 #define	HEADER_MS 50
--- a/configure.ac
+++ b/configure.ac
@@ -178,6 +178,7 @@ AST_EXT_LIB_SETUP([CAP], [POSIX 1.e capa
 AST_EXT_LIB_SETUP([CURSES], [curses], [curses])
 AST_EXT_LIB_SETUP([GNUTLS], [GNU TLS support (used for iksemel only)], [gnutls])
 AST_EXT_LIB_SETUP([GSM], [GSM], [gsm], [, or 'internal'])
+AST_EXT_LIB_SETUP([GSMAT], [GSMAT], [GSM AT command signalling], [gsmat])
 AST_EXT_LIB_SETUP([IKSEMEL], [Iksemel Jabber Library], [iksemel])
 AST_EXT_LIB_SETUP([IMAP_TK], [UW IMAP Toolkit], [imap])
 AST_EXT_LIB_SETUP([ISDNNET], [ISDN4Linux Library], [isdnnet])
--- a/configure
+++ b/configure
@@ -25979,6 +25979,188 @@ echo "$as_me: *** without explicitly spe
    fi
 fi
 
+{ echo "$as_me:$LINENO: checking for ${GSMAT_DIR}/include/libgsmat.h" >&5
+echo $ECHO_N "checking for ${GSMAT_DIR}/include/libgsmat.h... $ECHO_C" >&6; }
+if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+ac_res=`eval echo '${'$as_ac_Header'}'`
+	       { echo "$as_me:$LINENO: result: $ac_res" >&5
+echo "${ECHO_T}$ac_res" >&6; }
+
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  GSMAT_HEADER_FOUND=1
+else
+  GSMAT_HEADER_FOUND=0
+fi
+
+
+
+   if test "${GSMAT_HEADER_FOUND}" = "yes"; then
+      GSMAT_LIB="-lgsmat "
+      GSMAT_HEADER_FOUND="1"
+      if test "x${GSMAT_DIR}" != "x"; then
+         GSMAT_LIB="${pbxlibdir} ${GSMAT_LIB}"
+	 GSMAT_INCLUDE="-I${GSMAT_DIR}/include"
+	 fi
+	 CPPFLAGS="${saved_cppflags}"
+      else
+	 if test "xlibgsmat.h" != "x" ; then
+            if test "${ac_cv_header_libpri_h+set}" = set; then
+  { echo "$as_me:$LINENO: checking for libgsmat.h" >&5
+echo $ECHO_N "checking for libgsmat.h... $ECHO_C" >&6; }
+if test "${ac_cv_header_libgsmat_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_libgsmat_h" >&5
+echo "${ECHO_T}$ac_cv_header_libgsmat_h" >&6; }
+else
+  # Is the header compilable?
+{ echo "$as_me:$LINENO: checking libgsmat.h usability" >&5
+echo $ECHO_N "checking libgsmat.h usability... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <libgsmat.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_header_compiler=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ echo "$as_me:$LINENO: checking libgsmat.h presence" >&5
+echo $ECHO_N "checking libgsmat.h presence... $ECHO_C" >&6; }
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libgsmat.h>
+_ACEOF
+if { (ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+
+rm -f conftest.err conftest.$ac_ext
+{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: libgsmat.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: libgsmat.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: libgsmat.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: libgsmat.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: libgsmat.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: libgsmat.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: libgsmat.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: libgsmat.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: libgsmat.h: in the future, the compiler will take precedence" >&2;}
+
+    ;;
+esac
+{ echo "$as_me:$LINENO: checking for libgsmat.h" >&5
+echo $ECHO_N "checking for libgsmat.h... $ECHO_C" >&6; }
+if test "${ac_cv_header_libgsmat_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_libgsmat_h=$ac_header_preproc
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_header_libgsmat_h" >&5
+echo "${ECHO_T}$ac_cv_header_libgsmat_h" >&6; }
+
+fi
+
+
+	 fi
+      fi
+      if test "x${GSMAT_HEADER_FOUND}" = "x0" ; then
+         if test -n "${GSMAT_MANDATORY}" ;
+         then
+            { echo "$as_me:$LINENO: ***" >&5
+echo "$as_me: ***" >&6;}
+            { echo "$as_me:$LINENO: *** It appears that you do not have the GSMAT development package installed." >&5
+echo "$as_me: *** It appears that you do not have the GSMAT development package installed." >&6;}
+            { echo "$as_me:$LINENO: *** Please install it to include ${GSMAT_DESCRIP} support, or re-run configure" >&5
+echo "$as_me: *** Please install it to include ${GSMAT_DESCRIP} support, or re-run configure" >&6;}
+            { echo "$as_me:$LINENO: *** without explicitly specifying --with-${GSMAT_OPTION}" >&5
+echo "$as_me: *** without explicitly specifying --with-${GSMAT_OPTION}" >&6;}
+            exit 1
+         fi
+         GSMAT_LIB=""
+         GSMAT_INCLUDE=""
+         PBX_GSMAT=0
+      else
+         PBX_GSMAT=1
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_GSMAT 1
+_ACEOF
+
+fi
 
 if test "${USE_PWLIB}" != "no"; then
 	if test -n "${PWLIB_DIR}"; then
