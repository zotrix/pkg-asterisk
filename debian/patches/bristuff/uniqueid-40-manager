--- a/main/manager.c
+++ b/main/manager.c
@@ -87,6 +87,8 @@ struct fast_originate_helper {
 	char idtext[AST_MAX_EXTENSION];
 	char account[AST_MAX_ACCOUNT_CODE];
 	int priority;
+	int callingpres;
+	char uniqueid[64];
 	struct ast_variable *vars;
 };
 
@@ -1416,11 +1418,20 @@ static int action_hangup(struct mansessi
 {
 	struct ast_channel *c = NULL;
 	const char *name = astman_get_header(m, "Channel");
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "No channel specified");
+	const char *uniqueid = astman_get_header(m, "Uniqueid");
+
+	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+		astman_send_error(s, m, "No channel or uniqueid specified");
 		return 0;
 	}
-	c = ast_get_channel_by_name_locked(name);
+
+	if (!ast_strlen_zero(uniqueid)) {
+		c = ast_get_channel_by_uniqueid_locked(uniqueid);
+	} else {
+	    if (!ast_strlen_zero(name))
+		c = ast_get_channel_by_name_locked(name);
+	}
+
 	if (!c) {
 		astman_send_error(s, m, "No such channel");
 		return 0;
@@ -1671,12 +1682,18 @@ static int action_redirect(struct manses
 	const char *exten = astman_get_header(m, "Exten");
 	const char *context = astman_get_header(m, "Context");
 	const char *priority = astman_get_header(m, "Priority");
+ 	const char *uniqueid = astman_get_header(m, "Uniqueid");
+ 	const char *uniqueid2 = astman_get_header(m, "ExtraUniqueid");
+	const char *exten2 = astman_get_header(m, "ExtraExten");
+	const char *context2 = astman_get_header(m, "ExtraContext");
+	const char *priority2 = astman_get_header(m, "ExtraPriority");
 	struct ast_channel *chan, *chan2 = NULL;
 	int pi = 0;
+	int pi2 = 0;
 	int res;
 
-	if (ast_strlen_zero(name)) {
-		astman_send_error(s, m, "Channel not specified");
+ 	if (ast_strlen_zero(name) && ast_strlen_zero(uniqueid)) {
+ 		astman_send_error(s, m, "Channel or Uniqueid not specified");
 		return 0;
 	}
 	if (!ast_strlen_zero(priority) && (sscanf(priority, "%d", &pi) != 1)) {
@@ -1685,8 +1702,18 @@ static int action_redirect(struct manses
 			return 0;
 		}
 	}
+	if (!ast_strlen_zero(priority2) && (sscanf(priority2, "%d", &pi2) != 1)) {
+		if ((pi = ast_findlabel_extension(NULL, context2, exten2, priority2, NULL)) < 1) {
+			astman_send_error(s, m, "Invalid extra priority\n");
+			return 0;
+		}
+	}
 	/* XXX watch out, possible deadlock!!! */
-	chan = ast_get_channel_by_name_locked(name);
+ 	if (!ast_strlen_zero(uniqueid)) {
+ 	    chan = ast_get_channel_by_uniqueid_locked(uniqueid);
+ 	} else {
+ 	    chan = ast_get_channel_by_name_locked(name);
+ 	}
 	if (!chan) {
 		char buf[BUFSIZ];
 		snprintf(buf, sizeof(buf), "Channel does not exist: %s", name);
@@ -1698,8 +1725,11 @@ static int action_redirect(struct manses
 		ast_channel_unlock(chan);
 		return 0;
 	}
-	if (!ast_strlen_zero(name2))
+ 	if (!ast_strlen_zero(uniqueid2)) {
+ 	    chan2 = ast_get_channel_by_uniqueid_locked(uniqueid2);
+ 	} else if (!ast_strlen_zero(name2)) {
 		chan2 = ast_get_channel_by_name_locked(name2);
+	}
 	if (chan2 && ast_check_hangup(chan2)) {
 		astman_send_error(s, m, "Redirect failed, extra channel not up.\n");
 		ast_channel_unlock(chan);
@@ -1708,9 +1738,9 @@ static int action_redirect(struct manses
 	}
 	res = ast_async_goto(chan, context, exten, pi);
 	if (!res) {
-		if (!ast_strlen_zero(name2)) {
+		if ((!ast_strlen_zero(name2)) || (!ast_strlen_zero(uniqueid2))){
 			if (chan2)
-				res = ast_async_goto(chan2, context, exten, pi);
+				res = ast_async_goto(chan2, context2, exten2, pi2);
 			else
 				res = -1;
 			if (!res)
@@ -1789,15 +1819,15 @@ static void *fast_originate(void *data)
 	char requested_channel[AST_CHANNEL_NAME];
 
 	if (!ast_strlen_zero(in->app)) {
-		res = ast_pbx_outgoing_app(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, 
+		res = ast_pbx_outgoing_app_uniqueid(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->app, in->appdata, &reason, 1, in->callingpres,
 			S_OR(in->cid_num, NULL), 
 			S_OR(in->cid_name, NULL),
-			in->vars, in->account, &chan);
+			in->vars, in->account, &chan, in->uniqueid);
 	} else {
-		res = ast_pbx_outgoing_exten(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, 
+		res = ast_pbx_outgoing_exten_uniqueid(in->tech, AST_FORMAT_SLINEAR, in->data, in->timeout, in->context, in->exten, in->priority, &reason, 1, in->callingpres,
 			S_OR(in->cid_num, NULL), 
 			S_OR(in->cid_name, NULL),
-			in->vars, in->account, &chan);
+			in->vars, in->account, &chan, in->uniqueid);
 	}
 
 	if (!chan)
@@ -1857,6 +1887,7 @@ static int action_originate(struct manse
 	const char *appdata = astman_get_header(m, "Data");
 	const char *async = astman_get_header(m, "Async");
 	const char *id = astman_get_header(m, "ActionID");
+ 	const char *callingpres = astman_get_header(m, "CallingPres");
 	struct ast_variable *vars = astman_get_variables(m);
 	char *tech, *data;
 	char *l = NULL, *n = NULL;
@@ -1866,6 +1897,9 @@ static int action_originate(struct manse
 	int reason = 0;
 	char tmp[256];
 	char tmp2[256];
+ 	char *uniqueid;
+ 	int cpresi = 0;
+ 	char idText[256] = "";
 	
 	pthread_t th;
 	pthread_attr_t attr;
@@ -1883,6 +1917,10 @@ static int action_originate(struct manse
 		astman_send_error(s, m, "Invalid timeout\n");
 		return 0;
 	}
+	if (!ast_strlen_zero(callingpres) && (sscanf(callingpres, "%d", &cpresi) != 1)) {
+		astman_send_error(s, m, "Invalid CallingPres\n");
+		return 0;
+	}
 	ast_copy_string(tmp, name, sizeof(tmp));
 	tech = tmp;
 	data = strchr(tmp, '/');
@@ -1902,6 +1940,7 @@ static int action_originate(struct manse
 		if (ast_strlen_zero(l))
 			l = NULL;
 	}
+ 	uniqueid = ast_alloc_uniqueid();
 	if (ast_true(async)) {
 		struct fast_originate_helper *fast = ast_calloc(1, sizeof(*fast));
 		if (!fast) {
@@ -1921,8 +1960,10 @@ static int action_originate(struct manse
 			ast_copy_string(fast->context, context, sizeof(fast->context));
 			ast_copy_string(fast->exten, exten, sizeof(fast->exten));
 			ast_copy_string(fast->account, account, sizeof(fast->account));
+			ast_copy_string(fast->uniqueid, uniqueid, sizeof(fast->uniqueid));
 			fast->timeout = to;
 			fast->priority = pi;
+			fast->callingpres = cpresi;
 			pthread_attr_init(&attr);
 			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 			if (ast_pthread_create(&th, &attr, fast_originate, fast)) {
@@ -1933,19 +1974,28 @@ static int action_originate(struct manse
 			pthread_attr_destroy(&attr);
 		}
 	} else if (!ast_strlen_zero(app)) {
-        	res = ast_pbx_outgoing_app(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 1, l, n, vars, account, NULL);
+     		res = ast_pbx_outgoing_app_uniqueid(tech, AST_FORMAT_SLINEAR, data, to, app, appdata, &reason, 1, cpresi, l, n, vars, account, NULL, uniqueid);
     	} else {
 		if (exten && context && pi)
-	        	res = ast_pbx_outgoing_exten(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 1, l, n, vars, account, NULL);
+	        	res = ast_pbx_outgoing_exten_uniqueid(tech, AST_FORMAT_SLINEAR, data, to, context, exten, pi, &reason, 1, cpresi, l, n, vars, account, NULL, uniqueid);
 		else {
 			astman_send_error(s, m, "Originate with 'Exten' requires 'Context' and 'Priority'");
 			return 0;
 		}
 	}   
-	if (!res)
-		astman_send_ack(s, m, "Originate successfully queued");
-	else
+ 	if (!res) {
+ 	        if (id && !ast_strlen_zero(id)) {
+       		    snprintf(idText,256,"ActionID: %s\r\n",id);
+  		}
+ 		ast_cli(s->fd, "Response: Success\r\n"
+ 				    "%s"
+ 				   "Message: Originate successfully queued\r\n"
+ 				   "Uniqueid: %s\r\n"
+ 				   "\r\n",
+ 				    idText, uniqueid);
+ 	} else {
 		astman_send_error(s, m, "Originate failed");
+	}
 	return 0;
 }
 
--- a/include/asterisk/channel.h
+++ b/include/asterisk/channel.h
@@ -89,6 +89,9 @@
 
 #include "asterisk/abstract_jb.h"
 
+/* Max length of the uniqueid */
+#define AST_MAX_UNIQUEID 64
+
 #include <unistd.h>
 #ifdef POLLCOMPAT 
 #include "asterisk/poll-compat.h"
@@ -1039,6 +1042,8 @@ int ast_waitfordigit_full(struct ast_cha
 int ast_readstring(struct ast_channel *c, char *s, int len, int timeout, int rtimeout, char *enders);
 int ast_readstring_full(struct ast_channel *c, char *s, int len, int timeout, int rtimeout, char *enders, int audiofd, int ctrlfd);
 
+char *ast_alloc_uniqueid(void);
+
 /*! \brief Report DTMF on channel 0 */
 #define AST_BRIDGE_DTMF_CHANNEL_0		(1 << 0)		
 /*! \brief Report DTMF on channel 1 */
--- a/main/channel.c
+++ b/main/channel.c
@@ -706,6 +706,15 @@ static const struct ast_channel_tech nul
 	.description = "Null channel (should not see this)",
 };
 
+/*! \brief Create a uniqueid */
+char *ast_alloc_uniqueid(void) {
+   char *uniqueid;
+   uniqueid = malloc(64);
+   if (!uniqueid) return NULL;
+   snprintf(uniqueid, 63, "%s-%d-%li.%d", ast_config_AST_SYSTEM_NAME, ast_mainpid, (long)time(NULL), ast_atomic_fetchadd_int(&uniqueint, 1));
+   return uniqueid;
+}
+
 /*! \brief Create a new channel structure */
 struct ast_channel *ast_channel_alloc(int needqueue, int state, const char *cid_num, const char *cid_name, const char *acctcode, const char *exten, const char *context, const int amaflag, const char *name_fmt, ...)
 {
