Index: asterisk-1.4.14~dfsg/channels/chan_zap.c
===================================================================
--- asterisk-1.4.14~dfsg.orig/channels/chan_zap.c	2007-11-19 12:31:59.000000000 +0200
+++ asterisk-1.4.14~dfsg/channels/chan_zap.c	2007-11-19 12:48:21.000000000 +0200
@@ -103,6 +107,8 @@
 #include "asterisk/abstract_jb.h"
 #include "asterisk/smdi.h"
 #include "asterisk/astobj.h"
+#include "asterisk/devicestate.h"
+
 #define SMDI_MD_WAIT_TIMEOUT 1500 /* 1.5 seconds */
 
 /*! Global jitterbuffer configuration - by default, jb is disabled */
@@ -702,6 +743,7 @@
 	.fixup = zt_fixup,
 	.setoption = zt_setoption,
 	.func_channel_read = zt_func_read,
+/*	.devicestate = zt_devicestate, */
 };
 
 #ifdef HAVE_PRI
@@ -760,6 +809,112 @@
 #define CANBUSYDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 #define CANPROGRESSDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 
+static int zt_devicestate(void *data)
+{
+	int groupmatch = 0;
+	int channelmatch = 0;
+	struct zt_pvt *p;
+	char *dest=NULL;
+	int x;
+	char *s;
+	char opt=0;
+	int res, y=0;
+	struct zt_pvt *exit, *start, *end;
+	ast_mutex_t *lock;
+
+//	ast_log(LOG_NOTICE, "data = %s\n", (char *)data);
+	return AST_DEVICE_UNKNOWN;
+	
+	/* Assume we're locking the iflock */
+	lock = &iflock;
+	start = iflist;
+	end = ifend;
+
+	if (data) {
+		dest = ast_strdupa((char *)data);
+	} else {
+		ast_log(LOG_WARNING, "Channel requested with no data\n");
+		return AST_DEVICE_INVALID;
+	}
+	if (toupper(dest[0]) == 'G' || toupper(dest[0])=='R') {
+		/* Retrieve the group number */
+		char *stringp=NULL;
+		stringp=dest + 1;
+		s = strsep(&stringp, "/");
+		if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine group for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		}
+		groupmatch = 1 << x;
+	} else {
+		char *stringp=NULL;
+		stringp=dest;
+		s = strsep(&stringp, "/");
+		p = iflist;
+		if (!strcasecmp(s, "pseudo")) {
+			/* Special case for pseudo */
+			x = CHAN_PSEUDO;
+			channelmatch = x;
+			/* bail out */
+			return AST_DEVICE_INVALID;
+		} 
+
+		else if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine channel for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		} else {
+			channelmatch = x;
+			ast_log(LOG_NOTICE, "channelmatch = %d\n", channelmatch);
+		}
+	}
+	/* Search for an unowned channel */
+	if (ast_mutex_lock(lock)) {
+		ast_log(LOG_ERROR, "Unable to lock interface list???\n");
+		return AST_DEVICE_INVALID;
+	}
+	p = iflist;
+	exit = iflist;
+	res = AST_DEVICE_INVALID; /* start pessimistic */
+	while(p) {
+		if (p) {
+		    ast_mutex_lock(&p->lock);
+		    if ((groupmatch && ((p->group & groupmatch) != 0)) || (channelmatch && (p->channel == channelmatch))) {
+#ifdef ZAPATA_PRI
+			if (p->pri) {
+			    for(d=0;d<NUM_DCHANS;d++) {
+				if (p->pri->dchanavail[d] & DCHAN_UP) {
+			    	    res = AST_DEVICE_UNKNOWN;
+				}
+			    }
+			}
+#endif
+			if ((!ast_strlen_zero(p->cid_num) && (strncasecmp(p->cid_num, dest, strlen(p->cid_num)))) || (!ast_strlen_zero(p->dnid) && (strncasecmp(p->dnid, dest, strlen(p->dnid))))) {
+			    res = AST_DEVICE_UNKNOWN;
+			    if (p->owner) {
+				    if ((p->owner->_state == AST_STATE_RINGING) && (p->outgoing)) {
+			    		res = AST_DEVICE_RINGING;
+				    }
+				    if (((p->owner->_state == AST_STATE_RINGING) && (!p->outgoing)) || (p->owner->_state == AST_STATE_UP) || (p->owner->_state == AST_STATE_DIALING) || (p->owner->_state == AST_STATE_RESERVED) || (p->owner->_state == AST_STATE_RING)){
+			    		res = AST_DEVICE_INUSE;
+				    }
+			    }
+			    if ((res == AST_DEVICE_INUSE) || (res == AST_DEVICE_RINGING)) {
+				/* stop searching now, one non-idle channel is sufficient */
+				ast_mutex_unlock(&p->lock);
+				break;
+			    }
+			}
+		    }
+		    ast_mutex_unlock(&p->lock);
+		}	
+		p = p->next;
+	}
+	ast_mutex_unlock(lock);
+
+	return res;
+
+}
+
 static int zt_get_index(struct ast_channel *ast, struct zt_pvt *p, int nullok)
 {
 	int res;
