--- asterisk-1.4.10.1~dfsg.orig/include/asterisk/channel.h
+++ asterisk-1.4.10.1~dfsg/include/asterisk/channel.h
@@ -413,6 +413,8 @@ struct ast_channel {
 	unsigned int flags;				/*!< channel flags of AST_FLAG_ type */
 	unsigned short transfercapability;		/*!< ISDN Transfer Capbility - AST_FLAG_DIGITAL is not enough */
 	AST_LIST_HEAD_NOLOCK(, ast_frame) readq;
+	char lowlayercompat[16];			/*!< ISDN Low Layer Compatibility */
+	char highlayercompat[4];			/*!< ISDN High Layer Compatibility */
 	int alertpipe[2];
 
 	int nativeformats;				/*!< Kinds of data this channel can natively handle */
--- asterisk-1.4.10.1~dfsg.orig/main/pbx.c
+++ asterisk-1.4.10.1~dfsg/main/pbx.c
@@ -5101,7 +5101,7 @@ struct app_tmp {
 };
 
 /*! \brief run the application and free the descriptor once done */
-static void *ast_pbx_run_app(void *data)
+void *ast_pbx_run_app(void *data)
 {
 	struct app_tmp *tmp = data;
 	struct ast_app *app;
--- asterisk-1.4.10.1~dfsg.orig/include/asterisk/pbx.h
+++ asterisk-1.4.10.1~dfsg/include/asterisk/pbx.h
@@ -145,6 +145,8 @@ void ast_unregister_switch(struct ast_sw
  */
 struct ast_app *pbx_findapp(const char *app);
 
+void *ast_pbx_run_app(void *data);
+
 /*!
  * \brief Execute an application
  *
--- asterisk-1.4.10.1~dfsg.orig/channels/chan_zap.c
+++ asterisk-1.4.10.1~dfsg/channels/chan_zap.c
@@ -11,6 +11,10 @@
  * the project provides a web site, mailing lists and IRC
  * channels for your use.
  *
+ * Copyright (C) 2003-2006 Junghanns.NET GmbH
+ * Klaus-Peter Junghanns <kpj@junghanns.net>
+ *
+ *
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
@@ -103,6 +107,8 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 #include "asterisk/abstract_jb.h"
 #include "asterisk/smdi.h"
 #include "asterisk/astobj.h"
+#include "asterisk/devicestate.h"
+
 #define SMDI_MD_WAIT_TIMEOUT 1500 /* 1.5 seconds */
 
 /*! Global jitterbuffer configuration - by default, jb is disabled */
@@ -189,7 +195,7 @@ static const char config[] = "zapata.con
 #define SIG_GR303FXOKS	(0x0100000 | ZT_SIG_FXOKS)
 #define SIG_GR303FXSKS	(0x0100000 | ZT_SIG_FXSKS)
 
-#define NUM_SPANS 		32
+#define NUM_SPANS 		128	/*!<"32 spans", muahahaha, us alaws like to have some more... */
 #define NUM_DCHANS		4	/*!< No more than 4 d-channels */
 #define MAX_CHANNELS	672		/*!< No more than a DS3 per trunk group */
 
@@ -204,6 +210,9 @@ static const char config[] = "zapata.con
 static char defaultcic[64] = "";
 static char defaultozz[64] = "";
 
+static char nocid[256] = "No CID available";
+static char withheldcid[256] = "CID withheld";
+
 static char progzone[10] = "";
 
 static int distinctiveringaftercid = 0;
@@ -215,8 +224,6 @@ static struct ast_channel inuse;
 #ifdef PRI_GETSET_TIMERS
 static int pritimers[PRI_MAX_TIMERS];
 #endif
-static int pridebugfd = -1;
-static char pridebugfilename[1024] = "";
 #endif
 
 /*! \brief Wait up to 16 seconds for first digit (FXO logic) */
@@ -234,10 +241,6 @@ AST_MUTEX_DEFINE_STATIC(iflock);
 
 static int ifcount = 0;
 
-#ifdef HAVE_PRI
-AST_MUTEX_DEFINE_STATIC(pridebugfdlock);
-#endif
-
 /*! \brief Protect the monitoring thread, so only one process can kill or start it, and not
    when it's doing something critical. */
 AST_MUTEX_DEFINE_STATIC(monlock);
@@ -252,6 +255,7 @@ static enum ast_bridge_result zt_bridge(
 
 static int zt_sendtext(struct ast_channel *c, const char *text);
 
+
 /*! \brief Avoid the silly zt_getevent which ignores a bunch of events */
 static inline int zt_get_event(int fd)
 {
@@ -296,6 +300,27 @@ static int ringt_base = DEFAULT_RINGT;
 #define PRI_SPAN(p) (((p) >> 8) & 0xff)
 #define PRI_EXPLICIT(p) (((p) >> 16) & 0x01)
 
+struct zt_suspended_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char callid[10];			/* the callID provided by the user */
+	int parked_at;			/* extension in the call parking context */
+	struct zt_suspended_call *next;
+};
+
+struct zt_holded_call {
+	ast_mutex_t lock;		/* Mutex */
+	char msn[AST_MAX_EXTENSION];	/* the MSN to which this parked call belongs */
+	char uniqueid[AST_MAX_EXTENSION];	/* unique id of the onhold channel */
+	int tei;
+	int cref;
+	int alreadyhungup;
+	struct ast_channel *channel;
+	struct ast_channel *bridge;
+	q931_call *call;	/* this also covers tei mumbojumbo */
+	struct zt_holded_call *next;
+};
+
 struct zt_pri {
 	pthread_t master;						/*!< Thread of master */
 	ast_mutex_t lock;						/*!< Mutex */
@@ -309,6 +334,8 @@ struct zt_pri {
 	int nsf;							/*!< Network-Specific Facilities */
 	int dialplan;							/*!< Dialing plan */
 	int localdialplan;						/*!< Local dialing plan */
+ 	char nocid[256];
+ 	char withheldcid[256];
 	char internationalprefix[10];					/*!< country access code ('00' for european dialplans) */
 	char nationalprefix[10];					/*!< area access code ('0' for european dialplans) */
 	char localprefix[20];						/*!< area access code + area code ('0'+area code for european dialplans) */
@@ -320,6 +347,7 @@ struct zt_pri {
 	int prilogicalspan;						/*!< Logical span number within trunk group */
 	int numchans;							/*!< Num of channels we represent */
 	int overlapdial;						/*!< In overlap dialing mode */
+	int usercid;
 	int facilityenable;						/*!< Enable facility IEs */
 	struct pri *dchans[NUM_DCHANS];					/*!< Actual d-channels */
 	int dchanavail[NUM_DCHANS];					/*!< Whether each channel is available */
@@ -335,6 +363,9 @@ struct zt_pri {
 	struct zt_pvt *pvts[MAX_CHANNELS];				/*!< Member channel pvt structs */
 	struct zt_pvt *crvs;						/*!< Member CRV structs */
 	struct zt_pvt *crvend;						/*!< Pointer to end of CRV structs */
+ 	struct zt_suspended_call *suspended_calls; /* Calls parked with SUSPEND messages */
+ 	struct zt_holded_call *holded_calls; /* Calls on hold */
+	int debugfd;
 };
 
 
@@ -452,6 +483,8 @@ static struct zt_pvt {
 	unsigned int echocanbridged:1;
 	unsigned int echocanon:1;
 	unsigned int faxhandled:1;			/*!< Has a fax tone already been handled? */
+ 							/*!< KPJ: i will abuse this flag to implement a zapata option for dialing out
+ 							    on a zap channel with EC to be off no matter what happens. */
 	unsigned int firstradio:1;
 	unsigned int hanguponpolarityswitch:1;
 	unsigned int hardwaredtmf:1;
@@ -465,7 +498,8 @@ static struct zt_pvt {
 	unsigned int overlapdial:1;
 	unsigned int permcallwaiting:1;
 	unsigned int permhidecallerid:1;		/*!< Whether to hide our outgoing caller ID or not */
-	unsigned int priindication_oob:1;
+	unsigned int priindication_oob:2;
+	unsigned int pritransfer:2;
 	unsigned int priexclusive:1;
 	unsigned int pulse:1;
 	unsigned int pulsedial:1;			/*!< whether a pulse dial phone is detected */
@@ -502,6 +536,7 @@ static struct zt_pvt {
 #endif
 	char cid_num[AST_MAX_EXTENSION];
 	int cid_ton;					/*!< Type Of Number (TON) */
+	int cid_pres;					/*!< Calling Presentation */
 	char cid_name[AST_MAX_EXTENSION];
 	char lastcid_num[AST_MAX_EXTENSION];
 	char lastcid_name[AST_MAX_EXTENSION];
@@ -567,6 +602,8 @@ static struct zt_pvt {
 	struct zt_pvt *bearer;
 	struct zt_pvt *realcall;
 	q931_call *call;
+	int tei;					/* channel in use by this tei */
+	q931_call *holdedcall;
 	int prioffset;
 	int logicalspan;
 #endif	
@@ -617,6 +654,7 @@ static struct zt_chan_conf zt_chan_conf_
 			.localprefix = "",
 			.privateprefix = "",
 			.unknownprefix = "",
+			.usercid = 0,
 
 			.resetinterval = 3600
 		},
@@ -628,6 +666,8 @@ static struct zt_chan_conf zt_chan_conf_
 			.mohinterpret = "default",
 			.mohsuggest = "",
 			.transfertobusy = 1,
+			.priindication_oob = 0,
+			.pritransfer = 0,
 
 			.cid_signalling = CID_SIG_BELL,
 			.cid_start = CID_START_RING,
@@ -682,6 +722,8 @@ static int zt_indicate(struct ast_channe
 static int zt_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
 static int zt_setoption(struct ast_channel *chan, int option, void *data, int datalen);
 static int zt_func_read(struct ast_channel *chan, char *function, char *data, char *buf, size_t len); 
+static void enable_dtmf_detect(struct zt_pvt *p);
+static void disable_dtmf_detect(struct zt_pvt *p);
 
 static const struct ast_channel_tech zap_tech = {
 	.type = "Zap",
@@ -702,6 +744,7 @@ static const struct ast_channel_tech zap
 	.fixup = zt_fixup,
 	.setoption = zt_setoption,
 	.func_channel_read = zt_func_read,
+/*	.devicestate = zt_devicestate, */
 };
 
 #ifdef HAVE_PRI
@@ -713,6 +756,13 @@ static const struct ast_channel_tech zap
 struct zt_pvt *round_robin[32];
 
 #ifdef HAVE_PRI
+struct app_tmp {
+	char app[256];
+	char data[256];
+	struct ast_channel *chan;
+	pthread_t t;
+};
+
 static inline int pri_grab(struct zt_pvt *pvt, struct zt_pri *pri)
 {
 	int res;
@@ -760,6 +810,112 @@ static int cidrings[NUM_CADENCE_MAX] = {
 #define CANBUSYDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 #define CANPROGRESSDETECT(p) (ISTRUNK(p) || (p->sig & (SIG_EM | SIG_EM_E1 | SIG_SF)) /* || (p->sig & __ZT_SIG_FXO) */)
 
+static int zt_devicestate(void *data)
+{
+	int groupmatch = 0;
+	int channelmatch = 0;
+	struct zt_pvt *p;
+	char *dest=NULL;
+	int x;
+	char *s;
+	char opt=0;
+	int res, y=0;
+	struct zt_pvt *exit, *start, *end;
+	ast_mutex_t *lock;
+
+//	ast_log(LOG_NOTICE, "data = %s\n", (char *)data);
+	return AST_DEVICE_UNKNOWN;
+	
+	/* Assume we're locking the iflock */
+	lock = &iflock;
+	start = iflist;
+	end = ifend;
+
+	if (data) {
+		dest = ast_strdupa((char *)data);
+	} else {
+		ast_log(LOG_WARNING, "Channel requested with no data\n");
+		return AST_DEVICE_INVALID;
+	}
+	if (toupper(dest[0]) == 'G' || toupper(dest[0])=='R') {
+		/* Retrieve the group number */
+		char *stringp=NULL;
+		stringp=dest + 1;
+		s = strsep(&stringp, "/");
+		if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine group for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		}
+		groupmatch = 1 << x;
+	} else {
+		char *stringp=NULL;
+		stringp=dest;
+		s = strsep(&stringp, "/");
+		p = iflist;
+		if (!strcasecmp(s, "pseudo")) {
+			/* Special case for pseudo */
+			x = CHAN_PSEUDO;
+			channelmatch = x;
+			/* bail out */
+			return AST_DEVICE_INVALID;
+		} 
+
+		else if ((res = sscanf(s, "%d%c%d", &x, &opt, &y)) < 1) {
+			ast_log(LOG_WARNING, "Unable to determine channel for data %s\n", (char *)data);
+			return AST_DEVICE_INVALID;
+		} else {
+			channelmatch = x;
+			ast_log(LOG_NOTICE, "channelmatch = %d\n", channelmatch);
+		}
+	}
+	/* Search for an unowned channel */
+	if (ast_mutex_lock(lock)) {
+		ast_log(LOG_ERROR, "Unable to lock interface list???\n");
+		return AST_DEVICE_INVALID;
+	}
+	p = iflist;
+	exit = iflist;
+	res = AST_DEVICE_INVALID; /* start pessimistic */
+	while(p) {
+		if (p) {
+		    ast_mutex_lock(&p->lock);
+		    if ((groupmatch && ((p->group & groupmatch) != 0)) || (channelmatch && (p->channel == channelmatch))) {
+#ifdef ZAPATA_PRI
+			if (p->pri) {
+			    for(d=0;d<NUM_DCHANS;d++) {
+				if (p->pri->dchanavail[d] & DCHAN_UP) {
+			    	    res = AST_DEVICE_UNKNOWN;
+				}
+			    }
+			}
+#endif
+			if ((!ast_strlen_zero(p->cid_num) && (strncasecmp(p->cid_num, dest, strlen(p->cid_num)))) || (!ast_strlen_zero(p->dnid) && (strncasecmp(p->dnid, dest, strlen(p->dnid))))) {
+			    res = AST_DEVICE_UNKNOWN;
+			    if (p->owner) {
+				    if ((p->owner->_state == AST_STATE_RINGING) && (p->outgoing)) {
+			    		res = AST_DEVICE_RINGING;
+				    }
+				    if (((p->owner->_state == AST_STATE_RINGING) && (!p->outgoing)) || (p->owner->_state == AST_STATE_UP) || (p->owner->_state == AST_STATE_DIALING) || (p->owner->_state == AST_STATE_RESERVED) || (p->owner->_state == AST_STATE_RING)){
+			    		res = AST_DEVICE_INUSE;
+				    }
+			    }
+			    if ((res == AST_DEVICE_INUSE) || (res == AST_DEVICE_RINGING)) {
+				/* stop searching now, one non-idle channel is sufficient */
+				ast_mutex_unlock(&p->lock);
+				break;
+			    }
+			}
+		    }
+		    ast_mutex_unlock(&p->lock);
+		}	
+		p = p->next;
+	}
+	ast_mutex_unlock(lock);
+
+	return res;
+
+}
+
 static int zt_get_index(struct ast_channel *ast, struct zt_pvt *p, int nullok)
 {
 	int res;
@@ -1409,12 +1565,16 @@ static void zt_enable_ec(struct zt_pvt *
 	int res;
 	if (!p)
 		return;
+ 	if (p->faxhandled)  {
+ 		ast_log(LOG_DEBUG, "Not enabling echo cancellation on a fax/modem call\n");
+		return;
+ 	}
 	if (p->echocanon) {
 		ast_log(LOG_DEBUG, "Echo cancellation already on\n");
 		return;
 	}
 	if (p->digital) {
-		ast_log(LOG_DEBUG, "Echo cancellation isn't required on digital connection\n");
+		ast_log(LOG_DEBUG, "Echo cancellation does not make any sense on digital connections!\n");
 		return;
 	}
 	if (p->echocancel) {
@@ -1441,7 +1601,7 @@ static void zt_train_ec(struct zt_pvt *p
 {
 	int x;
 	int res;
-	if (p && p->echocancel && p->echotraining) {
+	if (p && p->echocancel && p->echotraining && (!p->digital) && (!p->faxhandled)) {
 		x = p->echotraining;
 		res = ioctl(p->subs[SUB_REAL].zfd, ZT_ECHOTRAIN, &x);
 		if (res)
@@ -1802,7 +1962,12 @@ static int zt_call(struct ast_channel *a
 		ast_log(LOG_WARNING, "Unable to flush input on channel %d\n", p->channel);
 	p->outgoing = 1;
 
-	set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	if (IS_DIGITAL(ast->transfercapability)) {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, 0, 0, p->law);
+	} else {
+	    set_actual_gain(p->subs[SUB_REAL].zfd, 0, p->rxgain, p->txgain, p->law);
+	}
+
 
 	mysig = p->sig;
 	if (p->outsigmod > -1)
@@ -2033,6 +2198,7 @@ static int zt_call(struct ast_channel *a
 	case SIG_PRI:
 		/* We'll get it in a moment -- but use dialdest to store pre-setup_ack digits */
 		p->dialdest[0] = '\0';
+		disable_dtmf_detect(p);
 		break;
 	default:
 		ast_log(LOG_DEBUG, "not yet implemented\n");
@@ -2053,6 +2219,12 @@ static int zt_call(struct ast_channel *a
 		const char *rr_str;
 		int redirect_reason;
 
+ 		if ((p->pri->nodetype == BRI_NETWORK_PTMP) || (p->pri->nodetype == BRI_NETWORK)) {
+ 		    // pass NO audio when ringing an isdn phone
+ 		    p->dialing = 1;
+ 		    // maybe we could allow passing audio when calling a p2p PBX, but well... ;-)
+ 		}
+
 		c = strchr(dest, '/');
 		if (c)
 			c++;
@@ -2074,6 +2246,7 @@ static int zt_call(struct ast_channel *a
 			ast_mutex_unlock(&p->lock);
 			return -1;
 		}
+		strncpy(p->dnid, (c + p->stripmsd), sizeof(p->dnid)-1);
 		if (mysig != SIG_FXSKS) {
 			p->dop.op = ZT_DIAL_OP_REPLACE;
 			s = strchr(c + p->stripmsd, 'w');
@@ -2097,6 +2270,8 @@ static int zt_call(struct ast_channel *a
 			pri_rel(p->pri);
 			ast_mutex_unlock(&p->lock);
 			return -1;
+		} else {
+		//	ast_log(LOG_NOTICE, "call %d\n", p->call);
 		}
 		if (!(sr = pri_sr_new())) {
 			ast_log(LOG_WARNING, "Failed to allocate setup request channel %d\n", p->channel);
@@ -2126,7 +2301,7 @@ static int zt_call(struct ast_channel *a
 		pri_sr_set_channel(sr, p->bearer ? PVT_TO_CHANNEL(p->bearer) : PVT_TO_CHANNEL(p), exclusive, 1);
 		pri_sr_set_bearer(sr, p->digital ? PRI_TRANS_CAP_DIGITAL : ast->transfercapability, 
 					(p->digital ? -1 : 
-						((p->law == ZT_LAW_ALAW) ? PRI_LAYER_1_ALAW : PRI_LAYER_1_ULAW)));
+						((p->law == ZT_LAW_ALAW) ? PRI_LAYER_1_ALAW : PRI_LAYER_1_ULAW)), ast->lowlayercompat);
 		if (p->pri->facilityenable)
 			pri_facility_enable(p->pri->pri);
 
@@ -2390,8 +2565,10 @@ static int pri_find_dchan(struct zt_pri 
 	}
 	if (newslot < 0) {
 		newslot = 0;
-		ast_log(LOG_WARNING, "No D-channels available!  Using Primary channel %d as D-channel anyway!\n",
+		if (pri->nodetype != BRI_CPE_PTMP) {
+		    ast_log(LOG_WARNING, "No D-channels available!  Using Primary channel %d as D-channel anyway!\n",
 			pri->dchannels[newslot]);
+		}
 	}
 	if (old && (oldslot != newslot))
 		ast_log(LOG_NOTICE, "Switching from from d-channel %d to channel %d!\n",
@@ -2401,6 +2578,16 @@ static int pri_find_dchan(struct zt_pri 
 }
 #endif
 
+static int zt_setlaw(int zfd, int law)
+{
+	int res;
+	res = ioctl(zfd, ZT_SETLAW, &law);
+	if (res)
+		return res;
+	return 0;
+}
+
+
 static int zt_hangup(struct ast_channel *ast)
 {
 	int res;
@@ -2448,8 +2635,7 @@ static int zt_hangup(struct ast_channel 
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Hangup: channel: %d index = %d, normal = %d, callwait = %d, thirdcall = %d\n",
 		p->channel, index, p->subs[SUB_REAL].zfd, p->subs[SUB_CALLWAIT].zfd, p->subs[SUB_THREEWAY].zfd);
-	p->ignoredtmf = 0;
-	
+
 	if (index > -1) {
 		/* Real channel, do some fixup */
 		p->subs[index].owner = NULL;
@@ -2551,6 +2737,7 @@ static int zt_hangup(struct ast_channel 
 	}
 
 	if (!p->subs[SUB_REAL].owner && !p->subs[SUB_CALLWAIT].owner && !p->subs[SUB_THREEWAY].owner) {
+		int outgoing = p->outgoing;
 		p->owner = NULL;
 		p->ringt = 0;
 		p->distinctivering = 0;
@@ -2593,7 +2780,7 @@ static int zt_hangup(struct ast_channel 
 						pri_call_set_useruser(p->call, useruser);
 #endif
 
-						pri_hangup(p->pri->pri, p->call, -1);
+						pri_hangup(p->pri->pri, p->call, -1, -1);
 						p->call = NULL;
 						if (p->bearer) 
 							p->bearer->call = NULL;
@@ -2613,7 +2800,28 @@ static int zt_hangup(struct ast_channel 
 							if (atoi(cause))
 								icause = atoi(cause);
 						}
-						pri_hangup(p->pri->pri, p->call, icause);
+
+						pri_hangup(p->pri->pri, p->call, icause, -1);
+
+						/* if we send a rel9999ease complete we wont ge no hangup event, so clear the call here */
+						if (icause == 34 || icause == 44 || icause == 82 || icause == 1 || icause == 81 || icause == 17) {
+						    if ((ast->_state == AST_STATE_RING) || (ast->_state == AST_STATE_RINGING) || (ast->_state == AST_STATE_DIALING) || (ast->_state == AST_STATE_RESERVED)) {
+							p->call = NULL;
+						    } else {
+							ast_log(LOG_ERROR, "What is wrong with you? You cannot use cause %d number when in state %d!\n", icause, ast->_state);
+							icause = 16; /* Note, in pri_hangup() libpri will already override the cause */
+						    }
+						} 
+						
+						if (p->pri->nodetype == BRI_NETWORK_PTMP) {
+						    if ((icause == 16 || icause == -1) && (ast->_state != AST_STATE_UP)) {
+							if (outgoing) {
+							    p->call = NULL;
+							}
+						    }
+						}
+						
+						
 					}
 					if (res < 0) 
 						ast_log(LOG_WARNING, "pri_disconnect failed\n");
@@ -2797,10 +3005,14 @@ static int zt_answer(struct ast_channel 
 			p->proceeding = 1;
 			res = pri_answer(p->pri->pri, p->call, 0, !p->digital);
 			pri_rel(p->pri);
+			/* stop ignoring inband dtmf */
+			enable_dtmf_detect(p);
 		} else {
 			ast_log(LOG_WARNING, "Unable to grab PRI on span %d\n", p->span);
 			res = -1;
 		}
+		/* the audio path is complete now, train the echo canceler */
+		zt_train_ec(p);
 		break;
 #endif
 	case 0:
@@ -3428,6 +3640,15 @@ static int zt_fixup(struct ast_channel *
 {
 	struct zt_pvt *p = newchan->tech_pvt;
 	int x;
+ 	if (newchan && newchan->tech_pvt) {
+ 	    p = newchan->tech_pvt;
+ 	}
+ 	if (!p) {
+ 	    if (newchan) {
+ 		ast_log(LOG_ERROR, "channel %s has no tech_pvt structure\n", newchan->name);
+ 	    }
+ 	    return 0;
+ 	}
 	ast_mutex_lock(&p->lock);
 	ast_log(LOG_DEBUG, "New owner for channel %d is %s\n", p->channel, newchan->name);
 	if (p->owner == oldchan) {
@@ -3637,8 +3858,10 @@ static void zt_handle_dtmfup(struct ast_
 					pbx_builtin_setvar_helper(ast, "FAXEXTEN", ast->exten);
 					if (ast_async_goto(ast, target_context, "fax", 1))
 						ast_log(LOG_WARNING, "Failed to async goto '%s' into fax of '%s'\n", ast->name, target_context);
-				} else
+				} else {
+				    if (option_verbose > 2)
 					ast_log(LOG_NOTICE, "Fax detected, but no fax extension\n");
+				}
 			} else if (option_debug)
 				ast_log(LOG_DEBUG, "Already in a fax extension, not redirecting\n");
 		} else if (option_debug)
@@ -3792,7 +4015,7 @@ static struct ast_frame *zt_handle_event
 				if (p->call) {
 					if (p->pri && p->pri->pri) {
 						if (!pri_grab(p, p->pri)) {
-							pri_hangup(p->pri->pri, p->call, -1);
+							pri_hangup(p->pri->pri, p->call, -1, -1);
 							pri_destroycall(p->pri->pri, p->call);
 							p->call = NULL;
 							pri_rel(p->pri);
@@ -4851,7 +5074,7 @@ static struct ast_frame  *zt_read(struct
 		p->subs[index].f.data = NULL;
 		p->subs[index].f.datalen= 0;
 	}
-	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect  || p->callprogress) && !index) {
+	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect || p->callprogress) && !index) {
 		/* Perform busy detection. etc on the zap line */
 		f = ast_dsp_process(ast, p->dsp, &p->subs[index].f);
 		if (f) {
@@ -4863,8 +5086,9 @@ static struct ast_frame  *zt_read(struct
 				}
 			} else if (f->frametype == AST_FRAME_DTMF) {
 #ifdef HAVE_PRI
-				if (!p->proceeding && p->sig==SIG_PRI && p->pri && p->pri->overlapdial) {
-					/* Don't accept in-band DTMF when in overlap dial mode */
+				if (p->sig==SIG_PRI && p->pri && p->pri->overlapdial && p->ignoredtmf) {
+					/* Don't accept in-band DTMF when in overlap dial mode 
+					   or when in non-overlap overlapdialing mode ... */
 					f->frametype = AST_FRAME_NULL;
 					f->subclass = 0;
 				}
@@ -4940,7 +5164,9 @@ static int zt_write(struct ast_channel *
 #endif
 	/* Write a frame of (presumably voice) data */
 	if (frame->frametype != AST_FRAME_VOICE) {
-		if (frame->frametype != AST_FRAME_IMAGE)
+		if (frame->frametype == AST_FRAME_TEXT) {
+			ast_log(LOG_NOTICE, "text\n");
+		} else if (frame->frametype != AST_FRAME_IMAGE)
 			ast_log(LOG_WARNING, "Don't know what to do with frame type '%d'\n", frame->frametype);
 		return 0;
 	}
@@ -5012,7 +5238,7 @@ static int zt_indicate(struct ast_channe
 		switch (condition) {
 		case AST_CONTROL_BUSY:
 #ifdef HAVE_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_USER_BUSY;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -5094,7 +5320,7 @@ static int zt_indicate(struct ast_channe
 		case AST_CONTROL_CONGESTION:
 			chan->hangupcause = AST_CAUSE_CONGESTION;
 #ifdef HAVE_PRI
-			if (p->priindication_oob && p->sig == SIG_PRI) {
+			if ((p->priindication_oob == 1) && p->sig == SIG_PRI) {
 				chan->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
 				chan->_softhangup |= AST_SOFTHANGUP_DEV;
 				res = 0;
@@ -5288,8 +5514,12 @@ static struct ast_channel *zt_new(struct
 	if (state == AST_STATE_RING)
 		tmp->rings = 1;
 	tmp->tech_pvt = i;
+#ifdef HAVE_PRI
+	if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS) || (i->sig == SIG_PRI)) {
+#else
 	if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
-		/* Only FXO signalled stuff can be picked up */
+#endif
+		/* Only FXO signalled stuff can be picked up */ /* i dont think so, mr. ulaw! we alaws like to pick up BRIs/PRIs */
 		tmp->callgroup = i->callgroup;
 		tmp->pickupgroup = i->pickupgroup;
 	}
@@ -5423,6 +5653,7 @@ static void *ss_thread(void *data)
 	int len = 0;
 	int res;
 	int index;
+	int network;
 
 	/* in the bizarre case where the channel has become a zombie before we
 	   even get started here, abort safely
@@ -5451,10 +5682,17 @@ static void *ss_thread(void *data)
 		len = strlen(exten);
 		res = 0;
 		while ((len < AST_MAX_EXTENSION-1) && ast_matchmore_extension(chan, chan->context, exten, 1, p->cid_num)) {
-			if (len && !ast_ignore_pattern(chan->context, exten))
+			if (len && !ast_ignore_pattern(chan->context, exten)) {
 				tone_zone_play_tone(p->subs[index].zfd, -1);
-			else
-				tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+			} else {
+				network = p->pri->nodetype == PRI_NETWORK || p->pri->nodetype == BRI_NETWORK || p->pri->nodetype == BRI_NETWORK_PTMP;
+				if (network) {
+				    tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALTONE);
+				} else {
+				    /* cpe be quiet */
+				    tone_zone_play_tone(p->subs[index].zfd, -1);
+				}
+			}
 			if (ast_exists_extension(chan, chan->context, exten, 1, p->cid_num))
 				timeout = matchdigittimeout;
 			else
@@ -6660,18 +6898,44 @@ static int handle_init_event(struct zt_p
 		break;
 	case ZT_EVENT_NOALARM:
 		i->inalarm = 0;
+#ifdef HAVE_PRI
+		if (i->pri) {
+		    if ((i->pri->nodetype == BRI_CPE_PTMP) || (i->pri->nodetype == BRI_CPE_PTMP)) {
+			/* dont annoy BRI TE mode users with layer2layer alarms */
+		    } else {
+			ast_log(LOG_NOTICE, "Alarm cleared on channel %d\n", i->channel);
+			manager_event(EVENT_FLAG_SYSTEM, "AlarmClear",
+		              "Channel: %d\r\n", i->channel);
+		    }
+		}
+#else
 		ast_log(LOG_NOTICE, "Alarm cleared on channel %d\n", i->channel);
 		manager_event(EVENT_FLAG_SYSTEM, "AlarmClear",
 			"Channel: %d\r\n", i->channel);
+#endif
 		break;
 	case ZT_EVENT_ALARM:
 		i->inalarm = 1;
 		res = get_alarms(i);
+#ifdef HAVE_PRI
+		if (i->pri) {
+		    if ((i->pri->nodetype == BRI_CPE_PTMP) || (i->pri->nodetype == BRI_CPE_PTMP)) {
+			/* dont annoy BRI TE mode users with layer2layer alarms */
+		    } else {
+			ast_log(LOG_WARNING, "Detected alarm on channel %d: %s\n", i->channel, alarm2str(res));
+			manager_event(EVENT_FLAG_SYSTEM, "Alarm",
+		              "Alarm: %s\r\n"
+		              "Channel: %d\r\n",
+		              alarm2str(res), i->channel);
+		    }
+		}
+#else
 		ast_log(LOG_WARNING, "Detected alarm on channel %d: %s\n", i->channel, alarm2str(res));
 		manager_event(EVENT_FLAG_SYSTEM, "Alarm",
 			"Alarm: %s\r\n"
 			"Channel: %d\r\n",
 			alarm2str(res), i->channel);
+#endif
 		/* fall thru intentionally */
 	case ZT_EVENT_ONHOOK:
 		if (i->radio)
@@ -6715,8 +6979,10 @@ static int handle_init_event(struct zt_p
 			zt_set_hook(i->subs[SUB_REAL].zfd, ZT_ONHOOK);
 			break;
 		case SIG_PRI:
-			zt_disable_ec(i);
-			res = tone_zone_play_tone(i->subs[SUB_REAL].zfd, -1);
+			if (event != ZT_EVENT_ALARM) {
+			    zt_disable_ec(i);
+			    res = tone_zone_play_tone(i->subs[SUB_REAL].zfd, -1);
+			}
 			break;
 		default:
 			ast_log(LOG_WARNING, "Don't know how to handle on hook with signalling %s on channel %d\n", sig2str(i->sig), i->channel);
@@ -7006,6 +7272,8 @@ static int pri_resolve_span(int *span, i
 		} else {
 			if (si->totalchans == 31) { /* if it's an E1 */
 				pris[*span].dchannels[0] = 16 + offset;
+			} else if (si->totalchans == 3) { /* if it's an S0 ZAPBRI */
+				pris[*span].dchannels[0] = 3 + offset;
 			} else {
 				pris[*span].dchannels[0] = 24 + offset;
 			}
@@ -7258,6 +7526,11 @@ static struct zt_pvt *mkintf(int channel
 							destroy_zt_pvt(&tmp);
 							return NULL;
 						}
+                                          	if ((pris[span].localdialplan) && (pris[span].localdialplan != conf.pri.localdialplan)) {
+  							ast_log(LOG_ERROR, "Span %d is already a %s local dialing plan\n", span + 1, dialplan2str(pris[span].localdialplan));
+  							destroy_zt_pvt(&tmp);
+                                                  	return NULL;
+   						}
 						if (pris[span].minunused && (pris[span].minunused != conf.pri.minunused)) {
 							ast_log(LOG_ERROR, "Span %d already has minunused of %d.\n", span + 1, conf.pri.minunused);
 							destroy_zt_pvt(&tmp);
@@ -7275,6 +7548,11 @@ static struct zt_pvt *mkintf(int channel
 							return NULL;
 						}
 						pris[span].nodetype = conf.pri.nodetype;
+
+						if (conf.pri.nodetype == BRI_NETWORK_PTMP) {
+						    pris[span].dchanavail[0] =  DCHAN_AVAILABLE;
+						    pri_find_dchan(&pris[span]);
+						}
 						pris[span].switchtype = myswitchtype;
 						pris[span].nsf = conf.pri.nsf;
 						pris[span].dialplan = conf.pri.dialplan;
@@ -7283,9 +7561,14 @@ static struct zt_pvt *mkintf(int channel
 						pris[span].minunused = conf.pri.minunused;
 						pris[span].minidle = conf.pri.minidle;
 						pris[span].overlapdial = conf.pri.overlapdial;
+						pris[span].usercid = conf.pri.usercid;
+						pris[span].suspended_calls = NULL;
+						pris[span].holded_calls = NULL;
 						pris[span].facilityenable = conf.pri.facilityenable;
 						ast_copy_string(pris[span].idledial, conf.pri.idledial, sizeof(pris[span].idledial));
 						ast_copy_string(pris[span].idleext, conf.pri.idleext, sizeof(pris[span].idleext));
+  						ast_copy_string(pris[span].nocid, conf.pri.nocid, sizeof(pris[span].nocid) - 1);
+  						ast_copy_string(pris[span].withheldcid, conf.pri.withheldcid, sizeof(pris[span].withheldcid) - 1);
 						ast_copy_string(pris[span].internationalprefix, conf.pri.internationalprefix, sizeof(pris[span].internationalprefix));
 						ast_copy_string(pris[span].nationalprefix, conf.pri.nationalprefix, sizeof(pris[span].nationalprefix));
 						ast_copy_string(pris[span].localprefix, conf.pri.localprefix, sizeof(pris[span].localprefix));
@@ -7421,6 +7704,7 @@ static struct zt_pvt *mkintf(int channel
 		tmp->restrictcid = conf.chan.restrictcid;
 		tmp->use_callingpres = conf.chan.use_callingpres;
 		tmp->priindication_oob = conf.chan.priindication_oob;
+ 		tmp->pritransfer = conf.chan.pritransfer;
 		tmp->priexclusive = conf.chan.priexclusive;
 		if (tmp->usedistinctiveringdetection) {
 			if (!tmp->use_callerid) {
@@ -7700,7 +7984,7 @@ static int pri_find_empty_chan(struct zt
 			break;
 		if (!backwards && (x >= pri->numchans))
 			break;
-		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner) {
+		if (pri->pvts[x] && !pri->pvts[x]->inalarm && !pri->pvts[x]->owner && !pri->pvts[x]->call) {
 			ast_log(LOG_DEBUG, "Found empty available channel %d/%d\n", 
 				pri->pvts[x]->logicalspan, pri->pvts[x]->prioffset);
 			return x;
@@ -7896,6 +8180,11 @@ static struct ast_channel *zt_request(co
 					p->digital = 1;
 					if (tmp)
 						tmp->transfercapability = AST_TRANS_CAP_DIGITAL;
+				} else if (opt == 'm') {
+					/* If this is a modem/fax call, pretend to have the fax handled and dont do EC */
+					p->faxhandled = 1;
+					if (tmp)
+					    tmp->transfercapability = AST_TRANS_CAP_3_1K_AUDIO;
 				} else {
 					ast_log(LOG_WARNING, "Unknown option '%c' in '%s'\n", opt, (char *)data);
 				}
@@ -7929,13 +8218,14 @@ next:
 				*cause = AST_CAUSE_BUSY;
 		} else if (groupmatched) {
 			*cause = AST_CAUSE_CONGESTION;
+		} else {
+			*cause = AST_CAUSE_CONGESTION;
 		}
 	}
 		
 	return tmp;
 }
 
-
 #ifdef HAVE_PRI
 static struct zt_pvt *pri_find_crv(struct zt_pri *pri, int crv)
 {
@@ -7949,6 +8239,58 @@ static struct zt_pvt *pri_find_crv(struc
 	return NULL;
 }
 
+static int pri_find_tei(struct zt_pri *pri, q931_call *c, int tei)
+{
+	int x=0;
+	for (x=0;x<pri->numchans;x++) {
+		if (!pri->pvts[x]) continue;
+		if ((pri->pvts[x]->tei == tei) && (pri->pvts[x]-> call != c)) {
+		    return x;
+		}
+	}
+	return -1;
+}
+
+static struct zt_holded_call *pri_get_callonhold(struct zt_pri *pri, int cref, int tei) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if ((zhc->tei == tei) && ((zhc->cref == cref) || (cref == -1))) {
+		return zhc;
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	return NULL;	
+}
+
+static int pri_destroy_callonhold(struct zt_pri *pri, struct zt_holded_call *onhold) {
+	struct zt_holded_call *zhc = pri->holded_calls;
+	struct zt_holded_call *zhctemp = NULL;
+
+	while (zhc) {
+	    if (zhc == onhold) {
+		if (zhctemp) {
+		    zhctemp->next = zhc->next;
+		    zhc = zhctemp;
+		} else {
+		    pri->holded_calls = zhc->next;
+		    zhc = pri->holded_calls;
+		    zhctemp = NULL;
+		}
+	    }			
+	    zhctemp = zhc;
+	    if (zhc) zhc = zhc->next;
+	}
+	if (onhold) {
+	    free(onhold);
+	    onhold = NULL;
+	    return 1;	
+	}
+	return 0;	
+}
+
 
 static int pri_find_principle(struct zt_pri *pri, int channel)
 {
@@ -7980,7 +8322,9 @@ static int pri_find_principle(struct zt_
 static int pri_fixup_principle(struct zt_pri *pri, int principle, q931_call *c)
 {
 	int x;
+	int res = 0;
 	struct zt_pvt *crv;
+	char tmpname[256];
 	if (!c) {
 		if (principle < 0)
 			return -1;
@@ -8008,6 +8352,7 @@ static int pri_fixup_principle(struct zt
 				}
 				/* Fix it all up now */
 				pri->pvts[principle]->owner = pri->pvts[x]->owner;
+ 				pri->pvts[principle]->outgoing = pri->pvts[x]->outgoing;
 				if (pri->pvts[principle]->owner) {
 					ast_string_field_build(pri->pvts[principle]->owner, name, 
 							       "Zap/%d:%d-%d", pri->trunkgroup,
@@ -8015,13 +8360,48 @@ static int pri_fixup_principle(struct zt
 					pri->pvts[principle]->owner->tech_pvt = pri->pvts[principle];
 					pri->pvts[principle]->owner->fds[0] = pri->pvts[principle]->subs[SUB_REAL].zfd;
 					pri->pvts[principle]->subs[SUB_REAL].owner = pri->pvts[x]->subs[SUB_REAL].owner;
-				} else
+				} else {
 					ast_log(LOG_WARNING, "Whoa, there's no  owner, and we're having to fix up channel %d to channel %d\n", pri->pvts[x]->channel, pri->pvts[principle]->channel);
+				}
 				pri->pvts[principle]->call = pri->pvts[x]->call;
+  				pri->pvts[principle]->dsp = pri->pvts[x]->dsp;
+  				pri->pvts[principle]->alreadyhungup = pri->pvts[x]->alreadyhungup;
+				pri->pvts[principle]->digital = pri->pvts[x]->digital;
+  				pri->pvts[principle]->faxhandled = pri->pvts[x]->faxhandled;
+  
+  				if ((pri->nodetype == BRI_CPE_PTMP) || (pri->nodetype == BRI_CPE)) { 
+  				    /* this might also apply for other pri types! */
+  				    pri->pvts[principle]->law = pri->pvts[x]->law;
+  				    if (ioctl(pri->pvts[principle]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &pri->pvts[principle]->law) == -1)
+  					ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", pri->pvts[principle]->channel, pri->pvts[principle]->law);
+  				    res = zt_setlaw(pri->pvts[principle]->subs[SUB_REAL].zfd, pri->pvts[principle]->law);
+  				    if (res < 0) 
+  					ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[principle]->channel);
+				    if (!pri->pvts[principle]->digital) {
+  					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, pri->pvts[principle]->rxgain, pri->pvts[principle]->txgain, pri->pvts[principle]->law);
+  				    } else {
+  					res = set_actual_gain(pri->pvts[principle]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[principle]->law);
+				    }
+				    if (res < 0) 
+  					ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[principle]->channel);
+  				    zt_confmute(pri->pvts[x], 0);
+  				    update_conf(pri->pvts[x]);
+  				    reset_conf(pri->pvts[x]);
+  				    restore_gains(pri->pvts[x]);
+  				    zt_disable_ec(pri->pvts[x]);
+  				    zt_setlinear(pri->pvts[x]->subs[SUB_REAL].zfd, 0);
+  				}
+  
+  				if (pri->pvts[principle]->owner) {
+  				    snprintf(tmpname, sizeof(tmpname), "Zap/%d-1", pri->pvts[principle]->channel);
+  				    ast_change_name(pri->pvts[principle]->owner, tmpname);
+  				}
+
 				/* Free up the old channel, now not in use */
 				pri->pvts[x]->subs[SUB_REAL].owner = NULL;
 				pri->pvts[x]->owner = NULL;
 				pri->pvts[x]->call = NULL;
+ 				pri->pvts[x]->dsp = NULL;
 			}
 			return principle;
 		}
@@ -8050,7 +8430,9 @@ static int pri_fixup_principle(struct zt
 		}
 		crv = crv->next;
 	}
-	ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+	    ast_log(LOG_WARNING, "Call specified, but not found?\n");
+	}
 	return -1;
 }
 
@@ -8109,86 +8491,21 @@ static void *do_idle_thread(void *vchan)
 #ifndef PRI_RESTART
 #error "Upgrade your libpri"
 #endif
-static void zt_pri_message(struct pri *pri, char *s)
+static void zt_pri_message(char *s, int span)
 {
-	int x, y;
-	int dchan = -1, span = -1;
-	int dchancount = 0;
-
-	if (pri) {
-		for (x = 0; x < NUM_SPANS; x++) {
-			for (y = 0; y < NUM_DCHANS; y++) {
-				if (pris[x].dchans[y])
-					dchancount++;
-
-				if (pris[x].dchans[y] == pri)
-					dchan = y;
-			}
-			if (dchan >= 0) {
-				span = x;
-				break;
-			}
-			dchancount = 0;
-		}
-		if ((dchan >= 0) && (span >= 0)) {
-			if (dchancount > 1)
-				ast_verbose("[Span %d D-Channel %d]%s", span, dchan, s);
-			else
-				ast_verbose("%s", s);
-		} else
-			ast_log(LOG_ERROR, "PRI debug error: could not find pri associated it with debug message output\n");
-	} else
-		ast_verbose("%s", s);
-
-	ast_mutex_lock(&pridebugfdlock);
-
-	if (pridebugfd >= 0)
-		write(pridebugfd, s, strlen(s));
-
-	ast_mutex_unlock(&pridebugfdlock);
+	ast_verbose("%d %s", span, s);
 }
 
-static void zt_pri_error(struct pri *pri, char *s)
+static void zt_pri_error(char *s, int span)
 {
-	int x, y;
-	int dchan = -1, span = -1;
-	int dchancount = 0;
-
-	if (pri) {
-		for (x = 0; x < NUM_SPANS; x++) {
-			for (y = 0; y < NUM_DCHANS; y++) {
-				if (pris[x].dchans[y])
-					dchancount++;
-
-				if (pris[x].dchans[y] == pri)
-					dchan = y;
-			}
-			if (dchan >= 0) {
-				span = x;
-				break;
-			}
-			dchancount = 0;
-		}
-		if ((dchan >= 0) && (span >= 0)) {
-			if (dchancount > 1)
-				ast_log(LOG_ERROR, "[Span %d D-Channel %d] PRI: %s", span, dchan, s);
-			else
-				ast_log(LOG_ERROR, "%s", s);
-		} else
-			ast_log(LOG_ERROR, "PRI debug error: could not find pri associated it with debug message output\n");
-	} else
-		ast_log(LOG_ERROR, "%s", s);
-
-	ast_mutex_lock(&pridebugfdlock);
-
-	if (pridebugfd >= 0)
-		write(pridebugfd, s, strlen(s));
-
-	ast_mutex_unlock(&pridebugfdlock);
+	ast_log(LOG_WARNING, "%d %s", span, s);
 }
 
 static int pri_check_restart(struct zt_pri *pri)
 {
+	if ((pri->nodetype != PRI_NETWORK) && (pri->nodetype != PRI_CPE)) {
+	    return 0;
+	}
 	do {
 		pri->resetpos++;
 	} while ((pri->resetpos < pri->numchans) &&
@@ -8272,13 +8589,30 @@ static void apply_plan_to_number(char *b
 	}
 }
 
-static int zt_setlaw(int zfd, int law)
-{
-	int res;
-	res = ioctl(zfd, ZT_SETLAW, &law);
-	if (res)
-		return res;
-	return 0;
+static void pri_make_callerid(struct zt_pri *pri, char *callerid, int callerid_len, char *callingnum, int callingnum_len, int callingplan, int callingpres, int stripmsd) {
+    if (callingnum && (callingnum_len > stripmsd)) {
+	callingnum += stripmsd;
+    }
+    switch (callingplan) {
+	case PRI_INTERNATIONAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->internationalprefix, callingnum);
+	    break;
+	case PRI_NATIONAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->nationalprefix, callingnum);
+	    break;
+	case PRI_LOCAL_ISDN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->localprefix, callingnum);
+	    break;
+	case PRI_PRIVATE:
+	    snprintf(callerid, callerid_len, "%s%s", pri->privateprefix, callingnum);
+	    break;
+	case PRI_UNKNOWN:
+	    snprintf(callerid, callerid_len, "%s%s", pri->unknownprefix, callingnum);
+	    break;
+	default:
+	    snprintf(callerid, callerid_len, "%s", callingnum);
+	    break;
+    }
 }
 
 static void *pri_dchannel(void *vpri)
@@ -8458,15 +8792,44 @@ static void *pri_dchannel(void *vpri)
 					/* Check for an event */
 					x = 0;
 					res = ioctl(pri->fds[which], ZT_GETEVENT, &x);
-					if (x) 
+					if ((pri->nodetype != BRI_CPE) && (pri->nodetype != BRI_CPE_PTMP)) {
+					    /* dont annoy BRI TE mode users with layer2layer alarms */
+					    if (x)
 						ast_log(LOG_NOTICE, "PRI got event: %s (%d) on %s D-channel of span %d\n", event2str(x), x, pri_order(which), pri->span);
+					}
 					/* Keep track of alarm state */	
 					if (x == ZT_EVENT_ALARM) {
 						pri->dchanavail[which] &= ~(DCHAN_NOTINALARM | DCHAN_UP);
 						pri_find_dchan(pri);
+						if ((pri->nodetype == BRI_CPE) || (pri->nodetype == BRI_CPE_PTMP)) {
+						    if (pri->pri) {
+							for (i=0; i<pri->numchans; i++) {
+							    struct zt_pvt *p = pri->pvts[i];
+							    if (p) {
+								if (p->call) {
+								    if (p->pri && p->pri->pri) {
+								    	pri_destroycall(p->pri->pri, p->call);
+									p->call = NULL;
+									p->tei = -1;
+								    } else
+									ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
+								}
+								if (p->owner)
+								    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+								p->inalarm = 1;
+							    }
+							}
+							pri_shutdown(pri->pri);
+						    }
+						}
 					} else if (x == ZT_EVENT_NOALARM) {
-						pri->dchanavail[which] |= DCHAN_NOTINALARM;
-						pri_restart(pri->dchans[which]);
+						if ((pri->nodetype == BRI_CPE) || (pri->nodetype == BRI_CPE_PTMP)) {
+						    pri->dchanavail[which] |= DCHAN_NOTINALARM;
+						//    pri->dchanavail[which] |= DCHAN_UP;
+						} else {
+						    pri->dchanavail[which] |= DCHAN_NOTINALARM;
+						    pri_restart(pri->dchans[which]);
+						}
 					}
 				
 					if (option_debug)
@@ -8478,8 +8841,7 @@ static void *pri_dchannel(void *vpri)
 					break;
 			}
 		} else if (errno != EINTR)
-			ast_log(LOG_WARNING, "pri_event returned error %d (%s)\n", errno, strerror(errno));
-
+ 			ast_log(LOG_WARNING, "pri_event returned error %d (%s) on span %d\n", errno, strerror(errno), pri->span);
 		if (e) {
 			if (pri->debug)
 				pri_dump_event(pri->dchans[which], e);
@@ -8492,32 +8854,86 @@ static void *pri_dchannel(void *vpri)
 
 			switch (e->e) {
 			case PRI_EVENT_DCHAN_UP:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
-				pri->dchanavail[which] |= DCHAN_UP;
-				if (!pri->pri) pri_find_dchan(pri);
+  				if (pri->nodetype == BRI_NETWORK_PTMP) {
+  				    if (option_verbose > 3) 
+  					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+				    pri->dchanavail[which] |= DCHAN_UP;
+				    if (!pri->pri) pri_find_dchan(pri);
+  
+  				    /* Note presense of D-channel */
+  				    time(&pri->lastreset);
+  
+  				    pri->resetting = 0;
+  				    /* Take the channels from inalarm condition */
+  				    for (i=0; i<pri->numchans; i++)
+  					if (pri->pvts[i]) {
+  						pri->pvts[i]->inalarm = 0;
+  					}
+  				} else {
+  				    if (pri->nodetype == BRI_CPE_PTMP) {
+  					if (option_verbose > 3) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+  				    } else {
+  					if (option_verbose > 1) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d up\n", pri_order(which), pri->span);
+  				    }
+				    pri->dchanavail[which] |= DCHAN_UP;
+				    if (!pri->pri) pri_find_dchan(pri);
 
-				/* Note presense of D-channel */
-				time(&pri->lastreset);
+				    /* Note presense of D-channel */
+				    time(&pri->lastreset);
 
-				/* Restart in 5 seconds */
-				if (pri->resetinterval > -1) {
+				    /* Restart in 5 seconds */
+				    if (pri->resetinterval > -1) {
 					pri->lastreset -= pri->resetinterval;
 					pri->lastreset += 5;
-				}
-				pri->resetting = 0;
-				/* Take the channels from inalarm condition */
-				for (i = 0; i < pri->numchans; i++)
+				    }
+				    pri->resetting = 0;
+				    /* Take the channels from inalarm condition */
+				    for (i = 0; i < pri->numchans; i++)
 					if (pri->pvts[i]) {
 						pri->pvts[i]->inalarm = 0;
 					}
+				}
 				break;
 			case PRI_EVENT_DCHAN_DOWN:
-				if (option_verbose > 1) 
-					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
-				pri->dchanavail[which] &= ~DCHAN_UP;
-				pri_find_dchan(pri);
-				if (!pri_is_up(pri)) {
+  				if (pri->nodetype == BRI_NETWORK_PTMP) {
+  				    if (option_verbose > 3) 
+  					ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down for TEI %d\n", pri_order(which), pri->span, e->gen.tei);
+  				    // PTMP BRIs have N dchans, handled by libpri
+  				    if (e->gen.tei == 0) break;
+  				    /* Hangup active channels */
+  				    for (i=0; i<pri->numchans; i++) {
+  				    	struct zt_pvt *p = pri->pvts[i];
+ 					if (p) {
+  			//		ast_log(LOG_NOTICE, "chan %d tei %d\n",i,p->tei);
+  					    if (p->tei == e->gen.tei) {
+  						if (p->call) {
+  							if (p->pri && p->pri->pri) {
+  								pri_hangup(p->pri->pri, p->call, -1, -1);
+  								pri_destroycall(p->pri->pri, p->call);
+  								p->call = NULL;
+  							} else
+  								ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
+  						}
+  						if (p->owner)
+  						    p->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+  						p->inalarm = 1;
+  						p->tei = -1;
+  					    }
+  					}
+  				    } 
+  				} else {
+  				    if (pri->nodetype == BRI_CPE_PTMP) {
+  					if (option_verbose > 3) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+  				    } else {
+  					if (option_verbose > 1) 
+  					    ast_verbose(VERBOSE_PREFIX_2 "%s D-Channel on span %d down\n", pri_order(which), pri->span);
+  				    }
+				    pri->dchanavail[which] &= ~DCHAN_UP;
+				    pri_find_dchan(pri);
+				    if (!pri_is_up(pri)) {
 					pri->resetting = 0;
 					/* Hangup active channels and put them in alarm mode */
 					for (i = 0; i < pri->numchans; i++) {
@@ -8527,12 +8943,13 @@ static void *pri_dchannel(void *vpri)
 								/* T309 is not enabled : hangup calls when alarm occurs */
 								if (p->call) {
 									if (p->pri && p->pri->pri) {
-										pri_hangup(p->pri->pri, p->call, -1);
+										pri_hangup(p->pri->pri, p->call, -1, -1);
 										pri_destroycall(p->pri->pri, p->call);
 										p->call = NULL;
 									} else
 										ast_log(LOG_WARNING, "The PRI Call have not been destroyed\n");
 								}
+  								p->tei = -1;
 								if (p->realcall) {
 									pri_hangup_all(p->realcall, pri);
 								} else if (p->owner)
@@ -8541,6 +8958,7 @@ static void *pri_dchannel(void *vpri)
 							p->inalarm = 1;
 						}
 					}
+				    }
 				}
 				break;
 			case PRI_EVENT_RESTART:
@@ -8575,8 +8993,8 @@ static void *pri_dchannel(void *vpri)
 								pri_destroycall(pri->pri, pri->pvts[x]->call);
 								pri->pvts[x]->call = NULL;
 							}
-							if (pri->pvts[chanpos]->realcall) 
-								pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
+							if (pri->pvts[x]->realcall) 
+								pri_hangup_all(pri->pvts[x]->realcall, pri);
  							else if (pri->pvts[x]->owner)
 								pri->pvts[x]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
 							ast_mutex_unlock(&pri->pvts[x]->lock);
@@ -8610,7 +9028,6 @@ static void *pri_dchannel(void *vpri)
 					}
 				}
 				break;
-				
 			case PRI_EVENT_INFO_RECEIVED:
 				chanpos = pri_find_principle(pri, e->ring.channel);
 				if (chanpos < 0) {
@@ -8619,9 +9036,11 @@ static void *pri_dchannel(void *vpri)
 				} else {
 					chanpos = pri_fixup_principle(pri, chanpos, e->ring.call);
 					if (chanpos > -1) {
+//					ast_log(LOG_NOTICE, "INFO received on  channel %d/%d span %d\n", 
+//						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						/* queue DTMF frame if the PBX for this call was already started (we're forwarding INFORMATION further on */
-						if (pri->overlapdial && pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
+						if (pri->pvts[chanpos]->call==e->ring.call && pri->pvts[chanpos]->owner) {
 							/* how to do that */
 							int digitlen = strlen(e->ring.callednum);
 							char digit;
@@ -8633,6 +9052,14 @@ static void *pri_dchannel(void *vpri)
 									zap_queue_frame(pri->pvts[chanpos], &f, pri);
 								}
 							}
+							if (!pri->overlapdial) {
+							    strncat(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
+							    if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+							    } else {
+								tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+							    }
+							} 
 						}
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					}
@@ -8640,36 +9067,59 @@ static void *pri_dchannel(void *vpri)
 				break;
 			case PRI_EVENT_RING:
 				crv = NULL;
-				if (e->ring.channel == -1)
+ 				if (e->ring.channel == -1) {
+ 					/* if no channel specified find one empty */
 					chanpos = pri_find_empty_chan(pri, 1);
-				else
+				} else {
 					chanpos = pri_find_principle(pri, e->ring.channel);
+				}
 				/* if no channel specified find one empty */
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Ring requested on unconfigured channel %d/%d span %d\n", 
-						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+ 					/* no channel specified and no free channel. this is a callwating SETUP */
+ 					if (e->ring.channel <= 0) {
+ 					    if (option_verbose > 2)
+ 						ast_verbose(VERBOSE_PREFIX_3 "Ignoring callwaiting SETUP on channel %d/%d span %d %d\n", PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span, e->ring.channel);
+ 					    pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_USER_BUSY, -1);
+ 					    break;
+ 					}
 				} else {
+					/* ok, we got a b channel for this call, lock it */
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
 					if (pri->pvts[chanpos]->owner) {
-						if (pri->pvts[chanpos]->call == e->ring.call) {
-							ast_log(LOG_WARNING, "Duplicate setup requested on channel %d/%d already in use on span %d\n", 
+					    /* safety check, for messed up retransmissions? */
+					    if (pri->pvts[chanpos]->call == e->ring.call) {
+						ast_log(LOG_WARNING, "Duplicate setup requested on channel %d/%d already in use on span %d\n", 
 								PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
-							break;
+						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+						chanpos = -1;
+						break;
+					    } else {
+ 						ast_log(LOG_WARNING, "Ring requested on channel %d/%d already in use on span %d. Hanging up owner.\n", 
+						PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
+						if (pri->pvts[chanpos]->realcall) {
+ 							pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
 						} else {
-							/* This is where we handle initial glare */
-							ast_log(LOG_DEBUG, "Ring requested on channel %d/%d already in use or previously requested on span %d.  Attempting to renegotiating channel.\n", 
-							PRI_SPAN(e->ring.channel), PRI_CHANNEL(e->ring.channel), pri->span);
-							ast_mutex_unlock(&pri->pvts[chanpos]->lock);
-							chanpos = -1;
+							pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+							/* XXX destroy the call here, so we can accept the retransmission as a new call */
+							pri_destroycall(pri->pri, e->ring.call);
 						}
-					}
-					if (chanpos > -1)
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+						chanpos = -1;
+						break;
+					    }
+					}
+ 					if (chanpos > -1) {
+						/* everything is ok with the b channel */
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					}
 				}
-				if ((chanpos < 0) && (e->ring.flexible))
-					chanpos = pri_find_empty_chan(pri, 1);
+ 				/* actually, we already got a valid channel by now */
 				if (chanpos > -1) {
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					/* dont detect dtmfs before the signalling is done */
+					disable_dtmf_detect(pri->pvts[chanpos]);
+					/* this channel is owned by this TEI */
+					pri->pvts[chanpos]->tei = e->ring.tei;
 					if (pri->switchtype == PRI_SWITCH_GR303_TMC) {
 						/* Should be safe to lock CRV AFAIK while bearer is still locked */
 						crv = pri_find_crv(pri, pri_get_crv(pri->pri, e->ring.call, NULL));
@@ -8683,13 +9133,14 @@ static void *pri_dchannel(void *vpri)
 								ast_log(LOG_WARNING, "Call received for busy CRV %d on span %d\n", pri_get_crv(pri->pri, e->ring.call, NULL), pri->span);
 							} else
 								ast_log(LOG_NOTICE, "Call received for unconfigured CRV %d on span %d\n", pri_get_crv(pri->pri, e->ring.call, NULL), pri->span);
-							pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_INVALID_CALL_REFERENCE);
+							pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_INVALID_CALL_REFERENCE, -1);
 							if (crv)
 								ast_mutex_unlock(&crv->lock);
 							ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 							break;
 						}
 					}
+  					/* assign call to b channel */
 					pri->pvts[chanpos]->call = e->ring.call;
 					apply_plan_to_number(plancallingnum, sizeof(plancallingnum), pri, e->ring.callingnum, e->ring.callingplan);
 					if (pri->pvts[chanpos]->use_callerid) {
@@ -8714,29 +9165,78 @@ static void *pri_dchannel(void *vpri)
 					}
 					apply_plan_to_number(pri->pvts[chanpos]->rdnis, sizeof(pri->pvts[chanpos]->rdnis), pri,
 							     e->ring.redirectingnum, e->ring.callingplanrdnis);
+  					/* get callingpres */
+  					pri->pvts[chanpos]->cid_pres = e->ring.callingpres;
+					switch (e->ring.callingpres) {
+					    case PRES_PROHIB_USER_NUMBER_NOT_SCREENED:
+					    case PRES_PROHIB_USER_NUMBER_PASSED_SCREEN:
+					    case PRES_PROHIB_USER_NUMBER_FAILED_SCREEN:
+					    case PRES_PROHIB_NETWORK_NUMBER:
+						strncpy(pri->pvts[chanpos]->cid_name, pri->withheldcid, sizeof(pri->pvts[chanpos]->cid_name));
+						break;
+					    case PRES_NUMBER_NOT_AVAILABLE:
+						strncpy(pri->pvts[chanpos]->cid_name, pri->nocid, sizeof(pri->pvts[chanpos]->cid_name));
+						break;
+					}
 					/* If immediate=yes go to s|1 */
 					if (pri->pvts[chanpos]->immediate) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of immediate=yes\n");
 						pri->pvts[chanpos]->exten[0] = 's';
 						pri->pvts[chanpos]->exten[1] = '\0';
-					}
-					/* Get called number */
-					else if (!ast_strlen_zero(e->ring.callednum)) {
-						ast_copy_string(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
-					} else
-						pri->pvts[chanpos]->exten[0] = '\0';
-					/* Set DNID on all incoming calls -- even immediate */
-					if (!ast_strlen_zero(e->ring.callednum))
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
-					/* No number yet, but received "sending complete"? */
-					if (e->ring.complete && (ast_strlen_zero(e->ring.callednum))) {
+  					} else if (ast_strlen_zero(e->ring.callednum)) {
+  					    /* called party number is empty */
+  					    if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+  						if (!pri->overlapdial) {
+  						    // be able to set digittimeout for BRI phones
+  						    pri->pvts[chanpos]->exten[0] = 's';
+  						    pri->pvts[chanpos]->exten[1] = '\0';
+  						    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  						} else {
+  						    pri->pvts[chanpos]->exten[0] = '\0';
+  						}
+  					    } else {
+  						if (pri->nodetype == BRI_CPE) { 
+  						    /* fix for .at p2p bri lines */
+  						    pri->pvts[chanpos]->exten[0] = 's';
+  						    pri->pvts[chanpos]->exten[1] = '\0';
+  						} else {
+  						    pri->pvts[chanpos]->exten[0] = '\0';
+  						}
+  					    }
+  					    /* No number yet, but received "sending complete"? */
+   					    if (e->ring.complete) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of Complete received\n");
 						pri->pvts[chanpos]->exten[0] = 's';
 						pri->pvts[chanpos]->exten[1] = '\0';
-					}
+ 					    }
+  					} else {
+  						/* Get called number */
+  						pri_make_callerid(pri, pri->pvts[chanpos]->dnid, sizeof(pri->pvts[chanpos]->dnid), e->ring.callednum, sizeof(e->ring.callednum),  e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+  						pri_make_callerid(pri, pri->pvts[chanpos]->exten, sizeof(pri->pvts[chanpos]->exten), e->ring.callednum, sizeof(e->ring.callednum), e->ring.calledplan, 0, pri->pvts[chanpos]->stripmsd);
+  						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+  						    /* if we get the next digit we should stop the dialtone */
+  						    if (!pri->overlapdial) {
+  							// with overlapdial=no the exten is always prefixed by "s"
+  							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten + 1)) {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+  							} else {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  							}
+  						    } else {
+  							if (!ast_ignore_pattern(pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten)) {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, -1);
+  							} else {
+  							    tone_zone_play_tone(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_TONE_DIALTONE);
+  							}
+  						    }
+  						}
+					}
+  					/* Part 3: create channel, setup audio... */
+ 					/* Set DNID on all incoming calls -- even immediate */
+ 					if (!ast_strlen_zero(e->ring.callednum))
+ 						strncpy(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid) - 1);
 					/* Make sure extension exists (or in overlap dial mode, can exist) */
 					if ((pri->overlapdial && ast_canmatch_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) ||
 						ast_exists_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) {
@@ -8755,19 +9255,36 @@ static void *pri_dchannel(void *vpri)
 						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
 						if (res < 0) 
 							ast_log(LOG_WARNING, "Unable to set law on channel %d\n", pri->pvts[chanpos]->channel);
-						res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						if (IS_DIGITAL(e->ring.ctype)) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						} else {
+ 						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+ 						}
 						if (res < 0)
 							ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", pri->pvts[chanpos]->channel);
-						if (e->ring.complete || !pri->overlapdial) {
+ 						if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+  						    if (e->ring.complete || !pri->overlapdial) {
 							/* Just announce proceeding */
 							pri->pvts[chanpos]->proceeding = 1;
 							pri_proceeding(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 0);
-						} else {
+						    } else {
 							if (pri->switchtype != PRI_SWITCH_GR303_TMC) 
 								pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
 							else
 								pri_answer(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+						    }
+						} else {
+ 							/* BRI_NETWORK | BRI_NETWORK_PTMP */
+ 							if (pri->overlapdial || (!strcasecmp(pri->pvts[chanpos]->exten, "s"))) {
+ 							    /* send a SETUP_ACKNOWLEDGE */
+ 							    pri_need_more_info(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+ 							} else {
+  							    /* send an ALERTING ??? wtf */
+ 							//    pri_acknowledge(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 1);
+ 							    pri_proceeding(pri->pri, e->ring.call, PVT_TO_CHANNEL(pri->pvts[chanpos]), 0);
+ 							}
 						}
+ 						/* overlapdial = yes  and the extension can be valid */
 						/* Get the use_callingpres state */
 						pri->pvts[chanpos]->callingpres = e->ring.callingpres;
 					
@@ -8779,14 +9296,31 @@ static void *pri_dchannel(void *vpri)
 								/* Set bearer and such */
 								pri_assign_bearer(crv, pri, pri->pvts[chanpos]);
 								c = zt_new(crv, AST_STATE_RESERVED, 0, SUB_REAL, law, e->ring.ctype);
+								if (c && (e->ring.lowlayercompat[0] > 0)) {
+								    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+								}
 								pri->pvts[chanpos]->owner = &inuse;
 								ast_log(LOG_DEBUG, "Started up crv %d:%d on bearer channel %d\n", pri->trunkgroup, crv->channel, crv->bearer->channel);
 							} else {
 								c = zt_new(pri->pvts[chanpos], AST_STATE_RESERVED, 0, SUB_REAL, law, e->ring.ctype);
+								if (c && (e->ring.lowlayercompat[0] > 0)) {
+								    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+								}
+ 								zt_enable_ec(pri->pvts[chanpos]);  /* XXX rethink */
 							}
 							if (!ast_strlen_zero(e->ring.callingsubaddr)) {
 								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
 							}
+ 					    		if (!ast_strlen_zero(e->ring.callingnum)) {
+ 							    char tmpstr[256];
+ 							    pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingnum, sizeof(e->ring.callingnum), e->ring.callingplan, e->ring.callingpres, 0);
+ 							    pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+ 							}
+ 							if (!ast_strlen_zero(e->ring.callingani)) {
+ 							    char tmpstr[256];
+ 							    pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingani, sizeof(e->ring.callingani), e->ring.callingplanuser, e->ring.callingpresuser, 0);
+ 							    pbx_builtin_setvar_helper(c, "PRI_USER_CID", tmpstr);
+ 							}
 							if (e->ring.ani2 >= 0) {
 								snprintf(ani2str, 5, "%.2d", e->ring.ani2);
 								pbx_builtin_setvar_helper(c, "ANI2", ani2str);
@@ -8808,8 +9342,8 @@ static void *pri_dchannel(void *vpri)
 							pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 							if (c && !ast_pthread_create(&threadid, &attr, ss_thread, c)) {
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap call from '%s' to '%s' on channel %d/%d, span %d\n",
-										plancallingnum, S_OR(pri->pvts[chanpos]->exten, "<unspecified>"),
+									ast_verbose(VERBOSE_PREFIX_3 "Accepting overlap %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+										pri->pvts[chanpos]->digital ? "data" : "voice", plancallingnum, S_OR(pri->pvts[chanpos]->exten, "<unspecified>"),
 										pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
@@ -8817,15 +9351,19 @@ static void *pri_dchannel(void *vpri)
 								if (c)
 									ast_hangup(c);
 								else {
-									pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION);
+									pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION, -1);
 									pri->pvts[chanpos]->call = NULL;
 								}
 							}
 							pthread_attr_destroy(&attr);
 						} else  {
+							/* overlapdial = no */    
 							ast_mutex_unlock(&pri->lock);
 							/* Release PRI lock while we create the channel */
 							c = zt_new(pri->pvts[chanpos], AST_STATE_RING, 1, SUB_REAL, law, e->ring.ctype);
+							if (c && (e->ring.lowlayercompat[0] > 0)) {
+							    memcpy(c->lowlayercompat, e->ring.lowlayercompat, sizeof(c->lowlayercompat));
+							}
 							ast_mutex_lock(&pri->lock);
 							if (c) {
 								char calledtonstr[10];
@@ -8846,23 +9384,40 @@ static void *pri_dchannel(void *vpri)
 								snprintf(calledtonstr, sizeof(calledtonstr)-1, "%d", e->ring.calledplan);
 								pbx_builtin_setvar_helper(c, "CALLEDTON", calledtonstr);
 								if (option_verbose > 2)
-									ast_verbose(VERBOSE_PREFIX_3 "Accepting call from '%s' to '%s' on channel %d/%d, span %d\n",
-										plancallingnum, pri->pvts[chanpos]->exten, 
+ 									ast_verbose(VERBOSE_PREFIX_3 "Accepting %s call from '%s' to '%s' on channel %d/%d, span %d\n",
+ 										pri->pvts[chanpos]->digital ? "data" : "voice", e->ring.callingnum, pri->pvts[chanpos]->exten, 
 											pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
 								zt_enable_ec(pri->pvts[chanpos]);
+ 							    if(!ast_strlen_zero(e->ring.callingsubaddr)) {
+ 								pbx_builtin_setvar_helper(c, "CALLINGSUBADDR", e->ring.callingsubaddr);
+ 							    }
+ 					    		    if (!ast_strlen_zero(e->ring.callingnum)) {
+ 								char tmpstr[256];
+ 							        pri_make_callerid(pri, tmpstr, sizeof(tmpstr), e->ring.callingnum, sizeof(e->ring.callingnum), e->ring.callingplan, e->ring.callingpres, 0);
+ 							        pbx_builtin_setvar_helper(c, "PRI_NETWORK_CID", tmpstr);
+ 							    }
+ 							    if (!ast_strlen_zero(e->ring.callingani)) {
+ 								char tmpstr[256];
+ 							        pri_make_callerid(pri, tmpstr,sizeof(tmpstr),  e->ring.callingani, sizeof(e->ring.callingani), e->ring.callingplanuser, e->ring.callingpresuser, 0);
+ 							        pbx_builtin_setvar_helper(c, "PRI_USER_CID", e->ring.callednum);
+ 							    }
+							    if (!ast_strlen_zero(e->ring.useruserinfo)) {
+							        pbx_builtin_setvar_helper(c, "UUI", e->ring.useruserinfo);
+							    }
 							} else {
 								ast_log(LOG_WARNING, "Unable to start PBX on channel %d/%d, span %d\n", 
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span);
-								pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION);
+								pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_SWITCH_CONGESTION, -1);
 								pri->pvts[chanpos]->call = NULL;
 							}
 						}
 					} else {
+					/* invalid extension */
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Extension '%s' in context '%s' from '%s' does not exist.  Rejecting call on channel %d/%d, span %d\n",
 								pri->pvts[chanpos]->exten, pri->pvts[chanpos]->context, pri->pvts[chanpos]->cid_num, pri->pvts[chanpos]->logicalspan, 
 									pri->pvts[chanpos]->prioffset, pri->span);
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED, -1);
 						pri->pvts[chanpos]->call = NULL;
 						pri->pvts[chanpos]->exten[0] = '\0';
 					}
@@ -8871,9 +9426,9 @@ static void *pri_dchannel(void *vpri)
 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 				} else {
 					if (e->ring.flexible)
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_NORMAL_CIRCUIT_CONGESTION, -1);
 					else
-						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_REQUESTED_CHAN_UNAVAIL);
+						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_REQUESTED_CHAN_UNAVAIL, -1);
 				}
 				break;
 			case PRI_EVENT_RINGING:
@@ -8889,7 +9444,7 @@ static void *pri_dchannel(void *vpri)
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (ast_strlen_zero(pri->pvts[chanpos]->dop.dialstr)) {
-							zt_enable_ec(pri->pvts[chanpos]);
+						// XXX	zt_enable_ec(pri->pvts[chanpos]);
 							pri->pvts[chanpos]->subs[SUB_REAL].needringing = 1;
 							pri->pvts[chanpos]->alerting = 1;
 						} else
@@ -8918,9 +9473,16 @@ static void *pri_dchannel(void *vpri)
 				}
 				break;
 			case PRI_EVENT_PROGRESS:
-				/* Get chan value if e->e is not PRI_EVNT_RINGING */
+				/* Get chan value if e->e is not PRI_EVENT_RINGING */
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
+				    if ((pri->pvts[chanpos]->priindication_oob == 2) && (e->proceeding.cause == PRI_CAUSE_USER_BUSY)) {
+					/* received PROGRESS with cause BUSY, no inband callprogress wanted => hang up! */
+					if (pri->pvts[chanpos]->owner) {
+					    pri->pvts[chanpos]->owner->hangupcause = AST_CAUSE_USER_BUSY;
+					    pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					}
+				    } else {
 #ifdef PRI_PROGRESS_MASK
 					if ((!pri->pvts[chanpos]->progress) || (e->proceeding.progressmask & PRI_PROG_INBAND_AVAILABLE)) {
 #else
@@ -8967,6 +9529,12 @@ static void *pri_dchannel(void *vpri)
 			case PRI_EVENT_PROCEEDING:
 				chanpos = pri_find_principle(pri, e->proceeding.channel);
 				if (chanpos > -1) {
+ 				    chanpos = pri_fixup_principle(pri, chanpos, e->proceeding.call);
+ 				    if (chanpos < 0) {
+ 					ast_log(LOG_WARNING, "Received PROCEEDING on channel %d/%d not in use on span %d\n", 
+						PRI_SPAN(e->proceeding.channel), PRI_CHANNEL(e->proceeding.channel), pri->span);
+ 					chanpos = -1;
+ 				    } else {
 					if (!pri->pvts[chanpos]->proceeding) {
 						struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_PROCEEDING, };
 						
@@ -9014,6 +9582,295 @@ static void *pri_dchannel(void *vpri)
 					}
 				}
 				break;				
+			case PRI_EVENT_SUSPEND_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->suspend_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Suspend requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (pri->pvts[chanpos]->owner) {
+					if (ast_bridged_channel(pri->pvts[chanpos]->owner)) {
+					    struct zt_suspended_call *zpc;
+					    char tmpstr[256];
+					    zpc = malloc(sizeof(struct zt_suspended_call));
+					    if (!zpc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_suspended_call\n");
+						break;
+					    }
+					    strncpy(zpc->msn,  pri->pvts[chanpos]->cid_num, sizeof(zpc->msn));
+					    strncpy(zpc->callid,  e->suspend_req.callid, sizeof(zpc->callid));
+					    ast_masq_park_call(ast_bridged_channel(pri->pvts[chanpos]->owner), NULL, 0, &zpc->parked_at);
+					    zpc->next = pri->suspended_calls;
+					    pri->suspended_calls = zpc;
+					    snprintf(tmpstr, sizeof(tmpstr), "Parked at %d", zpc->parked_at);
+					    pri_suspend_acknowledge(pri->pri, e->suspend_req.call,tmpstr);
+					    pri->pvts[chanpos]->call = NULL;
+					    pri->pvts[chanpos]->tei = -1;
+					    pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
+					} else {
+					    pri_suspend_reject(pri->pri, e->suspend_req.call, "cant park a non-bridge");
+					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    break;
+					}
+				    } else {
+					pri_suspend_reject(pri->pri, e->suspend_req.call, "");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_RESUME_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_resume_reject(pri->pri, e->resume_req.call,"All channels busy");
+					ast_log(LOG_WARNING, "Resume requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				} else if (!pri->pvts[chanpos]) {
+					pri_resume_reject(pri->pri, e->resume_req.call,"General protection fault in module 0x0BRI");
+					chanpos = -1;
+				}
+
+				if (chanpos > -1) {
+ 				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+				    if (!pri->pvts[chanpos]->owner) {
+					struct zt_suspended_call *zpc, *zpcl;
+					int unparked=0;
+					char extenstr[255], temp[255];
+					zpc = NULL;
+					zpcl = pri->suspended_calls;
+					while (zpcl) {
+					//    ast_log(LOG_NOTICE, "zpc->parked_at %d zpcl->callid %s\n",zpcl->parked_at, zpcl->callid);
+					    if (((strlen(zpcl->callid) == 0) && (strlen(e->resume_req.callid)==0)) || (!strcmp(zpcl->callid,e->resume_req.callid))) {
+						int law;
+						// found a parked call
+						snprintf(extenstr, sizeof(extenstr), "%d", zpcl->parked_at);
+						strncpy(pri->pvts[chanpos]->exten, extenstr, sizeof(pri->pvts[chanpos]->exten));
+					//	strncpy(pri->pvts[chanpos]->context, ast_parking_con(), sizeof(pri->pvts[chanpos]->context));
+					        pri->pvts[chanpos]->call = e->resume_req.call;
+ 					        law = 1;
+					        if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    	    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+						law = ZT_LAW_ALAW;
+						res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+						if (res < 0) 
+						    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						if (!pri->pvts[chanpos]->digital) {
+						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+  						} else {
+  						    res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, 0, 0, pri->pvts[chanpos]->law);
+						}
+						if (res < 0)
+						    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+						/* Start PBX */
+						c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 1, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+						if (c) {
+						    pri->pvts[chanpos]->owner = c;
+						    pri->pvts[chanpos]->call = e->resume_req.call;
+						    zt_enable_ec(pri->pvts[chanpos]);
+						    zt_train_ec(pri->pvts[chanpos]);
+						} else {
+						    ast_log(LOG_ERROR, "unable to start pbx\n");
+						}
+
+						if (zpc) {
+						    zpc->next = zpcl->next;
+						    free(zpcl);
+						    zpcl = zpc->next;
+						} else {
+						    // remove head
+						    pri->suspended_calls = zpcl->next;
+						    free(zpcl);
+						    zpcl = pri->suspended_calls;
+						    zpc = NULL;
+						}
+						unparked = 1;
+						snprintf(temp, sizeof(temp), "Unparked %s", extenstr);
+						pri_resume_acknowledge(pri->pri, e->resume_req.call, chanpos + 1, temp);
+					        break;
+					    }
+					    zpc = zpcl;
+					    if (zpcl) zpcl = zpcl->next;
+					}
+					if (!unparked)
+					    pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    } else {
+					pri_resume_reject(pri->pri, e->resume_req.call,"No suspended call to unpark!");
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
+				break;
+			case PRI_EVENT_HOLD_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_hold_reject(pri->pri, e->hold_req.call);
+				    break;
+				}
+				chanpos = pri_find_principle(pri, e->hold_req.channel);
+				if (chanpos < 0)  {
+					ast_log(LOG_WARNING, "Hold requested on unconfigured channel %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+				}
+				if (chanpos > -1) {
+				//    ast_log(LOG_NOTICE, "Hold request for channel number %d span %d\n", chanpos, pri->span);
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 				    if (pri->pvts[chanpos]->owner) {
+					struct zt_pvt *p = pri->pvts[chanpos];
+					struct zt_holded_call *zhc;
+					int holdacked=0;
+					
+//					ast_log(LOG_NOTICE,"HOLD request from channel %s tei %d\n",p->owner->name, e->hold_req.tei);
+				    	if (ast_bridged_channel(p->owner)) {
+					    zhc = malloc(sizeof(struct zt_holded_call));
+					    if (!zhc) {
+						ast_log(LOG_ERROR, "unable to malloc zt_holded_call\n");
+						break;
+					    }
+					    memset(zhc, 0, sizeof(zhc));
+					    strncpy(zhc->msn,  pri->pvts[chanpos]->cid_num, sizeof(zhc->msn));
+					    strncpy(zhc->uniqueid,  ast_bridged_channel(p->owner)->uniqueid, sizeof(zhc->uniqueid));
+					    zhc->tei = e->hold_req.tei;
+					    zhc->cref = e->hold_req.cref;
+					    zhc->call = e->hold_req.call;
+					    zhc->channel = p->owner;
+					    zhc->alreadyhungup = 0;
+					    zhc->bridge = ast_bridged_channel(p->owner);
+					    zhc->next = pri->holded_calls;
+					    pri->holded_calls = zhc;
+
+					    /* put channel on hold */
+					    ast_masq_hold_call(ast_bridged_channel(p->owner), p->owner);
+
+					    pri_hold_acknowledge(pri->pri, e->hold_req.call);
+					    holdacked = 1;
+					    p->call = NULL; // free the bchannel withouth destroying the call
+					    p->tei = -1;
+					} else {
+					    // cant hold a non-bridge,...yet
+					    
+					    // make a fake channel
+					    
+					    // masquerade
+					    
+					    // put on hold
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+					}
+				    } else {
+					    pri_hold_reject(pri->pri, e->hold_req.call);
+				    }
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				} else {
+					pri_hold_reject(pri->pri, e->hold_req.call);
+				}
+				break; 
+			case PRI_EVENT_RETRIEVE_REQ:
+				if ((pri->nodetype != BRI_NETWORK_PTMP) && (pri->nodetype != BRI_NETWORK)) {
+				    pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    break;
+				}
+				chanpos = pri_find_empty_chan(pri, 1);
+				if (chanpos < 0) { 
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					ast_log(LOG_WARNING, "Retrieve requested on odd channel number %d span %d\n", chanpos, pri->span);
+					chanpos = -1;
+					break;
+				} else if (!pri->pvts[chanpos]) {
+					ast_log(LOG_WARNING, "Retrieve requested on unconfigured channel number %d span %d\n", chanpos, pri->span);
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					chanpos = -1;
+					break;
+				}
+				if (chanpos > -1) {
+				    struct zt_holded_call *onhold = NULL;
+				    int retrieved = 0;
+				    int res = -1;
+				    struct app_tmp *tmp;
+				    pthread_attr_t attr;
+				    int law;
+
+				    onhold = pri_get_callonhold(pri, e->retrieve_req.cref, e->retrieve_req.tei);
+
+				    if (!onhold) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+					break;
+				    }
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					// found a parked call
+ 					law = 1;
+					if (ioctl(pri->pvts[chanpos]->subs[SUB_REAL].zfd, ZT_AUDIOMODE, &law) == -1)
+					    ast_log(LOG_WARNING, "Unable to set audio mode on channel %d to %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]), law);
+					// uhh ohh...what shall we do without the bearer cap???
+					law = ZT_LAW_ALAW;
+					res = zt_setlaw(pri->pvts[chanpos]->subs[SUB_REAL].zfd, law);
+					if (res < 0) 
+					    ast_log(LOG_WARNING, "Unable to set law on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					res = set_actual_gain(pri->pvts[chanpos]->subs[SUB_REAL].zfd, 0, pri->pvts[chanpos]->rxgain, pri->pvts[chanpos]->txgain, law);
+					if (res < 0)
+					    ast_log(LOG_WARNING, "Unable to set gains on channel %d\n", PVT_TO_CHANNEL(pri->pvts[chanpos]));
+					/* Start PBX */
+					c = zt_new(pri->pvts[chanpos], AST_STATE_UP, 0, SUB_REAL, law, PRI_TRANS_CAP_SPEECH);
+					if (c) {
+					    pri->pvts[chanpos]->owner = c;
+					    pri->pvts[chanpos]->outgoing = 1; /* for not sending proceedings... */
+					    pri->pvts[chanpos]->call = e->retrieve_req.call;
+					    pri->pvts[chanpos]->tei = e->retrieve_req.tei;
+				    	    zt_enable_ec(pri->pvts[chanpos]);
+				    	    zt_train_ec(pri->pvts[chanpos]);
+					} else {
+					    ast_log(LOG_ERROR, "unable to start pbx\n");
+					}
+
+					retrieved = 1;
+				//	ast_log(LOG_NOTICE, "sending RETRIEVE ACK on channel %d, span %d for tei %d cref %d\n",chanpos,pri->span, e->retrieve_req.tei,  e->retrieve_req.cref);
+					pri_retrieve_acknowledge(pri->pri, e->retrieve_req.call, chanpos + 1);
+
+					// the magic begins here: ....
+					tmp = malloc(sizeof(struct app_tmp));
+					if (tmp) {
+					    memset(tmp, 0, sizeof(struct app_tmp));
+					    strncpy(tmp->app, "holdedcall", sizeof(tmp->app) - 1);
+					    strncpy(tmp->data, onhold->uniqueid, sizeof(tmp->data) - 1);
+					    tmp->chan = c;
+					}
+					pri_destroy_callonhold(pri, onhold);
+					onhold = NULL;
+
+					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					pthread_attr_init(&attr);
+					pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+					if (ast_pthread_create(&tmp->t, &attr, ast_pbx_run_app, tmp)) {
+ 					    ast_log(LOG_WARNING, "Unable to spawn execute thread on %s: %s\n", c->name, strerror(errno));
+					    free(tmp);
+					    ast_hangup(c);
+					    retrieved = 0;
+					}
+
+				    if (!retrieved) {
+					pri_retrieve_reject(pri->pri, e->retrieve_req.call);
+				    }
+				}
+ 				break; 
+			case PRI_EVENT_DISPLAY_RECEIVED:
+				ast_log(LOG_NOTICE, "DISPLAY IE: [ %s ] received\n",e->display.text);
+				chanpos = pri_find_principle(pri, e->display.channel);
+				if (chanpos < 0) {
+				    ast_log(LOG_WARNING, "odd channel number %d span %d\n", chanpos, pri->span);
+				    chanpos = -1;
+				} 
+				if (chanpos > -1) {
+				    if (pri->pvts[chanpos]->owner) {
+			//		ast_sendtext(pri->pvt[chanpos]->owner, e->display.text);
+				    }
+				}				
+				break;
 			case PRI_EVENT_ANSWER:
 				chanpos = pri_find_principle(pri, e->answer.channel);
 				if (chanpos < 0) {
@@ -9026,6 +9883,7 @@ static void *pri_dchannel(void *vpri)
 							PRI_SPAN(e->answer.channel), PRI_CHANNEL(e->answer.channel), pri->span);
 					} else {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
+  						pri->pvts[chanpos]->tei = e->answer.tei;
 						/* Now we can do call progress detection */
 
 						/* We changed this so it turns on the DSP no matter what... progress or no progress.
@@ -9055,11 +9913,16 @@ static void *pri_dchannel(void *vpri)
 								ast_log(LOG_DEBUG, "Sent deferred digit string: %s\n", pri->pvts[chanpos]->dop.dialstr);
 							pri->pvts[chanpos]->dop.dialstr[0] = '\0';
 						} else if (pri->pvts[chanpos]->confirmanswer) {
-							ast_log(LOG_DEBUG, "Waiting on answer confirmation on channel %d!\n", pri->pvts[chanpos]->channel);
+							ast_log(LOG_DEBUG, "Waiting for answer confirmation on channel %d!\n", pri->pvts[chanpos]->channel);
+							enable_dtmf_detect(pri->pvts[chanpos]);
 						} else {
+							pri->pvts[chanpos]->dialing = 0;
 							pri->pvts[chanpos]->subs[SUB_REAL].needanswer =1;
 							/* Enable echo cancellation if it's not on already */
 							zt_enable_ec(pri->pvts[chanpos]);
+							zt_train_ec(pri->pvts[chanpos]);
+							/* stop ignoring inband dtmf */
+							enable_dtmf_detect(pri->pvts[chanpos]);
 						}
 
 #ifdef SUPPORT_USERUSER
@@ -9113,20 +9976,29 @@ static void *pri_dchannel(void *vpri)
 								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d got hangup, cause %d\n", 
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, e->hangup.cause);
 						} else {
-							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
+							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
 							pri->pvts[chanpos]->call = NULL;
+							pri->pvts[chanpos]->tei = -1;
 						}
 						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
+ 							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+							    if (option_verbose > 2)
 								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d on span %d since channel reported in use\n", 
-									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
-						}
-						if (e->hangup.aoc_units > -1)
+ 									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+							    pri->pvts[chanpos]->resetting = 1;
+ 							}
+						}
+ 						if (e->hangup.aoc_units > -1) {
+							if (pri->pvts[chanpos]->owner) {
+							    char tmpstr[256];
+							    snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+							    pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+							}
 							if (option_verbose > 2)
 								ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
 									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+						}
 
 #ifdef SUPPORT_USERUSER
 						if (!ast_strlen_zero(e->hangup.useruserinfo)) {
@@ -9136,8 +10008,20 @@ static void *pri_dchannel(void *vpri)
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
-							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						struct zt_holded_call *onhold = NULL;
+						/* check calls on hold */
+ 						onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+ 						
+ 						if (onhold) {
+ 						    // ast_log(LOG_NOTICE, "hangup, found cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+ 						    pri_destroy_callonhold(pri, onhold);
+ 						    onhold = NULL;
+ 						} else {
+ 						    ast_log(LOG_NOTICE, "Hangup, did not find cref %d, tei %d\n",e->hangup.cref, e->hangup.tei);
+ 						    ast_log(LOG_WARNING, "Hangup on bad channel %d/%d on span %d\n", 
+  							PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						}
 					}
 				} 
 				break;
@@ -9147,15 +10031,23 @@ static void *pri_dchannel(void *vpri)
 			case PRI_EVENT_HANGUP_REQ:
 				chanpos = pri_find_principle(pri, e->hangup.channel);
 				if (chanpos < 0) {
-					ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
-						PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-				} else {
+					if (pri->nodetype == BRI_NETWORK_PTMP) {
+					    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause, -1);
+					} else {
+					    ast_log(LOG_WARNING, "Hangup REQ requested on unconfigured channel %d/%d span %d\n", 
+  						PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+					}
+				} else if ((pri->pvts[chanpos]->priindication_oob != 2) || (!e->hangup.inband_progress) || (!pri->pvts[chanpos]->outgoing)) {
+								    /* dont hang up if we want to hear inband call progress */
 					chanpos = pri_fixup_principle(pri, chanpos, e->hangup.call);
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						if (pri->pvts[chanpos]->realcall) 
 							pri_hangup_all(pri->pvts[chanpos]->realcall, pri);
 						else if (pri->pvts[chanpos]->owner) {
+							char tmpstr[256];
+							snprintf(tmpstr, sizeof(tmpstr), "%d", e->hangup.cause);
+							pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "PRI_CAUSE", tmpstr);
 							pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
 							if (pri->pvts[chanpos]->owner->_state == AST_STATE_UP)
 								pri->pvts[chanpos]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
@@ -9182,16 +10074,86 @@ static void *pri_dchannel(void *vpri)
 								if (option_verbose > 2)
 									ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
 										pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+							if (e->hangup.aoc_units > -1) {
+							    if (pri->pvts[chanpos]->owner) {
+								char tmpstr[256];
+								snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+								pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+							    }
+							    if (option_verbose > 2)
+							    	ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
+									pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+							}
+ 							if (pri->nodetype == BRI_NETWORK_PTMP) {
+							    // check for bri transfers, not everybody uses ECT...
+ 							    if (pri->pvts[chanpos]->owner) {
+ 								// find on hold call
+								struct zt_holded_call *onhold = NULL;
+ 								struct ast_channel *transferee = NULL;
+								int transfer_ok = 0;
+ 
+ 								onhold = pri_get_callonhold(pri, -1, e->hangup.tei);
+ 
+ 								if (onhold) {
+								    if (pri->pvts[chanpos]->pritransfer == 2) {
+ 									if (((pri->pvts[chanpos]->owner->_state != AST_STATE_RING) && (pri->pvts[chanpos]->owner->_state != AST_STATE_RESERVED)) || ((!ast_strlen_zero(pri->pvts[chanpos]->exten)) && (strncasecmp(pri->pvts[chanpos]->exten, "s", sizeof(pri->pvts[chanpos]->exten))))) {
+ 								    	    transferee = ast_get_holded_call(onhold->uniqueid);
+ 
+ 									    if (transferee) {
+ 										if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+ 									    	    ast_indicate(transferee, AST_CONTROL_RINGING);
+ 										}
+ 
+ 										pri->pvts[chanpos]->owner->_softhangup &= ~AST_SOFTHANGUP_DEV;
+  
+  									        ast_mutex_unlock(&transferee->lock);
+ 										if (ast_channel_masquerade(pri->pvts[chanpos]->owner, transferee)) {
+ 										    ast_log(LOG_WARNING, "unable to masquerade\n");
+ 									        } else { 
+ 									    	    /* beware of zombies!!! */
+										    ast_set_flag(transferee, AST_FLAG_ZOMBIE);
+ 										    pri->pvts[chanpos]->owner = NULL;
+ 										    pri->pvts[chanpos]->tei = -1;
+										    transfer_ok = 1;
+ 										}
+ 									    }
+									}	
+ 								    } else if (pri->pvts[chanpos]->pritransfer == 0) {
+									ast_log(LOG_NOTICE, "killing channel %s \n", onhold->uniqueid);
+ 									ast_retrieve_call_to_death(onhold->uniqueid);
+									transfer_ok = 1;
+ 								    } else if (pri->pvts[chanpos]->pritransfer == 1) {
+									/* we use ECT transfers, so just ignore this */
+									transfer_ok = 0;
+								    }
+							
+								    if (transfer_ok) {
+ 									onhold->alreadyhungup = 1;	
+ 									pri_hangup(pri->pri, onhold->call, e->hangup.cause, -1);
+ 									onhold = NULL;
+								    }
+ 								    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 								    break;
+                                                        	} else {
+                                                                    pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
+                                                                        pri->pvts[chanpos]->call = NULL;
+                                                                        pri->pvts[chanpos]->tei = -1;
+                                                                }
+  							    }
+  							}
 						} else {
-							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause);
+							pri_hangup(pri->pri, pri->pvts[chanpos]->call, e->hangup.cause, -1);
 							pri->pvts[chanpos]->call = NULL;
+ 							pri->pvts[chanpos]->tei = -1;
 						}
 						if (e->hangup.cause == PRI_CAUSE_REQUESTED_CHAN_UNAVAIL) {
-							if (option_verbose > 2)
+ 							if ((pri->nodetype != BRI_CPE_PTMP) && (pri->nodetype != BRI_NETWORK_PTMP)) {
+							    if (option_verbose > 2)
 								ast_verbose(VERBOSE_PREFIX_3 "Forcing restart of channel %d/%d span %d since channel reported in use\n", 
 									PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
-							pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
-							pri->pvts[chanpos]->resetting = 1;
+							    pri_reset(pri->pri, PVT_TO_CHANNEL(pri->pvts[chanpos]));
+							    pri->pvts[chanpos]->resetting = 1;
+							}
 						}
 
 #ifdef SUPPORT_USERUSER
@@ -9202,9 +10164,39 @@ static void *pri_dchannel(void *vpri)
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 					} else {
-						ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						if (pri->nodetype != BRI_NETWORK_PTMP) {
+  						    ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						} else {
+ 						    // check holded_calls!!!
+ 						    struct zt_holded_call *onhold = NULL;
+ 
+ 						    onhold = pri_get_callonhold(pri, e->hangup.cref, e->hangup.tei);
+ 
+ 						    if (onhold) {
+ 							    pri_hangup(pri->pri, e->hangup.call, e->hangup.cause, -1);
+ 							    ast_retrieve_call_to_death(onhold->uniqueid);
+ 							    pri_destroy_callonhold(pri, onhold);
+ 							    onhold = NULL;
+ 						    } else {
+ 							ast_log(LOG_WARNING, "Hangup REQ on bad channel %d/%d on span %d\n", PRI_SPAN(e->hangup.channel), PRI_CHANNEL(e->hangup.channel), pri->span);
+ 						    }
+ 						}
 					}
 				} 
+				if ((chanpos > -1) && (pri->pvts[chanpos]->owner) && (pri->pvts[chanpos]->priindication_oob == 2) && (e->hangup.inband_progress) && (pri->pvts[chanpos]->outgoing)) {
+				    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+					if (e->hangup.aoc_units > -1) {
+					    char tmpstr[256];
+					    snprintf(tmpstr, sizeof(tmpstr), "%d", (int)e->hangup.aoc_units);
+					    pbx_builtin_setvar_helper(pri->pvts[chanpos]->owner, "AOCEUNITS", tmpstr);
+					    if (option_verbose > 2)
+						ast_verbose(VERBOSE_PREFIX_3 "Channel %d/%d, span %d received AOC-E charging %d unit%s\n",
+						    pri->pvts[chanpos]->logicalspan, pri->pvts[chanpos]->prioffset, pri->span, (int)e->hangup.aoc_units, (e->hangup.aoc_units == 1) ? "" : "s");
+					}
+					pri->pvts[chanpos]->owner->hangupcause = e->hangup.cause;
+					ast_channel_setwhentohangup(pri->pvts[chanpos]->owner, 5);
+				    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+				}
 				break;
 			case PRI_EVENT_HANGUP_ACK:
 				chanpos = pri_find_principle(pri, e->hangup.channel);
@@ -9216,6 +10208,7 @@ static void *pri_dchannel(void *vpri)
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						pri->pvts[chanpos]->call = NULL;
+						pri->pvts[chanpos]->tei = -1;
 						pri->pvts[chanpos]->resetting = 0;
 						if (pri->pvts[chanpos]->owner) {
 							if (option_verbose > 2) 
@@ -9229,7 +10222,9 @@ static void *pri_dchannel(void *vpri)
 #endif
 
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+					    }
 					}
+				    }
 				}
 				break;
 			case PRI_EVENT_CONFIG_ERR:
@@ -9319,10 +10314,22 @@ static void *pri_dchannel(void *vpri)
 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
 					switch (e->notify.info) {
 					case PRI_NOTIFY_REMOTE_HOLD:
+						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						    ast_log(LOG_DEBUG, "Received REMOTE_HOLD notification on NETWORK channel. Starting MoH\n");
+						    ast_moh_start(ast_bridged_channel(pri->pvts[chanpos]->owner), NULL, pri->pvts[chanpos]->mohinterpret);
+						} else {
+						    ast_log(LOG_DEBUG, "Received REMOTE_HOLD notification on CPE channel. Not Starting MoH\n");
+						}
 						f.subclass = AST_CONTROL_HOLD;
 						zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						break;
 					case PRI_NOTIFY_REMOTE_RETRIEVAL:
+						if ((pri->nodetype == BRI_NETWORK_PTMP) || (pri->nodetype == BRI_NETWORK)) {
+						    ast_log(LOG_DEBUG, "Received REMOTE_RETRIEVAL notification on NETWORK channel. Stopping MoH\n");
+						    ast_moh_stop(ast_bridged_channel(pri->pvts[chanpos]->owner));
+						} else {
+						    ast_log(LOG_DEBUG, "Received REMOTE_RETRIEVAL notification on CPE channel.\n");
+						}
 						f.subclass = AST_CONTROL_UNHOLD;
 						zap_queue_frame(pri->pvts[chanpos], &f, pri);
 						break;
@@ -9330,6 +10337,77 @@ static void *pri_dchannel(void *vpri)
 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
 				}
 				break;
+ 			case PRI_EVENT_FACILITY:
+ 				    if (e->facility.operation == 0x06) {
+ 					struct ast_channel *chan = NULL;
+ 					struct zt_holded_call *onhold = NULL;
+ 					if (option_verbose > 2) {
+ 					    ast_verbose(VERBOSE_PREFIX_3 "ECT requested by TEI %d for cref %d\n", e->facility.tei, e->facility.cref);
+ 					}
+ 					/* search for cref/tei in held calls */
+ 					onhold = pri_get_callonhold(pri, e->facility.cref, e->facility.tei);
+ 					if (onhold) {
+ 					    chan = ast_get_holded_call(onhold->uniqueid);
+ 					    onhold->alreadyhungup = 1;
+ 					    onhold = NULL;
+ 					    if (!chan) {
+ 						/* hang up */
+ 					        pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 						break;
+ 					    }
+ 					} else {
+ 					    /* unknown cref/tei */
+ 					    ast_log(LOG_WARNING, "did not find call on hold for cref %d tei %d\n", e->facility.tei, e->facility.cref);
+ 					    /* hang up */
+ 					    pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 					    break;
+ 					}
+ 
+ 					/* find an active call for the same tei */
+ 					chanpos = pri_find_tei(pri, e->facility.call, e->facility.tei);
+ 					if (chanpos < 0) {
+ 					    /* did not find active call, hangup call on hold */
+ 					    if (chan) {
+ 						ast_hangup(chan);
+ 						chan = NULL;
+ 					    }
+ 					} else {
+ 					    ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 					    /* transfer */
+ 					    if (pri->pvts[chanpos]->owner) {
+ 						if (option_verbose > 3) {
+ 						    ast_verbose(VERBOSE_PREFIX_3 "ECT: found %s on channel %d for tei %d\n", pri->pvts[chanpos]->owner->name ,chanpos, e->facility.tei);
+ 						}
+ 						/* pass callprogress if the channel is not up yet */
+ 						if (pri->pvts[chanpos]->owner->_state == AST_STATE_RINGING) {
+ 						    ast_indicate(chan, AST_CONTROL_RINGING);
+ 						}
+ 						/* unlock the channel we removed from hold */
+ 						ast_mutex_unlock(&chan->lock);
+ 						if (ast_channel_masquerade(pri->pvts[chanpos]->owner, chan)) {
+ 					    	    ast_log(LOG_WARNING, "unable to masquerade\n");
+ 						} else {
+ 						    /* beware of zombies !!! */
+						    ast_set_flag(chan, AST_FLAG_ZOMBIE);
+ 						//    chan->zombie = 1;
+ 						}
+ 					    }
+ 					    ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 					}
+					/* disconnect */
+ 					pri_hangup(pri->pri, e->facility.call, 16, -1);
+ 				    } else if (e->facility.operation == 0x0D) {
+ 					ast_log(LOG_NOTICE, "call deflection to %s requested.\n", e->facility.forwardnum);
+ 					ast_mutex_lock(&pri->pvts[chanpos]->lock);
+ 					    /* transfer */
+ 					    if (pri->pvts[chanpos]->owner) {
+						snprintf(pri->pvts[chanpos]->owner->call_forward, sizeof(pri->pvts[chanpos]->owner->call_forward), "Local/%s@%s", e->facility.forwardnum, pri->pvts[chanpos]->owner->context);
+ 					    }
+ 					ast_mutex_unlock(&pri->pvts[chanpos]->lock);
+ 				    } else {
+ 					ast_log(LOG_WARNING, "Unknown facility operation %#x requested.\n", e->facility.operation);
+ 				    }
+ 				break;
 			default:
 				ast_log(LOG_DEBUG, "Event: %d\n", e->e);
 			}
@@ -9391,7 +10469,7 @@ static int start_pri(struct zt_pri *pri)
 			pri->fds[i] = -1;
 			return -1;
 		}
-		pri->dchans[i] = pri_new(pri->fds[i], pri->nodetype, pri->switchtype);
+		pri->dchans[i] = pri_new(pri->fds[i], pri->nodetype, pri->switchtype, pri->span);
 		/* Force overlap dial if we're doing GR-303! */
 		if (pri->switchtype == PRI_SWITCH_GR303_TMC)
 			pri->overlapdial = 1;
@@ -9459,39 +10537,77 @@ static char *complete_span_5(const char 
 
 static int handle_pri_set_debug_file(int fd, int argc, char **argv)
 {
-	int myfd;
+ 	int myfd, x, d;
+ 	int span;
+ 
+ 	if (argc < 6) 
+ 		return RESULT_SHOWUSAGE;
 
 	if (!strncasecmp(argv[1], "set", 3)) {
-		if (argc < 5) 
+		if (argc < 7) 
 			return RESULT_SHOWUSAGE;
 
-		if (ast_strlen_zero(argv[4]))
+		if (!argv[4] || ast_strlen_zero(argv[4]))
 			return RESULT_SHOWUSAGE;
 
+ 		if (!argv[5])
+ 			return RESULT_SHOWUSAGE;
+ 
+ 		if (!argv[6] || ast_strlen_zero(argv[6]))
+ 			return RESULT_SHOWUSAGE;
+ 
+ 		span = atoi(argv[6]);
+ 		if ((span < 1) && (span > NUM_SPANS)) {
+ 			return RESULT_SUCCESS;
+ 		}
+ 		
+
 		myfd = open(argv[4], O_CREAT|O_WRONLY);
 		if (myfd < 0) {
-			ast_cli(fd, "Unable to open '%s' for writing\n", argv[4]);
-			return RESULT_SUCCESS;
+ 		    ast_cli(fd, "Unable to open '%s' for writing\n", argv[4]);
+ 		    return RESULT_SUCCESS;
 		}
-
-		ast_mutex_lock(&pridebugfdlock);
-
-		if (pridebugfd >= 0)
-			close(pridebugfd);
-
-		pridebugfd = myfd;
-		ast_copy_string(pridebugfilename,argv[4],sizeof(pridebugfilename));
-		
-		ast_mutex_unlock(&pridebugfdlock);
-
-		ast_cli(fd, "PRI debug output will be sent to '%s'\n", argv[4]);
+ 		for (x=0; x < NUM_SPANS; x++) {
+ 	    	    ast_mutex_lock(&pris[x].lock);
+ 		    
+ 		    if (pris[x].span == span) {
+ 			if (pris[x].debugfd >= 0)
+ 			    close(pris[x].debugfd);
+ 			pris[x].debugfd = myfd;
+ 			for (d=0; d < NUM_DCHANS; d++) {
+ 			    if (pris[x].dchans[d])
+ 				pri_set_debug_fd(pris[x].dchans[d], myfd);
+ 			}
+ 		    }
+ 	    	    ast_mutex_unlock(&pris[x].lock);
+ 		}
+  
+ 		ast_cli(fd, "PRI debug output for span %d will be sent to '%s'\n", span, argv[4]);
 	} else {
+ 		if (!argv[5] || ast_strlen_zero(argv[5]))
+ 			return RESULT_SHOWUSAGE;
 		/* Assume it is unset */
-		ast_mutex_lock(&pridebugfdlock);
-		close(pridebugfd);
-		pridebugfd = -1;
-		ast_cli(fd, "PRI debug output to file disabled\n");
-		ast_mutex_unlock(&pridebugfdlock);
+		span = atoi(argv[5]);
+ 		if ((span < 1) && (span > NUM_SPANS)) {
+ 			return RESULT_SUCCESS;
+ 		}
+ 
+ 		for (x=0; x < NUM_SPANS; x++) {
+ 	    	    ast_mutex_lock(&pris[x].lock);
+ 		    
+ 		    if (pris[x].span == span) {
+ 			if (pris[x].debugfd >= 0)
+ 			    close(pris[x].debugfd);
+ 			pris[x].debugfd = -1;
+ 			for (d=0; d < NUM_DCHANS; d++) {
+ 			    if (pris[x].dchans[d])
+ 				pri_set_debug_fd(pris[x].dchans[d], -1);
+ 			}
+ 		    }
+ 	    	    ast_mutex_unlock(&pris[x].lock);
+ 		}
+ 
+ 		ast_cli(fd, "PRI debug output to file for span %d disabled\n", span);
 	}
 
 	return RESULT_SUCCESS;
@@ -9525,6 +10641,7 @@ static int handle_pri_debug(int fd, int 
 
 
 
+
 static int handle_pri_no_debug(int fd, int argc, char *argv[])
 {
 	int span;
@@ -9674,10 +10791,6 @@ static int handle_pri_show_debug(int fd,
 		}
 
 	}
-	ast_mutex_lock(&pridebugfdlock);
-	if (pridebugfd >= 0) 
-		ast_cli(fd, "Logging PRI debug to file %s\n", pridebugfilename);
-	ast_mutex_unlock(&pridebugfdlock);
 	    
 	if (!count) 
 		ast_cli(fd, "No debug set or no PRI running\n");
@@ -9704,6 +10817,18 @@ static const char pri_show_spans_help[] 
 	"Usage: pri show spans\n"
 	"       Displays PRI Information\n";
 
+static char bri_debug_help[] = 
+	"Usage: bri debug span <span>\n"
+	"       Enables debugging on a given BRI span\n";
+	
+static char bri_no_debug_help[] = 
+	"Usage: bri no debug span <span>\n"
+	"       Disables debugging on a given BRI span\n";
+
+static char bri_really_debug_help[] = 
+	"Usage: bri intensive debug span <span>\n"
+	"       Enables debugging down to the Q.921 level\n";
+
 static struct ast_cli_entry zap_pri_cli[] = {
 	{ { "pri", "debug", "span", NULL },
 	handle_pri_debug, "Enables PRI debugging on a span",
@@ -9728,6 +10853,15 @@ static struct ast_cli_entry zap_pri_cli[
 	{ { "pri", "show", "debug", NULL },
 	handle_pri_show_debug, "Displays current PRI debug settings" },
 
+	{ { "bri", "debug", "span", NULL }, handle_pri_debug,
+	  "Enables BRI debugging on a span", bri_debug_help, complete_span_4 },
+
+	{ { "bri", "no", "debug", "span", NULL }, handle_pri_no_debug,
+	  "Disables BRI debugging on a span", bri_no_debug_help, complete_span_5 },
+
+	{ { "bri", "intense", "debug", "span", NULL }, handle_pri_really_debug,
+	  "Enables REALLY INTENSE BRI debugging", bri_really_debug_help, complete_span_5 },
+
 	{ { "pri", "set", "debug", "file", NULL },
 	handle_pri_set_debug_file, "Sends PRI debug output to the specified file" },
 
@@ -9735,8 +10869,76 @@ static struct ast_cli_entry zap_pri_cli[
 	handle_pri_set_debug_file, "Ends PRI debug output to file" },
 };
 
+static char *zapCD_tdesc = "Call Deflection";
+static char *zapCD_app = "zapCD";
+static char *zapCD_synopsis = "Call Deflection";
+
+static int app_zapCD(struct ast_channel *chan, void *data)
+{
+ struct zt_pvt *p = chan->tech_pvt;
+
+ if((!p->pri) || (!p->pri->pri)) {
+	return -1;
+ }
+
+ if(!data) {
+     ast_log(LOG_WARNING, "zapCD wants a number to deflect to\n");
+	return -1;
+ }
+ return pri_deflect(p->pri->pri, p->call, data);
+}
+
+static char *zapInband_tdesc = "Inband Call Progress (pre-answer)";
+static char *zapInband_app = "zapInband";
+static char *zapInband_synopsis = "Inband Call Progress";
+
+static int app_zapInband(struct ast_channel *chan, void *data)
+{
+ struct zt_pvt *p = chan->tech_pvt;
+
+ return pri_acknowledge(p->pri->pri, p->call, PVT_TO_CHANNEL(p), 1);
+}
+
 #endif /* HAVE_PRI */
 
+static int app_zapEC(struct ast_channel *chan, void *data)
+{
+ int res=-1;
+ struct zt_pvt *p = NULL;
+
+ if (!data) {
+	ast_log(LOG_WARNING, "zapEC requires one argument (on | off)\n");
+ }
+ if (chan && !strcasecmp("ZAP",chan->tech->type)) {
+	p = chan->tech_pvt;
+	if (!p) return res;
+	if (!strcasecmp("on",(char *)data)) {
+	    zt_enable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Enabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else if (!strcasecmp("off",(char *)data)) {
+	    zt_disable_ec(p);
+	    res = 0;
+	    if (option_verbose > 3) {
+		ast_verbose(VERBOSE_PREFIX_3 "Disabled echo cancelation on channel %s.\n", chan->name);
+	    }
+	} else {
+ 	    ast_log(LOG_WARNING, "Unknown argument %s to zapEC\n", (char *)data);
+	}
+ } else {
+  ast_log(LOG_WARNING, "zapNoEC only works on ZAP channels, check your extensions.conf!\n");
+  res = 0;
+ }
+
+ return res;
+}
+
+static char *zapEC_tdesc = "Enable/disable Echo cancelation";
+static char *zapEC_app = "zapEC";
+static char *zapEC_synopsis = "Enable/Disable Echo Cancelation on a Zap channel";
+
 static int zap_destroy_channel(int fd, int argc, char **argv)
 {
 	int channel;
@@ -10316,8 +11518,11 @@ static int __unload_module(void)
 	}
 	ast_cli_unregister_multiple(zap_pri_cli, sizeof(zap_pri_cli) / sizeof(struct ast_cli_entry));
 	ast_unregister_application(zap_send_keypad_facility_app);
+	ast_unregister_application(zapCD_app);
+	ast_unregister_application(zapInband_app);
 #endif
 	ast_cli_unregister_multiple(zap_cli, sizeof(zap_cli) / sizeof(struct ast_cli_entry));
+	ast_unregister_application(zapEC_app);
 	ast_manager_unregister( "ZapDialOffhook" );
 	ast_manager_unregister( "ZapHangup" );
 	ast_manager_unregister( "ZapTransfer" );
@@ -10819,6 +12024,22 @@ static int process_zap(struct zt_chan_co
 					confp->chan.sig = SIG_GR303FXSKS;
 					confp->chan.radio = 0;
 					confp->pri.nodetype = PRI_CPE;
+ 				} else if (!strcasecmp(v->value, "bri_net_ptmp")) {
+ 					confp->chan.radio = 0;
+ 					confp->chan.sig = SIG_PRI;
+ 					confp->pri.nodetype = BRI_NETWORK_PTMP;
+ 				} else if (!strcasecmp(v->value, "bri_cpe_ptmp")) {
+ 					confp->chan.sig = SIG_PRI;
+ 					confp->chan.radio = 0;
+ 					confp->pri.nodetype = BRI_CPE_PTMP;
+ 				} else if (!strcasecmp(v->value, "bri_net")) {
+ 					confp->chan.radio = 0;
+ 					confp->chan.sig = SIG_PRI;
+ 					confp->pri.nodetype = BRI_NETWORK;
+ 				} else if (!strcasecmp(v->value, "bri_cpe")) {
+ 					confp->chan.sig = SIG_PRI;
+ 					confp->chan.radio = 0;
+ 					confp->pri.nodetype = BRI_CPE;
 #endif
 				} else {
 					ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
@@ -10931,9 +12152,21 @@ static int process_zap(struct zt_chan_co
 					confp->chan.priindication_oob = 1;
 				else if (!strcasecmp(v->value, "inband"))
 					confp->chan.priindication_oob = 0;
+				else if (!strcasecmp(v->value, "passthrough"))
+					confp->chan.priindication_oob = 2;
 				else
-					ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband' or 'outofband' at line %d\n",
+					ast_log(LOG_WARNING, "'%s' is not a valid pri indication value, should be 'inband', 'outofband' or 'passthrough' at line %d\n",
 						v->value, v->lineno);
+			} else if (!strcasecmp(v->name, "pritransfer")) {
+				if (!strcasecmp(v->value, "no"))
+					confp->chan.pritransfer = 0;
+				else if (!strcasecmp(v->value, "ect"))
+					confp->chan.pritransfer = 1;
+				else if (!strcasecmp(v->value, "hangup"))
+					confp->chan.pritransfer = 2;
+  				else
+ 					ast_log(LOG_WARNING, "'%s' is not a valid pri transfer value, should be 'no' , 'ect' or 'hangup' at line %d\n",
+  						v->value, v->lineno);
 			} else if (!strcasecmp(v->name, "priexclusive")) {
 				confp->chan.priexclusive = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "internationalprefix")) {
@@ -10946,6 +12179,10 @@ static int process_zap(struct zt_chan_co
 				ast_copy_string(confp->pri.privateprefix, v->value, sizeof(confp->pri.privateprefix));
 			} else if (!strcasecmp(v->name, "unknownprefix")) {
 				ast_copy_string(confp->pri.unknownprefix, v->value, sizeof(confp->pri.unknownprefix));
+ 			} else if (!strcasecmp(v->name, "nocid")) {
+  				ast_copy_string(confp->pri.nocid, v->value, sizeof(confp->pri.nocid) - 1);
+  			} else if (!strcasecmp(v->name, "withheldcid")) {
+  				ast_copy_string(confp->pri.withheldcid, v->value, sizeof(confp->pri.withheldcid) - 1);
 			} else if (!strcasecmp(v->name, "resetinterval")) {
 				if (!strcasecmp(v->value, "never"))
 					confp->pri.resetinterval = -1;
@@ -10962,6 +12199,8 @@ static int process_zap(struct zt_chan_co
 				ast_copy_string(confp->pri.idleext, v->value, sizeof(confp->pri.idleext));
 			} else if (!strcasecmp(v->name, "idledial")) {
 				ast_copy_string(confp->pri.idledial, v->value, sizeof(confp->pri.idledial));
+  			} else if (!strcasecmp(v->name, "pritrustusercid")) {
+  				confp->pri.usercid = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "overlapdial")) {
 				confp->pri.overlapdial = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "pritimer")) {
@@ -11263,6 +12502,7 @@ static int setup_zap(int reload)
 #ifdef HAVE_PRI
 	if (!reload) {
 		for (x = 0; x < NUM_SPANS; x++) {
+			pris[x].debugfd = -1;
 			if (pris[x].pvts[0]) {
 				if (start_pri(pris + x)) {
 					ast_log(LOG_ERROR, "Unable to start D-channel on span %d\n", x + 1);
@@ -11310,7 +12550,10 @@ static int load_module(void)
 	ast_string_field_init(&inuse, 16);
 	ast_string_field_set(&inuse, name, "GR-303InUse");
 	ast_cli_register_multiple(zap_pri_cli, sizeof(zap_pri_cli) / sizeof(struct ast_cli_entry));
+	ast_register_application(zapCD_app, app_zapCD, zapCD_synopsis, zapCD_tdesc);
+        ast_register_application(zapInband_app, app_zapInband, zapInband_synopsis, zapInband_tdesc);
 #endif	
+	ast_register_application(zapEC_app, app_zapEC, zapEC_synopsis, zapEC_tdesc);
 	ast_cli_register_multiple(zap_cli, sizeof(zap_cli) / sizeof(struct ast_cli_entry));
 	
 	memset(round_robin, 0, sizeof(round_robin));
@@ -11344,6 +12587,7 @@ static int zt_sendtext(struct ast_channe
 	float scont = 0.0;
 	int index;
 
+
 	index = zt_get_index(c, p, 0);
 	if (index < 0) {
 		ast_log(LOG_WARNING, "Huh?  I don't exist?\n");
--- asterisk-1.4.10.1~dfsg.orig/configs/zapata.conf.sample
+++ asterisk-1.4.10.1~dfsg/configs/zapata.conf.sample
@@ -123,9 +123,20 @@ switchtype=national
 ; 
 ; outofband:      Signal Busy/Congestion out of band with RELEASE/DISCONNECT
 ; inband:         Signal Busy/Congestion using in-band tones
+; passthrough:	  Listen to the telco
 ;
 ; priindication = outofband
 ;
+; PRI/BRI transfers (HOLD -> SETUP -> ECT/Hangup)
+;
+; Configure how transfers are initiated. ECT should be preferred
+;
+; no:		no transfers allowed (results in hangup)
+; ect:  	use ECT (facility)
+; hangup:	transfer on hangup (if your phones dont support ECT)
+;
+; pritransfer = ect
+;
 ; If you need to override the existing channels selection routine and force all
 ; PRI channels to be marked as exclusively selected, set this to yes.
 ; priexclusive = yes
--- asterisk-1.4.10.1~dfsg.orig/main/channel.c
+++ asterisk-1.4.10.1~dfsg/main/channel.c
@@ -4112,6 +4112,10 @@ enum ast_bridge_result ast_channel_bridg
 			c1->name, c1->_bridge->name);
 		return -1;
 	}
+
+	if (IS_DIGITAL(c0->transfercapability) || IS_DIGITAL(c1->transfercapability)) {
+	    config->flags = 0;
+	}
 	
 	/* Stop if we're a zombie or need a soft hangup */
 	if (ast_test_flag(c0, AST_FLAG_ZOMBIE) || ast_check_hangup_locked(c0) ||
