Fix a segfault that occured on AEL parsing on amd64 systems, e.g.
	context blah {
		lars => NoOp(Test);
		123456 => goto foo|1;
	};

Backported from upstream's r162013.
Upstream bug: http://bugs.digium.com/view.php?id=14019
Debian bug: #507883

  -- Faidon Liambotis <paravoid@debian.org>

--- a/pbx/ael/ael.flex
+++ b/pbx/ael/ael.flex
@@ -238,7 +238,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 
 [-a-zA-Z0-9'"_/.\<\>\*\+!$#\[\]][-a-zA-Z0-9'"_/.!\*\+\<\>\{\}$#\[\]]*	{
 		STORE_POS;
-		yylval->str = strdup(yytext);
+		yylval->str = ast_malloc(yyleng+1);
+		ast_copy_string(yylval->str, yytext, yyleng+1);
 		prev_word = yylval->str;
 		return word;
 	}
@@ -257,7 +258,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno, my_col, yytext);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			prev_word = 0;
 			return word;
 		}
@@ -266,8 +268,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			yymore();
 		} else {
 			STORE_LOC;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(')');
 			BEGIN(0);
 			return word;
@@ -289,7 +291,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n",
 				my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -317,7 +320,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno, my_col);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 
@@ -329,8 +333,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			BEGIN(0);
 			if ( !strcmp(yytext, ")") )
 				return RP;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(')');
 			return word;
 		}
@@ -343,8 +347,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			STORE_LOC;
 			if( !strcmp(yytext,"," ) )
 				return COMMA;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0';
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(',');
 			return word;
 		}
@@ -356,7 +360,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -379,7 +384,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -387,8 +393,8 @@ includes	{ STORE_POS; return KW_INCLUDES
 
 <semic>{NOSEMIC};	{
 		STORE_LOC;
-		yylval->str = strdup(yytext);
-		yylval->str[yyleng-1] = '\0';
+		yylval->str = ast_malloc(yyleng);
+		ast_copy_string(yylval->str, yytext, yyleng);
 		unput(';');
 		BEGIN(0);
 		return word;
--- a/pbx/pbx_ael.c
+++ b/pbx/pbx_ael.c
@@ -710,7 +710,7 @@ static int extension_matches(pval *here,
 	regex_t preg;
 	
 	/* simple case, they match exactly, the pattern and exten name */
-	if( !strcmp(pattern,exten) == 0 )
+	if( strcmp(pattern,exten) == 0 )
 		return 1;
 	
 	if ( pattern[0] == '_' ) {
@@ -2959,7 +2959,7 @@ static void gen_prios(struct ael_extensi
 			pr->type = AEL_APPCALL;
 			p->u2.goto_target = get_goto_target(p);
 			if( p->u2.goto_target ) {
-				p->u3.goto_target_in_case = p->u2.goto_target->u2.label_in_case = label_inside_case(p->u2.goto_target);
+				p->u3.goto_target_in_case = label_inside_case(p->u2.goto_target);
 			}
 			
 			if (!p->u1.list->next) /* just one */ {
--- a/pbx/ael/ael_lex.c
+++ b/pbx/ael/ael_lex.c
@@ -9,7 +9,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 33
+#define YY_FLEX_SUBMINOR_VERSION 35
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -32,7 +32,7 @@
 
 /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
 
-#if !defined __STDC_VERSION__ || __STDC_VERSION__ >= 199901L
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
 
 /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
  * if you want the limit (max/min) macros for int types. 
@@ -55,7 +55,6 @@ typedef int flex_int32_t;
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -86,6 +85,8 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! C99 */
+
 #endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
@@ -95,11 +96,12 @@ typedef unsigned int flex_uint32_t;
 
 #else	/* ! __cplusplus */
 
-#if __STDC__
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
 
 #define YY_USE_CONST
 
-#endif	/* __STDC__ */
+#endif	/* defined (__STDC__) */
 #endif	/* ! __cplusplus */
 
 #ifdef YY_USE_CONST
@@ -135,8 +137,6 @@ typedef void* yyscan_t;
 #define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
 #define yy_flex_debug yyg->yy_flex_debug_r
 
-int ael_yylex_init (yyscan_t* scanner);
-
 /* Enter a start condition.  This macro really ought to take a parameter,
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
@@ -194,14 +194,9 @@ typedef struct yy_buffer_state *YY_BUFFE
 
 #define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
 
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-
 #ifndef YY_TYPEDEF_YY_SIZE_T
 #define YY_TYPEDEF_YY_SIZE_T
-typedef unsigned int yy_size_t;
+typedef size_t yy_size_t;
 #endif
 
 #ifndef YY_STRUCT_YY_BUFFER_STATE
@@ -905,7 +900,7 @@ static void pbcwhere(const char *text, i
 #define	STORE_POS
 #define	STORE_LOC
 #endif
-#line 908 "ael_lex.c"
+#line 903 "ael_lex.c"
 
 #define INITIAL 0
 #define paren 1
@@ -971,6 +966,10 @@ static int yy_init_globals (yyscan_t yys
     
     #    define yylloc yyg->yylloc_r
     
+int ael_yylex_init (yyscan_t* scanner);
+
+int ael_yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);
+
 /* Accessor methods to globals.
    These are made visible to non-reentrant scanners for convenience. */
 
@@ -1042,7 +1041,12 @@ static int input (yyscan_t yyscanner );
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -1050,7 +1054,7 @@ static int input (yyscan_t yyscanner );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1115,9 +1119,11 @@ static int input (yyscan_t yyscanner );
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
 
-extern int ael_yylex (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
+extern int ael_yylex \
+               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
 
-#define YY_DECL int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
+#define YY_DECL int ael_yylex \
+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -1147,7 +1153,7 @@ YY_DECL
 #line 185 "ael.flex"
 
 
-#line 1150 "ael_lex.c"
+#line 1156 "ael_lex.c"
 
     yylval = yylval_param;
 
@@ -1489,7 +1495,8 @@ YY_RULE_SETUP
 #line 239 "ael.flex"
 {
 		STORE_POS;
-		yylval->str = strdup(yytext);
+		yylval->str = ast_malloc(yyleng+1);
+		ast_copy_string(yylval->str, yytext, yyleng+1);
 		prev_word = yylval->str;
 		return word;
 	}
@@ -1504,13 +1511,14 @@ YY_RULE_SETUP
 case 51:
 /* rule 51 can match eol */
 YY_RULE_SETUP
-#line 255 "ael.flex"
+#line 256 "ael.flex"
 {
 		if ( pbcpop(')') ) {	/* error */
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno, my_col, yytext);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			prev_word = 0;
 			return word;
 		}
@@ -1519,8 +1527,8 @@ YY_RULE_SETUP
 			yymore();
 		} else {
 			STORE_LOC;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(')');
 			BEGIN(0);
 			return word;
@@ -1530,7 +1538,7 @@ YY_RULE_SETUP
 case 52:
 /* rule 52 can match eol */
 YY_RULE_SETUP
-#line 277 "ael.flex"
+#line 279 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1542,7 +1550,7 @@ YY_RULE_SETUP
 case 53:
 /* rule 53 can match eol */
 YY_RULE_SETUP
-#line 285 "ael.flex"
+#line 287 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c))  { /* error */
@@ -1550,7 +1558,8 @@ YY_RULE_SETUP
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n",
 				my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -1567,7 +1576,7 @@ YY_RULE_SETUP
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 307 "ael.flex"
+#line 310 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1579,13 +1588,14 @@ YY_RULE_SETUP
 case 55:
 /* rule 55 can match eol */
 YY_RULE_SETUP
-#line 315 "ael.flex"
+#line 318 "ael.flex"
 {
 		if ( pbcpop(')') ) { /* error */
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno, my_col);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 
@@ -1597,8 +1607,8 @@ YY_RULE_SETUP
 			BEGIN(0);
 			if ( !strcmp(yytext, ")") )
 				return RP;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(')');
 			return word;
 		}
@@ -1607,7 +1617,7 @@ YY_RULE_SETUP
 case 56:
 /* rule 56 can match eol */
 YY_RULE_SETUP
-#line 339 "ael.flex"
+#line 343 "ael.flex"
 {
 		if( parencount != 0) { /* printf("Folding in a comma!\n"); */
 			yymore();
@@ -1615,8 +1625,8 @@ YY_RULE_SETUP
 			STORE_LOC;
 			if( !strcmp(yytext,"," ) )
 				return COMMA;
-			yylval->str = strdup(yytext);
-			yylval->str[yyleng-1] = '\0';
+			yylval->str = ast_malloc(yyleng);
+			ast_copy_string(yylval->str, yytext, yyleng);
 			unput(',');
 			return word;
 		}
@@ -1625,14 +1635,15 @@ YY_RULE_SETUP
 case 57:
 /* rule 57 can match eol */
 YY_RULE_SETUP
-#line 353 "ael.flex"
+#line 357 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -1646,7 +1657,7 @@ YY_RULE_SETUP
 case 58:
 /* rule 58 can match eol */
 YY_RULE_SETUP
-#line 370 "ael.flex"
+#line 375 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		yymore();
@@ -1656,14 +1667,15 @@ YY_RULE_SETUP
 case 59:
 /* rule 59 can match eol */
 YY_RULE_SETUP
-#line 376 "ael.flex"
+#line 381 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
 			STORE_LOC;
 			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
 			BEGIN(0);
-			yylval->str = strdup(yytext);
+			yylval->str = ast_malloc(yyleng+1);
+			ast_copy_string(yylval->str, yytext, yyleng+1);
 			return word;
 		}
 		yymore();
@@ -1672,11 +1684,11 @@ YY_RULE_SETUP
 case 60:
 /* rule 60 can match eol */
 YY_RULE_SETUP
-#line 388 "ael.flex"
+#line 394 "ael.flex"
 {
 		STORE_LOC;
-		yylval->str = strdup(yytext);
-		yylval->str[yyleng-1] = '\0';
+		yylval->str = ast_malloc(yyleng);
+		ast_copy_string(yylval->str, yytext, yyleng);
 		unput(';');
 		BEGIN(0);
 		return word;
@@ -1685,7 +1697,7 @@ YY_RULE_SETUP
 case 61:
 /* rule 61 can match eol */
 YY_RULE_SETUP
-#line 397 "ael.flex"
+#line 403 "ael.flex"
 {
 		char fnamebuf[1024],*p1,*p2;
 		int glob_ret;
@@ -1731,7 +1743,7 @@ case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
 case YY_STATE_EOF(comment):
-#line 438 "ael.flex"
+#line 444 "ael.flex"
 {
 		char fnamebuf[2048];
 		if (include_stack_index > 0 && include_stack[include_stack_index-1].globbuf_pos < include_stack[include_stack_index-1].globbuf.gl_pathc-1) {
@@ -1766,10 +1778,10 @@ case YY_STATE_EOF(comment):
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 470 "ael.flex"
+#line 476 "ael.flex"
 ECHO;
 	YY_BREAK
-#line 1772 "ael_lex.c"
+#line 1784 "ael_lex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2000,7 +2012,7 @@ static int yy_get_next_buffer (yyscan_t 
 
 		/* Read in more data. */
 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
+			yyg->yy_n_chars, (size_t) num_to_read );
 
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
 		}
@@ -2024,6 +2036,14 @@ static int yy_get_next_buffer (yyscan_t 
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
+	if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) ael_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
 	yyg->yy_n_chars += number_to_move;
 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
@@ -2452,7 +2472,9 @@ static void ael_yyensure_buffer_stack (y
 		yyg->yy_buffer_stack = (struct yy_buffer_state**)ael_yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
-		
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in ael_yyensure_buffer_stack()" );
+								  
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
 				
 		yyg->yy_buffer_stack_max = num_to_alloc;
@@ -2470,6 +2492,8 @@ static void ael_yyensure_buffer_stack (y
 								(yyg->yy_buffer_stack,
 								num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in ael_yyensure_buffer_stack()" );
 
 		/* zero only the new slots.*/
 		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
@@ -2514,7 +2538,7 @@ YY_BUFFER_STATE ael_yy_scan_buffer  (cha
 
 /** Setup the input buffer state to scan a string. The next call to ael_yylex() will
  * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
+ * @param yystr a NUL-terminated string to scan
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
@@ -2528,8 +2552,8 @@ YY_BUFFER_STATE ael_yy_scan_string (yyco
 
 /** Setup the input buffer state to scan the given bytes. The next call to ael_yylex() will
  * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
@@ -2788,6 +2812,42 @@ int ael_yylex_init(yyscan_t* ptr_yy_glob
     return yy_init_globals ( *ptr_yy_globals );
 }
 
+/* ael_yylex_init_extra has the same functionality as ael_yylex_init, but follows the
+ * convention of taking the scanner as the last argument. Note however, that
+ * this is a *pointer* to a scanner, as it will be allocated by this call (and
+ * is the reason, too, why this function also must handle its own declaration).
+ * The user defined value in the first argument will be available to ael_yyalloc in
+ * the yyextra field.
+ */
+
+int ael_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
+
+{
+    struct yyguts_t dummy_yyguts;
+
+    ael_yyset_extra (yy_user_defined, &dummy_yyguts);
+
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+	
+    *ptr_yy_globals = (yyscan_t) ael_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
+	
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+    
+    /* By setting to 0xAA, we expose bugs in
+    yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+    
+    ael_yyset_extra (yy_user_defined, *ptr_yy_globals);
+    
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
 static int yy_init_globals (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2894,7 +2954,7 @@ void *ael_yyrealloc  (void * ptr, yy_siz
 
 #define YYTABLES_NAME "yytables"
 
-#line 470 "ael.flex"
+#line 476 "ael.flex"
 
 
 
